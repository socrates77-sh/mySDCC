!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
ADDRESSMOD	SDCCy.c	/^     ADDRESSMOD = 297,$/;"	e	enum:yytokentype	file:
ADDRESSMOD	SDCCy.c	222;"	d	file:
ADDRESSMOD	SDCCy.h	/^     ADDRESSMOD = 297,$/;"	e	enum:yytokentype
ADDRESSMOD	SDCCy.h	198;"	d
ADDRESS_OF	SDCCy.c	/^     ADDRESS_OF = 349,$/;"	e	enum:yytokentype	file:
ADDRESS_OF	SDCCy.c	274;"	d	file:
ADDRESS_OF	SDCCy.h	/^     ADDRESS_OF = 349,$/;"	e	enum:yytokentype
ADDRESS_OF	SDCCy.h	250;"	d
ADDRSPACE_NAME	SDCCy.c	/^     ADDRSPACE_NAME = 260,$/;"	e	enum:yytokentype	file:
ADDRSPACE_NAME	SDCCy.c	185;"	d	file:
ADDRSPACE_NAME	SDCCy.h	/^     ADDRSPACE_NAME = 260,$/;"	e	enum:yytokentype
ADDRSPACE_NAME	SDCCy.h	161;"	d
ADDTOCHAIN	SDCCicode.h	55;"	d
ADD_ASSIGN	SDCCy.c	/^     ADD_ASSIGN = 279,$/;"	e	enum:yytokentype	file:
ADD_ASSIGN	SDCCy.c	204;"	d	file:
ADD_ASSIGN	SDCCy.h	/^     ADD_ASSIGN = 279,$/;"	e	enum:yytokentype
ADD_ASSIGN	SDCCy.h	180;"	d
ADD_SUBTRACT_ITEMP	SDCCicode.h	286;"	d
ALLOCATE	SDCCast.c	54;"	d	file:
AND_ASSIGN	SDCCy.c	/^     AND_ASSIGN = 283,$/;"	e	enum:yytokentype	file:
AND_ASSIGN	SDCCy.c	208;"	d	file:
AND_ASSIGN	SDCCy.h	/^     AND_ASSIGN = 283,$/;"	e	enum:yytokentype
AND_ASSIGN	SDCCy.h	184;"	d
AND_OP	SDCCy.c	/^     AND_OP = 274,$/;"	e	enum:yytokentype	file:
AND_OP	SDCCy.c	199;"	d	file:
AND_OP	SDCCy.h	/^     AND_OP = 274,$/;"	e	enum:yytokentype
AND_OP	SDCCy.h	175;"	d
ARRAY	SDCCsymt.h	/^  ARRAY,$/;"	e
ARRAYINIT	SDCCy.c	/^     ARRAYINIT = 374,$/;"	e	enum:yytokentype	file:
ARRAYINIT	SDCCy.c	299;"	d	file:
ARRAYINIT	SDCCy.h	/^     ARRAYINIT = 374,$/;"	e	enum:yytokentype
ARRAYINIT	SDCCy.h	275;"	d
ASM	SDCCy.c	/^     ASM = 382$/;"	e	enum:yytokentype	file:
ASM	SDCCy.c	307;"	d	file:
ASM	SDCCy.h	/^     ASM = 382$/;"	e	enum:yytokentype
ASM	SDCCy.h	283;"	d
ASM_MAPPING	SDCCasm.h	/^ASM_MAPPING;$/;"	t
ASM_MAPPINGS	SDCCasm.h	/^typedef struct _ASM_MAPPINGS ASM_MAPPINGS;$/;"	t
ASSIGNMENT	SDCCicode.h	271;"	d
ASSIGNMENT_TO_SELF	SDCCicode.h	291;"	d
ASSIGN_ITEMP_TO_ITEMP	SDCCicode.h	281;"	d
ASSIGN_ITEMP_TO_SYM	SDCCicode.h	277;"	d
ASSIGN_SYM_TO_ITEMP	SDCCicode.h	273;"	d
ASTTYPE	SDCCast.h	/^} ASTTYPE;$/;"	t
AST_ARGREG	SDCCast.h	155;"	d
AST_FLOAT_VALUE	SDCCast.h	149;"	d
AST_FOR	SDCCast.h	154;"	d
AST_SYMBOL	SDCCast.h	151;"	d
AST_ULONG_VALUE	SDCCast.h	150;"	d
AST_VALUE	SDCCast.h	152;"	d
AST_VALUES	SDCCast.h	153;"	d
AT	SDCCy.c	/^     AT = 298,$/;"	e	enum:yytokentype	file:
AT	SDCCy.c	223;"	d	file:
AT	SDCCy.h	/^     AT = 298,$/;"	e	enum:yytokentype
AT	SDCCy.h	199;"	d
AUTO	SDCCy.c	/^     AUTO = 289,$/;"	e	enum:yytokentype	file:
AUTO	SDCCy.c	214;"	d	file:
AUTO	SDCCy.h	/^     AUTO = 289,$/;"	e	enum:yytokentype
AUTO	SDCCy.h	190;"	d
AddrspaceTab	SDCCsymt.c	/^bucket *AddrspaceTab[256];      \/* the named address space table  *\/$/;"	v
BANKED	SDCCy.c	/^     BANKED = 309,$/;"	e	enum:yytokentype	file:
BANKED	SDCCy.c	234;"	d	file:
BANKED	SDCCy.h	/^     BANKED = 309,$/;"	e	enum:yytokentype
BANKED	SDCCy.h	210;"	d
BANKED_FUNCTIONS	SDCCsymt.h	447;"	d
BEGIN	SDCClex.c	79;"	d	file:
BIT	SDCCy.c	/^     BIT = 325,$/;"	e	enum:yytokentype	file:
BIT	SDCCy.c	250;"	d	file:
BIT	SDCCy.h	/^     BIT = 325,$/;"	e	enum:yytokentype
BIT	SDCCy.h	226;"	d
BITSIZE	SDCCglobl.h	151;"	d
BITVAR_PAD	SDCCsymt.h	37;"	d
BITWISEAND	SDCCy.c	/^     BITWISEAND = 357,$/;"	e	enum:yytokentype	file:
BITWISEAND	SDCCy.c	282;"	d	file:
BITWISEAND	SDCCy.h	/^     BITWISEAND = 357,$/;"	e	enum:yytokentype
BITWISEAND	SDCCy.h	258;"	d
BIT_NAME	SDCCmem.h	54;"	d
BLOCK	SDCCy.c	/^     BLOCK = 370,$/;"	e	enum:yytokentype	file:
BLOCK	SDCCy.c	295;"	d	file:
BLOCK	SDCCy.h	/^     BLOCK = 370,$/;"	e	enum:yytokentype
BLOCK	SDCCy.h	271;"	d
BOOLSIZE	SDCCglobl.h	142;"	d
BREAK	SDCCy.c	/^     BREAK = 341,$/;"	e	enum:yytokentype	file:
BREAK	SDCCy.c	266;"	d	file:
BREAK	SDCCy.h	/^     BREAK = 341,$/;"	e	enum:yytokentype
BREAK	SDCCy.h	242;"	d
BREAKLINE	SDCCmem.c	1232;"	d	file:
BitBankUsed	SDCCmain.c	/^int BitBankUsed;                \/* MB: overlayable bit bank *\/$/;"	v
CABS_NAME	SDCCmem.h	60;"	d
CALL	SDCCy.c	/^     CALL = 367,$/;"	e	enum:yytokentype	file:
CALL	SDCCy.c	292;"	d	file:
CALL	SDCCy.h	/^     CALL = 367,$/;"	e	enum:yytokentype
CALL	SDCCy.h	268;"	d
CAN_EVAL	SDCCast.h	159;"	d
CASE	SDCCy.c	/^     CASE = 331,$/;"	e	enum:yytokentype	file:
CASE	SDCCy.c	256;"	d	file:
CASE	SDCCy.h	/^     CASE = 331,$/;"	e	enum:yytokentype
CASE	SDCCy.h	232;"	d
CAST	SDCCy.c	/^     CAST = 366,$/;"	e	enum:yytokentype	file:
CAST	SDCCy.c	291;"	d	file:
CAST	SDCCy.h	/^     CAST = 366,$/;"	e	enum:yytokentype
CAST	SDCCy.h	267;"	d
CCR_ALWAYS_FALSE	SDCCval.h	/^  CCR_ALWAYS_FALSE,$/;"	e
CCR_ALWAYS_TRUE	SDCCval.h	/^  CCR_ALWAYS_TRUE$/;"	e
CCR_OK	SDCCval.h	/^  CCR_OK,                       \/* evaluate at runtime *\/$/;"	e
CCR_OVL	SDCCval.h	/^  CCR_OVL,$/;"	e
CCR_RESULT	SDCCval.h	/^CCR_RESULT;$/;"	t
CHARSIZE	SDCCglobl.h	143;"	d
CLAT_ADD_SET	SDCCargs.h	/^  CLAT_ADD_SET$/;"	e	enum:cl_opt_arg_type
CLAT_BOOLEAN	SDCCargs.h	/^  CLAT_BOOLEAN = 0, \/* has to be zero! *\/$/;"	e	enum:cl_opt_arg_type
CLAT_INTEGER	SDCCargs.h	/^  CLAT_INTEGER,$/;"	e	enum:cl_opt_arg_type
CLAT_SET	SDCCargs.h	/^  CLAT_SET,$/;"	e	enum:cl_opt_arg_type
CLAT_STRING	SDCCargs.h	/^  CLAT_STRING,$/;"	e	enum:cl_opt_arg_type
CODE	SDCCy.c	/^     CODE = 291,$/;"	e	enum:yytokentype	file:
CODE	SDCCy.c	216;"	d	file:
CODE	SDCCy.h	/^     CODE = 291,$/;"	e	enum:yytokentype
CODE	SDCCy.h	192;"	d
CODE_NAME	SDCCmem.h	47;"	d
COMMON_H	common.h	27;"	d
CONDITIONAL	SDCCicode.h	/^  CONDITIONAL = 0,$/;"	e
CONSTANT	SDCCy.c	/^     CONSTANT = 261,$/;"	e	enum:yytokentype	file:
CONSTANT	SDCCy.c	186;"	d	file:
CONSTANT	SDCCy.h	/^     CONSTANT = 261,$/;"	e	enum:yytokentype
CONSTANT	SDCCy.h	162;"	d
CONST_NAME	SDCCmem.h	59;"	d
CONTINUE	SDCCy.c	/^     CONTINUE = 340,$/;"	e	enum:yytokentype	file:
CONTINUE	SDCCy.c	265;"	d	file:
CONTINUE	SDCCy.h	/^     CONTINUE = 340,$/;"	e	enum:yytokentype
CONTINUE	SDCCy.h	241;"	d
COPYTYPE	SDCCglobl.h	177;"	d
CPOINTER	SDCCsymt.h	/^  CPOINTER,                         \/* pointer to code space *\/$/;"	e
CRITICAL	SDCCy.c	/^     CRITICAL = 307,$/;"	e	enum:yytokentype	file:
CRITICAL	SDCCy.c	232;"	d	file:
CRITICAL	SDCCy.h	/^     CRITICAL = 307,$/;"	e	enum:yytokentype
CRITICAL	SDCCy.h	208;"	d
CodePtrPointsToConst	SDCCast.c	/^CodePtrPointsToConst (sym_link * t)$/;"	f
D	SDCCgen.c	25;"	d	file:
DATA	SDCCy.c	/^     DATA = 303,$/;"	e	enum:yytokentype	file:
DATA	SDCCy.c	228;"	d	file:
DATA	SDCCy.h	/^     DATA = 303,$/;"	e	enum:yytokentype
DATA	SDCCy.h	204;"	d
DATADIR	SDCCsystem.c	27;"	d	file:
DATA_NAME	SDCCmem.h	48;"	d
DCL_ELEM	SDCCsymt.h	396;"	d
DCL_PTR_ADDRSPACE	SDCCsymt.h	400;"	d
DCL_PTR_CONST	SDCCsymt.h	397;"	d
DCL_PTR_RESTRICT	SDCCsymt.h	399;"	d
DCL_PTR_VOLATILE	SDCCsymt.h	398;"	d
DCL_TSPEC	SDCCsymt.h	401;"	d
DCL_TYPE	SDCCsymt.h	395;"	d
DEALLOCATE	SDCCast.c	55;"	d	file:
DEBUGFILE	SDCCdebug.h	/^}DEBUGFILE;$/;"	t
DEBUG_CF	SDCCast.c	25;"	d	file:
DECLARATOR	SDCCsymt.h	/^  DECLARATOR = 1,$/;"	e
DECLARATOR_TYPE	SDCCsymt.h	/^DECLARATOR_TYPE;$/;"	t
DECLSPEC2TXT	SDCCsymt.h	238;"	d
DEC_OP	SDCCy.c	/^     DEC_OP = 267,$/;"	e	enum:yytokentype	file:
DEC_OP	SDCCy.c	192;"	d	file:
DEC_OP	SDCCy.h	/^     DEC_OP = 267,$/;"	e	enum:yytokentype
DEC_OP	SDCCy.h	168;"	d
DEFAULT	SDCCy.c	/^     DEFAULT = 332,$/;"	e	enum:yytokentype	file:
DEFAULT	SDCCy.c	257;"	d	file:
DEFAULT	SDCCy.h	/^     DEFAULT = 332,$/;"	e	enum:yytokentype
DEFAULT	SDCCy.h	233;"	d
DEFAULT_ERROR_OUT	SDCCerr.c	29;"	d	file:
DEFAULT_ERROR_OUT	SDCCerr.c	31;"	d	file:
DEFAULT_HTAB_SIZE	SDCChasht.c	33;"	d	file:
DEFPOOLSTACK	SDCCglobl.h	160;"	d
DEFSETFUNC	SDCCBBlock.c	/^DEFSETFUNC (ifFromIs)$/;"	f
DEFSETFUNC	SDCCBBlock.c	/^DEFSETFUNC (printEntryLabel)$/;"	f
DEFSETFUNC	SDCCast.c	/^DEFSETFUNC (resetParmKey)$/;"	f
DEFSETFUNC	SDCCcflow.c	/^DEFSETFUNC (DFOrdering)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (delGetPointerSucc)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (diCodeForSym)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (findCheaperOp)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (findPointerSet)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (findPrevIc)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (iCodeKeyIs)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifAnyGetPointer)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifAnyUnrestrictedGetPointer)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifAnyUnrestrictedSetPointer)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifAssignedFromGlobal)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifDefGlobal)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifDefGlobalAliasableByPtr)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifDefSymIsX)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifDiCodeIsX)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifFromAddrTaken)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifFromGlobal)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifFromGlobalAliasableByPtr)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifOperandsHave)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifPointerGet)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (ifPointerSet)$/;"	f
DEFSETFUNC	SDCCcse.c	/^DEFSETFUNC (removeFromInExprs)$/;"	f
DEFSETFUNC	SDCCdflow.c	/^DEFSETFUNC (ifKilledInBlock)$/;"	f
DEFSETFUNC	SDCCdflow.c	/^DEFSETFUNC (isDefAlive)$/;"	f
DEFSETFUNC	SDCCdflow.c	/^DEFSETFUNC (mergeInDefs)$/;"	f
DEFSETFUNC	SDCCdflow.c	/^DEFSETFUNC (mergeInExprs)$/;"	f
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (addDefInExprs)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (addToExitsMarkDepth)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (backEdges)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (createLoop)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (dominatedBy)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (findInduction)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (hasNonPtrUse)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (ifMerged)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (insertIntoLoop)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (isNotInBlocks)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (mergeInnerLoops)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (mergeRegions)$/;"	f	file:
DEFSETFUNC	SDCCloop.c	/^DEFSETFUNC (pointerAssigned)$/;"	f	file:
DEFSETFUNC	SDCCset.h	47;"	d
DELETE_ACTION	SDCChasht.h	/^DELETE_ACTION;$/;"	t
DELETE_CHAIN	SDCChasht.h	/^    DELETE_CHAIN = 1,$/;"	e
DELETE_ITEM	SDCChasht.h	/^    DELETE_ITEM$/;"	e
DESIGNATOR_ARRAY	SDCCval.h	/^    DESIGNATOR_ARRAY$/;"	e
DESIGNATOR_STRUCT	SDCCval.h	/^    DESIGNATOR_STRUCT,$/;"	e
DIV_ASSIGN	SDCCy.c	/^     DIV_ASSIGN = 277,$/;"	e	enum:yytokentype	file:
DIV_ASSIGN	SDCCy.c	202;"	d	file:
DIV_ASSIGN	SDCCy.h	/^     DIV_ASSIGN = 277,$/;"	e	enum:yytokentype
DIV_ASSIGN	SDCCy.h	178;"	d
DO	SDCCy.c	/^     DO = 337,$/;"	e	enum:yytokentype	file:
DO	SDCCy.c	262;"	d	file:
DO	SDCCy.h	/^     DO = 337,$/;"	e	enum:yytokentype
DO	SDCCy.h	238;"	d
DOUBLE	SDCCy.c	/^     DOUBLE = 320,$/;"	e	enum:yytokentype	file:
DOUBLE	SDCCy.c	245;"	d	file:
DOUBLE	SDCCy.h	/^     DOUBLE = 320,$/;"	e	enum:yytokentype
DOUBLE	SDCCy.h	221;"	d
DUMMY_READ_VOLATILE	SDCCy.c	/^     DUMMY_READ_VOLATILE = 375,$/;"	e	enum:yytokentype	file:
DUMMY_READ_VOLATILE	SDCCy.c	300;"	d	file:
DUMMY_READ_VOLATILE	SDCCy.h	/^     DUMMY_READ_VOLATILE = 375,$/;"	e	enum:yytokentype
DUMMY_READ_VOLATILE	SDCCy.h	276;"	d
DUMP_CSE	SDCCglobl.h	405;"	d
DUMP_DEADCODE	SDCCglobl.h	408;"	d
DUMP_DFLOW	SDCCglobl.h	406;"	d
DUMP_GCSE	SDCCglobl.h	407;"	d
DUMP_LOOP	SDCCglobl.h	409;"	d
DUMP_LOOPD	SDCCglobl.h	411;"	d
DUMP_LOOPG	SDCCglobl.h	410;"	d
DUMP_LRANGE	SDCCglobl.h	415;"	d
DUMP_OUTPUT	altlex.c	10;"	d	file:
DUMP_PACK	SDCCglobl.h	413;"	d
DUMP_RANGE	SDCCglobl.h	412;"	d
DUMP_RASSGN	SDCCglobl.h	414;"	d
DUMP_RAW0	SDCCglobl.h	403;"	d
DUMP_RAW1	SDCCglobl.h	404;"	d
DW_ATE_address	SDCCdwarf2.h	251;"	d
DW_ATE_boolean	SDCCdwarf2.h	252;"	d
DW_ATE_complex_float	SDCCdwarf2.h	253;"	d
DW_ATE_float	SDCCdwarf2.h	254;"	d
DW_ATE_signed	SDCCdwarf2.h	255;"	d
DW_ATE_signed_char	SDCCdwarf2.h	256;"	d
DW_ATE_unsigned	SDCCdwarf2.h	257;"	d
DW_ATE_unsigned_char	SDCCdwarf2.h	258;"	d
DW_AT_abstract_origin	SDCCdwarf2.h	111;"	d
DW_AT_accessibility	SDCCdwarf2.h	112;"	d
DW_AT_address_class	SDCCdwarf2.h	113;"	d
DW_AT_artificial	SDCCdwarf2.h	114;"	d
DW_AT_base_types	SDCCdwarf2.h	115;"	d
DW_AT_bit_offset	SDCCdwarf2.h	86;"	d
DW_AT_bit_size	SDCCdwarf2.h	87;"	d
DW_AT_byte_size	SDCCdwarf2.h	85;"	d
DW_AT_calling_convention	SDCCdwarf2.h	116;"	d
DW_AT_common_reference	SDCCdwarf2.h	97;"	d
DW_AT_comp_dir	SDCCdwarf2.h	98;"	d
DW_AT_const_value	SDCCdwarf2.h	99;"	d
DW_AT_containing_type	SDCCdwarf2.h	100;"	d
DW_AT_count	SDCCdwarf2.h	117;"	d
DW_AT_data_member_location	SDCCdwarf2.h	118;"	d
DW_AT_decl_column	SDCCdwarf2.h	119;"	d
DW_AT_decl_file	SDCCdwarf2.h	120;"	d
DW_AT_decl_line	SDCCdwarf2.h	121;"	d
DW_AT_declaration	SDCCdwarf2.h	122;"	d
DW_AT_default_value	SDCCdwarf2.h	101;"	d
DW_AT_discr	SDCCdwarf2.h	92;"	d
DW_AT_discr_list	SDCCdwarf2.h	123;"	d
DW_AT_discr_value	SDCCdwarf2.h	93;"	d
DW_AT_encoding	SDCCdwarf2.h	124;"	d
DW_AT_external	SDCCdwarf2.h	125;"	d
DW_AT_frame_base	SDCCdwarf2.h	126;"	d
DW_AT_friend	SDCCdwarf2.h	127;"	d
DW_AT_hi_user	SDCCdwarf2.h	141;"	d
DW_AT_high_pc	SDCCdwarf2.h	90;"	d
DW_AT_identifier_case	SDCCdwarf2.h	128;"	d
DW_AT_import	SDCCdwarf2.h	95;"	d
DW_AT_inline	SDCCdwarf2.h	102;"	d
DW_AT_is_optional	SDCCdwarf2.h	103;"	d
DW_AT_language	SDCCdwarf2.h	91;"	d
DW_AT_lo_user	SDCCdwarf2.h	140;"	d
DW_AT_location	SDCCdwarf2.h	82;"	d
DW_AT_low_pc	SDCCdwarf2.h	89;"	d
DW_AT_lower_bound	SDCCdwarf2.h	104;"	d
DW_AT_macro_info	SDCCdwarf2.h	129;"	d
DW_AT_name	SDCCdwarf2.h	83;"	d
DW_AT_namelist_item	SDCCdwarf2.h	130;"	d
DW_AT_ordering	SDCCdwarf2.h	84;"	d
DW_AT_priority	SDCCdwarf2.h	131;"	d
DW_AT_producer	SDCCdwarf2.h	105;"	d
DW_AT_prototyped	SDCCdwarf2.h	106;"	d
DW_AT_return_addr	SDCCdwarf2.h	107;"	d
DW_AT_segment	SDCCdwarf2.h	132;"	d
DW_AT_sibling	SDCCdwarf2.h	81;"	d
DW_AT_specification	SDCCdwarf2.h	133;"	d
DW_AT_start_scope	SDCCdwarf2.h	108;"	d
DW_AT_static_link	SDCCdwarf2.h	134;"	d
DW_AT_stmt_list	SDCCdwarf2.h	88;"	d
DW_AT_stride_size	SDCCdwarf2.h	109;"	d
DW_AT_string_length	SDCCdwarf2.h	96;"	d
DW_AT_type	SDCCdwarf2.h	135;"	d
DW_AT_upper_bound	SDCCdwarf2.h	110;"	d
DW_AT_use_location	SDCCdwarf2.h	136;"	d
DW_AT_user_block	SDCCdwarf2.h	143;"	d
DW_AT_user_level	SDCCdwarf2.h	144;"	d
DW_AT_variable_parameter	SDCCdwarf2.h	137;"	d
DW_AT_virtuality	SDCCdwarf2.h	138;"	d
DW_AT_visibility	SDCCdwarf2.h	94;"	d
DW_AT_vtable_elem_location	SDCCdwarf2.h	139;"	d
DW_CC_nocall	SDCCdwarf2.h	262;"	d
DW_CC_normal	SDCCdwarf2.h	260;"	d
DW_CC_program	SDCCdwarf2.h	261;"	d
DW_CFA_advance_loc	SDCCdwarf2.h	284;"	d
DW_CFA_advance_loc1	SDCCdwarf2.h	288;"	d
DW_CFA_advance_loc2	SDCCdwarf2.h	289;"	d
DW_CFA_advance_loc4	SDCCdwarf2.h	290;"	d
DW_CFA_def_cfa	SDCCdwarf2.h	298;"	d
DW_CFA_def_cfa_offset	SDCCdwarf2.h	300;"	d
DW_CFA_def_cfa_register	SDCCdwarf2.h	299;"	d
DW_CFA_hi_user	SDCCdwarf2.h	303;"	d
DW_CFA_lo_user	SDCCdwarf2.h	302;"	d
DW_CFA_nop	SDCCdwarf2.h	301;"	d
DW_CFA_offset	SDCCdwarf2.h	285;"	d
DW_CFA_offset_extended	SDCCdwarf2.h	291;"	d
DW_CFA_register	SDCCdwarf2.h	295;"	d
DW_CFA_remember_state	SDCCdwarf2.h	296;"	d
DW_CFA_restore	SDCCdwarf2.h	286;"	d
DW_CFA_restore_extended	SDCCdwarf2.h	292;"	d
DW_CFA_restore_state	SDCCdwarf2.h	297;"	d
DW_CFA_same_value	SDCCdwarf2.h	294;"	d
DW_CFA_set_loc	SDCCdwarf2.h	287;"	d
DW_CFA_undefined	SDCCdwarf2.h	293;"	d
DW_CHILDREN_no	SDCCdwarf2.h	76;"	d
DW_CHILDREN_yes	SDCCdwarf2.h	77;"	d
DW_FORM_addr	SDCCdwarf2.h	146;"	d
DW_FORM_block	SDCCdwarf2.h	153;"	d
DW_FORM_block1	SDCCdwarf2.h	154;"	d
DW_FORM_block2	SDCCdwarf2.h	147;"	d
DW_FORM_block4	SDCCdwarf2.h	148;"	d
DW_FORM_data1	SDCCdwarf2.h	155;"	d
DW_FORM_data2	SDCCdwarf2.h	149;"	d
DW_FORM_data4	SDCCdwarf2.h	150;"	d
DW_FORM_data8	SDCCdwarf2.h	151;"	d
DW_FORM_flag	SDCCdwarf2.h	156;"	d
DW_FORM_indirect	SDCCdwarf2.h	165;"	d
DW_FORM_ref1	SDCCdwarf2.h	161;"	d
DW_FORM_ref2	SDCCdwarf2.h	162;"	d
DW_FORM_ref4	SDCCdwarf2.h	163;"	d
DW_FORM_ref_addr	SDCCdwarf2.h	160;"	d
DW_FORM_ref_udata	SDCCdwarf2.h	164;"	d
DW_FORM_sdata	SDCCdwarf2.h	157;"	d
DW_FORM_string	SDCCdwarf2.h	152;"	d
DW_FORM_strp	SDCCdwarf2.h	158;"	d
DW_FORM_udata	SDCCdwarf2.h	159;"	d
DW_LANG_C89	SDCCdwarf2.h	79;"	d
DW_LNE_define_file	SDCCdwarf2.h	276;"	d
DW_LNE_end_sequence	SDCCdwarf2.h	274;"	d
DW_LNE_set_address	SDCCdwarf2.h	275;"	d
DW_LNS_advance_line	SDCCdwarf2.h	266;"	d
DW_LNS_advance_pc	SDCCdwarf2.h	265;"	d
DW_LNS_const_add_pc	SDCCdwarf2.h	271;"	d
DW_LNS_copy	SDCCdwarf2.h	264;"	d
DW_LNS_fixed_advance_pc	SDCCdwarf2.h	272;"	d
DW_LNS_negate_stmt	SDCCdwarf2.h	269;"	d
DW_LNS_set_basic_block	SDCCdwarf2.h	270;"	d
DW_LNS_set_column	SDCCdwarf2.h	268;"	d
DW_LNS_set_file	SDCCdwarf2.h	267;"	d
DW_MACINFO_define	SDCCdwarf2.h	278;"	d
DW_MACINFO_end_file	SDCCdwarf2.h	281;"	d
DW_MACINFO_start_file	SDCCdwarf2.h	280;"	d
DW_MACINFO_undef	SDCCdwarf2.h	279;"	d
DW_MACINFO_vendor_ext	SDCCdwarf2.h	282;"	d
DW_OP_abs	SDCCdwarf2.h	186;"	d
DW_OP_addr	SDCCdwarf2.h	167;"	d
DW_OP_and	SDCCdwarf2.h	187;"	d
DW_OP_bra	SDCCdwarf2.h	202;"	d
DW_OP_breg0	SDCCdwarf2.h	211;"	d
DW_OP_breg1	SDCCdwarf2.h	212;"	d
DW_OP_breg10	SDCCdwarf2.h	221;"	d
DW_OP_breg11	SDCCdwarf2.h	222;"	d
DW_OP_breg12	SDCCdwarf2.h	223;"	d
DW_OP_breg13	SDCCdwarf2.h	224;"	d
DW_OP_breg14	SDCCdwarf2.h	225;"	d
DW_OP_breg15	SDCCdwarf2.h	226;"	d
DW_OP_breg16	SDCCdwarf2.h	227;"	d
DW_OP_breg17	SDCCdwarf2.h	228;"	d
DW_OP_breg18	SDCCdwarf2.h	229;"	d
DW_OP_breg19	SDCCdwarf2.h	230;"	d
DW_OP_breg2	SDCCdwarf2.h	213;"	d
DW_OP_breg20	SDCCdwarf2.h	231;"	d
DW_OP_breg21	SDCCdwarf2.h	232;"	d
DW_OP_breg22	SDCCdwarf2.h	233;"	d
DW_OP_breg23	SDCCdwarf2.h	234;"	d
DW_OP_breg24	SDCCdwarf2.h	235;"	d
DW_OP_breg25	SDCCdwarf2.h	236;"	d
DW_OP_breg26	SDCCdwarf2.h	237;"	d
DW_OP_breg27	SDCCdwarf2.h	238;"	d
DW_OP_breg28	SDCCdwarf2.h	239;"	d
DW_OP_breg29	SDCCdwarf2.h	240;"	d
DW_OP_breg3	SDCCdwarf2.h	214;"	d
DW_OP_breg30	SDCCdwarf2.h	241;"	d
DW_OP_breg31	SDCCdwarf2.h	242;"	d
DW_OP_breg4	SDCCdwarf2.h	215;"	d
DW_OP_breg5	SDCCdwarf2.h	216;"	d
DW_OP_breg6	SDCCdwarf2.h	217;"	d
DW_OP_breg7	SDCCdwarf2.h	218;"	d
DW_OP_breg8	SDCCdwarf2.h	219;"	d
DW_OP_breg9	SDCCdwarf2.h	220;"	d
DW_OP_bregx	SDCCdwarf2.h	245;"	d
DW_OP_const1s	SDCCdwarf2.h	170;"	d
DW_OP_const1u	SDCCdwarf2.h	169;"	d
DW_OP_const2s	SDCCdwarf2.h	172;"	d
DW_OP_const2u	SDCCdwarf2.h	171;"	d
DW_OP_const4s	SDCCdwarf2.h	174;"	d
DW_OP_const4u	SDCCdwarf2.h	173;"	d
DW_OP_const8s	SDCCdwarf2.h	176;"	d
DW_OP_const8u	SDCCdwarf2.h	175;"	d
DW_OP_consts	SDCCdwarf2.h	178;"	d
DW_OP_constu	SDCCdwarf2.h	177;"	d
DW_OP_deref	SDCCdwarf2.h	168;"	d
DW_OP_deref_size	SDCCdwarf2.h	247;"	d
DW_OP_div	SDCCdwarf2.h	188;"	d
DW_OP_drop	SDCCdwarf2.h	180;"	d
DW_OP_dup	SDCCdwarf2.h	179;"	d
DW_OP_eq	SDCCdwarf2.h	203;"	d
DW_OP_fbreg	SDCCdwarf2.h	244;"	d
DW_OP_ge	SDCCdwarf2.h	204;"	d
DW_OP_gt	SDCCdwarf2.h	205;"	d
DW_OP_le	SDCCdwarf2.h	206;"	d
DW_OP_lit0	SDCCdwarf2.h	209;"	d
DW_OP_lt	SDCCdwarf2.h	207;"	d
DW_OP_minus	SDCCdwarf2.h	189;"	d
DW_OP_mod	SDCCdwarf2.h	190;"	d
DW_OP_mul	SDCCdwarf2.h	191;"	d
DW_OP_ne	SDCCdwarf2.h	208;"	d
DW_OP_neg	SDCCdwarf2.h	192;"	d
DW_OP_nop	SDCCdwarf2.h	249;"	d
DW_OP_not	SDCCdwarf2.h	193;"	d
DW_OP_or	SDCCdwarf2.h	194;"	d
DW_OP_over	SDCCdwarf2.h	181;"	d
DW_OP_pick	SDCCdwarf2.h	182;"	d
DW_OP_piece	SDCCdwarf2.h	246;"	d
DW_OP_plus	SDCCdwarf2.h	195;"	d
DW_OP_plus_uconst	SDCCdwarf2.h	196;"	d
DW_OP_reg0	SDCCdwarf2.h	210;"	d
DW_OP_regx	SDCCdwarf2.h	243;"	d
DW_OP_rot	SDCCdwarf2.h	184;"	d
DW_OP_shl	SDCCdwarf2.h	197;"	d
DW_OP_shr	SDCCdwarf2.h	198;"	d
DW_OP_shra	SDCCdwarf2.h	199;"	d
DW_OP_skip	SDCCdwarf2.h	201;"	d
DW_OP_swap	SDCCdwarf2.h	183;"	d
DW_OP_xderef	SDCCdwarf2.h	185;"	d
DW_OP_xderef_size	SDCCdwarf2.h	248;"	d
DW_OP_xor	SDCCdwarf2.h	200;"	d
DW_TAG_access_declaration	SDCCdwarf2.h	56;"	d
DW_TAG_array_type	SDCCdwarf2.h	28;"	d
DW_TAG_base_type	SDCCdwarf2.h	57;"	d
DW_TAG_catch_block	SDCCdwarf2.h	58;"	d
DW_TAG_class_type	SDCCdwarf2.h	29;"	d
DW_TAG_common_block	SDCCdwarf2.h	47;"	d
DW_TAG_common_inclusion	SDCCdwarf2.h	48;"	d
DW_TAG_compile_unit	SDCCdwarf2.h	39;"	d
DW_TAG_const_type	SDCCdwarf2.h	59;"	d
DW_TAG_constant	SDCCdwarf2.h	60;"	d
DW_TAG_entry_point	SDCCdwarf2.h	30;"	d
DW_TAG_enumeration_type	SDCCdwarf2.h	31;"	d
DW_TAG_enumerator	SDCCdwarf2.h	61;"	d
DW_TAG_file_type	SDCCdwarf2.h	62;"	d
DW_TAG_formal_parameter	SDCCdwarf2.h	32;"	d
DW_TAG_friend	SDCCdwarf2.h	63;"	d
DW_TAG_imported_declaration	SDCCdwarf2.h	33;"	d
DW_TAG_inheritance	SDCCdwarf2.h	49;"	d
DW_TAG_inlined_subroutine	SDCCdwarf2.h	50;"	d
DW_TAG_label	SDCCdwarf2.h	34;"	d
DW_TAG_lexical_block	SDCCdwarf2.h	35;"	d
DW_TAG_member	SDCCdwarf2.h	36;"	d
DW_TAG_module	SDCCdwarf2.h	51;"	d
DW_TAG_namelist	SDCCdwarf2.h	64;"	d
DW_TAG_namelist_item	SDCCdwarf2.h	65;"	d
DW_TAG_packed_type	SDCCdwarf2.h	66;"	d
DW_TAG_pointer_type	SDCCdwarf2.h	37;"	d
DW_TAG_ptr_to_member_type	SDCCdwarf2.h	52;"	d
DW_TAG_reference_type	SDCCdwarf2.h	38;"	d
DW_TAG_set_type	SDCCdwarf2.h	53;"	d
DW_TAG_string_type	SDCCdwarf2.h	40;"	d
DW_TAG_structure_type	SDCCdwarf2.h	41;"	d
DW_TAG_subprogram	SDCCdwarf2.h	67;"	d
DW_TAG_subrange_type	SDCCdwarf2.h	54;"	d
DW_TAG_subroutine_type	SDCCdwarf2.h	42;"	d
DW_TAG_template_type_param	SDCCdwarf2.h	68;"	d
DW_TAG_template_value_param	SDCCdwarf2.h	69;"	d
DW_TAG_thrown_type	SDCCdwarf2.h	70;"	d
DW_TAG_try_block	SDCCdwarf2.h	71;"	d
DW_TAG_typedef	SDCCdwarf2.h	43;"	d
DW_TAG_union_type	SDCCdwarf2.h	44;"	d
DW_TAG_unspecified_parameters	SDCCdwarf2.h	45;"	d
DW_TAG_variable	SDCCdwarf2.h	73;"	d
DW_TAG_variant	SDCCdwarf2.h	46;"	d
DW_TAG_variant_part	SDCCdwarf2.h	72;"	d
DW_TAG_volatile_type	SDCCdwarf2.h	74;"	d
DW_TAG_with_stmt	SDCCdwarf2.h	55;"	d
DebugFile	SDCCdebug.h	/^typedef struct DebugFile$/;"	s
ECHO	SDCClex.c	15474;"	d	file:
EEPPOINTER	SDCCsymt.h	/^  EEPPOINTER,                       \/* pointer to eeprom     *\/$/;"	e
EEPROM	SDCCy.c	/^     EEPROM = 292,$/;"	e	enum:yytokentype	file:
EEPROM	SDCCy.c	217;"	d	file:
EEPROM	SDCCy.h	/^     EEPROM = 292,$/;"	e	enum:yytokentype
EEPROM	SDCCy.h	193;"	d
ELSE	SDCCy.c	/^     ELSE = 334,$/;"	e	enum:yytokentype	file:
ELSE	SDCCy.c	259;"	d	file:
ELSE	SDCCy.h	/^     ELSE = 334,$/;"	e	enum:yytokentype
ELSE	SDCCy.h	235;"	d
EMPTY	SDCCglobl.h	171;"	d
EMPTY	SDCCglobl.h	173;"	d
ENDCRITICAL	SDCCy.c	/^     ENDCRITICAL = 376,$/;"	e	enum:yytokentype	file:
ENDCRITICAL	SDCCy.c	301;"	d	file:
ENDCRITICAL	SDCCy.h	/^     ENDCRITICAL = 376,$/;"	e	enum:yytokentype
ENDCRITICAL	SDCCy.h	277;"	d
ENDFUNCTION	SDCCy.c	/^     ENDFUNCTION = 362,$/;"	e	enum:yytokentype	file:
ENDFUNCTION	SDCCy.c	287;"	d	file:
ENDFUNCTION	SDCCy.h	/^     ENDFUNCTION = 362,$/;"	e	enum:yytokentype
ENDFUNCTION	SDCCy.h	263;"	d
ENTRY	altlex.c	778;"	d	file:
ENUM	SDCCy.c	/^     ENUM = 328,$/;"	e	enum:yytokentype	file:
ENUM	SDCCy.c	253;"	d	file:
ENUM	SDCCy.h	/^     ENUM = 328,$/;"	e	enum:yytokentype
ENUM	SDCCy.h	229;"	d
EOB_ACT_CONTINUE_SCAN	SDCClex.c	104;"	d	file:
EOB_ACT_END_OF_FILE	SDCClex.c	105;"	d	file:
EOB_ACT_LAST_MATCH	SDCClex.c	106;"	d	file:
EQ_OP	SDCCy.c	/^     EQ_OP = 272,$/;"	e	enum:yytokentype	file:
EQ_OP	SDCCy.c	197;"	d	file:
EQ_OP	SDCCy.h	/^     EQ_OP = 272,$/;"	e	enum:yytokentype
EQ_OP	SDCCy.h	173;"	d
ERROR_LEVEL_ALL	SDCCerr.h	/^  ERROR_LEVEL_ALL,$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LEVEL_ERROR	SDCCerr.h	/^  ERROR_LEVEL_ERROR,$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LEVEL_INFO	SDCCerr.h	/^  ERROR_LEVEL_INFO,$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LEVEL_PEDANTIC	SDCCerr.h	/^  ERROR_LEVEL_PEDANTIC,$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LEVEL_SYNTAX_ERROR	SDCCerr.h	/^  ERROR_LEVEL_SYNTAX_ERROR$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LEVEL_WARNING	SDCCerr.h	/^  ERROR_LEVEL_WARNING,$/;"	e	enum:_ERROR_LOG_LEVEL
ERROR_LOG_LEVEL	SDCCerr.h	/^typedef enum _ERROR_LOG_LEVEL ERROR_LOG_LEVEL;$/;"	t
ERRSINK	altlex.c	64;"	d	file:
EXE_EXT	SDCCsystem.c	137;"	d	file:
EXPECT_CHR	SDCCpeeph.c	1348;"	d	file:
EXPECT_STR	SDCCpeeph.c	1346;"	d	file:
EXPRESSION	SDCCicode.h	/^  EXPRESSION,$/;"	e
EXTERN	SDCCy.c	/^     EXTERN = 287,$/;"	e	enum:yytokentype	file:
EXTERN	SDCCy.c	212;"	d	file:
EXTERN	SDCCy.h	/^     EXTERN = 287,$/;"	e	enum:yytokentype
EXTERN	SDCCy.h	188;"	d
EXTERN_STACK_DCL	SDCCglobl.h	187;"	d
EX_LINK	SDCCast.h	/^  EX_LINK,$/;"	e
EX_OP	SDCCast.h	/^  EX_OP = 0,$/;"	e
EX_OPERAND	SDCCast.h	/^  EX_OPERAND$/;"	e
EX_VALUE	SDCCast.h	/^  EX_VALUE,$/;"	e
E_AGGR_ASSIGN	SDCCerr.h	/^  E_AGGR_ASSIGN                 =  48, \/* aggr assign         *\/$/;"	e
E_ANDOR_OP	SDCCerr.h	/^  E_ANDOR_OP                    =  46, \/* && || op invalid    *\/$/;"	e
E_ARGUMENT_MISSING	SDCCerr.h	/^  E_ARGUMENT_MISSING            = 148, \/* Option requires an argument. *\/$/;"	e
E_ARG_COUNT	SDCCerr.h	/^  E_ARG_COUNT                   =  39, \/* func expecting more *\/$/;"	e
E_ARG_ERROR	SDCCerr.h	/^  E_ARG_ERROR                   =  38, \/* argument count error*\/$/;"	e
E_ARG_TYPE	SDCCerr.h	/^  E_ARG_TYPE                    =  52, \/* arg type mismatch   *\/$/;"	e
E_ARRAY_DIRECT	SDCCerr.h	/^  E_ARRAY_DIRECT                =  49, \/* array indexing in   *\/$/;"	e
E_AUTO_ABSA	SDCCerr.h	/^  E_AUTO_ABSA                   =  17, \/* abs addr for auto var*\/$/;"	e
E_AUTO_ADDRSPACE	SDCCerr.h	/^  E_AUTO_ADDRSPACE              = 208, \/* named address space for auto var *\/$/;"	e
E_AUTO_AGGR_INIT	SDCCerr.h	/^  E_AUTO_AGGR_INIT              =  67, \/* auto aggregates no init *\/$/;"	e
E_AUTO_ASSUMED	SDCCerr.h	/^  E_AUTO_ASSUMED                =  16, \/* sclass auto assumed  *\/$/;"	e
E_BAD_DESIGNATOR	SDCCerr.h	/^  E_BAD_DESIGNATOR              = 202, \/* Bad designated initializer *\/$/;"	e
E_BAD_INLINE	SDCCerr.h	/^  E_BAD_INLINE                  = 193, \/* Only functions may be qualified with 'inline' *\/$/;"	e
E_BAD_INT_ARGUMENT	SDCCerr.h	/^  E_BAD_INT_ARGUMENT            = 194, \/* Bad integer option argument *\/$/;"	e
E_BAD_RESTRICT	SDCCerr.h	/^  E_BAD_RESTRICT                = 192, \/* Only pointers may be qualified with 'restrict' *\/$/;"	e
E_BAD_TAG	SDCCerr.h	/^  E_BAD_TAG                     = 173, \/* '%s' is not a %s tag *\/$/;"	e
E_BANKED_WITH_CALLEESAVES	SDCCerr.h	/^  E_BANKED_WITH_CALLEESAVES     = 183, \/* banked and callee-saves mixed *\/$/;"	e
E_BITFLD_SIZE	SDCCerr.h	/^  E_BITFLD_SIZE                 =  31, \/* bit field size > 16  *\/$/;"	e
E_BITVAR_STORAGE	SDCCerr.h	/^  E_BITVAR_STORAGE              =  90, \/* storage given for 'bit' variable *\/$/;"	e
E_BITWISE_OP	SDCCerr.h	/^  E_BITWISE_OP                  =  45, \/* bit op invalid op   *\/$/;"	e
E_BIT_ARRAY	SDCCerr.h	/^  E_BIT_ARRAY                   =  50, \/* bit array not allowed  *\/$/;"	e
E_BREAK_CONTEXT	SDCCerr.h	/^  E_BREAK_CONTEXT               =  63, \/* break statement invalid *\/$/;"	e
E_CANNOT_ALLOC	SDCCerr.h	/^  E_CANNOT_ALLOC                =   6, \/* cannot allocate space*\/$/;"	e
E_CASE_CONSTANT	SDCCerr.h	/^  E_CASE_CONSTANT               =  62, \/* case expression ! const *\/$/;"	e
E_CASE_CONTEXT	SDCCerr.h	/^  E_CASE_CONTEXT                =  61, \/* case stmnt without switch *\/$/;"	e
E_CASE_NON_INTEGER	SDCCerr.h	/^  E_CASE_NON_INTEGER            = 108, \/* case value not integer *\/$/;"	e
E_CAST_ILLEGAL	SDCCerr.h	/^  E_CAST_ILLEGAL                =  36, \/* cast illegal        *\/$/;"	e
E_CAST_ZERO	SDCCerr.h	/^  E_CAST_ZERO                   = 124, \/* casting to from size zero *\/$/;"	e
E_CODE_NO_INIT	SDCCerr.h	/^  E_CODE_NO_INIT                =  99, \/* vars in code space must have initializer *\/$/;"	e
E_CODE_WRITE	SDCCerr.h	/^  E_CODE_WRITE                  =  33, \/* trying 2 write to code *\/$/;"	e
E_COMPARE_OP	SDCCerr.h	/^  E_COMPARE_OP                  =  44, \/* compare operand     *\/$/;"	e
E_CONST_EXPECTED	SDCCerr.h	/^  E_CONST_EXPECTED              =   2, \/* constant expected    *\/$/;"	e
E_CONV_ERR	SDCCerr.h	/^  E_CONV_ERR                    =  29, \/* conversion error     *\/$/;"	e
E_DIVIDE_BY_ZERO	SDCCerr.h	/^  E_DIVIDE_BY_ZERO              = 122, \/* \/ 0 *\/$/;"	e
E_DUPLICATE	SDCCerr.h	/^  E_DUPLICATE                   =   0, \/* Duplicate variable   *\/$/;"	e
E_DUPLICATE_LABEL	SDCCerr.h	/^  E_DUPLICATE_LABEL             =  56, \/* duplicate label name *\/$/;"	e
E_DUPLICATE_MEMBER	SDCCerr.h	/^  E_DUPLICATE_MEMBER            = 163, \/* duplicate %s member '%s' *\/$/;"	e
E_DUPLICATE_TYPEDEF	SDCCerr.h	/^  E_DUPLICATE_TYPEDEF           =  51, \/* typedef name duplicate *\/$/;"	e
E_DUP_FAILED	SDCCerr.h	/^  E_DUP_FAILED                  =  77, \/* file DUP failed     *\/$/;"	e
E_ENUM_NON_INTEGER	SDCCerr.h	/^  E_ENUM_NON_INTEGER            = 174, \/* enumeration constant not an integer *\/$/;"	e
E_EXTERN_MISMATCH	SDCCerr.h	/^  E_EXTERN_MISMATCH             =  91, \/* extern declaration mismatches *\/$/;"	e
E_FILE_OPEN_ERR	SDCCerr.h	/^  E_FILE_OPEN_ERR               =   4, \/* File open failed     *\/$/;"	e
E_FLEXARRAY_INEMPTYSTRCT	SDCCerr.h	/^  E_FLEXARRAY_INEMPTYSTRCT      = 189, \/* flexible array in otherwise empty struct *\/$/;"	e
E_FLEXARRAY_NOTATEND	SDCCerr.h	/^  E_FLEXARRAY_NOTATEND          = 188, \/* flexible array member not at end of struct *\/$/;"	e
E_FUNCTION_EXPECTED	SDCCerr.h	/^  E_FUNCTION_EXPECTED           =  12, \/* function expected    *\/$/;"	e
E_FUNC_AGGR	SDCCerr.h	/^  E_FUNC_AGGR                   =  54, \/* function returing aggr *\/$/;"	e
E_FUNC_ATTR	SDCCerr.h	/^  E_FUNC_ATTR                   = 169, \/* function attribute without function *\/$/;"	e
E_FUNC_BIT	SDCCerr.h	/^  E_FUNC_BIT                    = 123, \/* function cannot return bit *\/$/;"	e
E_FUNC_BODY	SDCCerr.h	/^  E_FUNC_BODY                   =  65, \/* func has body already *\/$/;"	e
E_FUNC_DEF	SDCCerr.h	/^  E_FUNC_DEF                    =  55, \/* ANSI Style def neede *\/$/;"	e
E_FUNC_EXPECTED	SDCCerr.h	/^  E_FUNC_EXPECTED               =  40, \/* func name expected  *\/$/;"	e
E_FUNC_NO_CODE	SDCCerr.h	/^  E_FUNC_NO_CODE                = 103, \/* fatalError          *\/$/;"	e
E_FUNC_REDEF	SDCCerr.h	/^  E_FUNC_REDEF                  =  19, \/* func name redefined  *\/$/;"	e
E_FUNC_VOID	SDCCerr.h	/^  E_FUNC_VOID                   =  58, \/* void func ret value  *\/$/;"	e
E_IDX_NOT_INT	SDCCerr.h	/^  E_IDX_NOT_INT                 =  23, \/* index not an integer *\/$/;"	e
E_ID_UNDEF	SDCCerr.h	/^  E_ID_UNDEF                    =  20, \/* identifer undefined  *\/$/;"	e
E_ILLEGAL_ADDR	SDCCerr.h	/^  E_ILLEGAL_ADDR                =  35, \/* address of bit      *\/$/;"	e
E_INCLUDE_MISSING	SDCCerr.h	/^  E_INCLUDE_MISSING             =  73, \/* compiler include missing *\/$/;"	e
E_INCOMPAT_PTYPES	SDCCerr.h	/^  E_INCOMPAT_PTYPES             = 129, \/* incampatible pointer assignment *\/$/;"	e
E_INCOMPAT_TYPES	SDCCerr.h	/^  E_INCOMPAT_TYPES              =  78, \/* incompatible types casting *\/$/;"	e
E_INCOMPLETE_FIELD	SDCCerr.h	/^  E_INCOMPLETE_FIELD            = 200, \/* struct field has incomplete type *\/$/;"	e
E_INIT_COUNT	SDCCerr.h	/^  E_INIT_COUNT                  =  68, \/* too many initializers *\/$/;"	e
E_INIT_NON_ADDR	SDCCerr.h	/^  E_INIT_NON_ADDR               =  70, \/* non address xpr for init *\/$/;"	e
E_INIT_STRUCT	SDCCerr.h	/^  E_INIT_STRUCT                 =  69, \/* struct init wrong   *\/$/;"	e
E_INTEGERSUFFIX	SDCCerr.h	/^  E_INTEGERSUFFIX               = 207, \/* Invalid integer suffix *\/$/;"	e
E_INTERNAL_ERROR	SDCCerr.h	/^  E_INTERNAL_ERROR              =   9, \/* unable to alloc tvar *\/$/;"	e
E_INT_ARGS	SDCCerr.h	/^  E_INT_ARGS                    =  72, \/* interrupt rtn cannot have args *\/$/;"	e
E_INT_BAD_INTNO	SDCCerr.h	/^  E_INT_BAD_INTNO               = 167, \/* invalid interrupt number *\/$/;"	e
E_INT_DEFINED	SDCCerr.h	/^  E_INT_DEFINED                 =  71, \/* interrupt already over *\/$/;"	e
E_INT_REQD	SDCCerr.h	/^  E_INT_REQD                    =  30, \/* bit field must be int*\/$/;"	e
E_INVALID_CRITICAL	SDCCerr.h	/^  E_INVALID_CRITICAL            = 171, \/* operation invalid in critical sequence *\/$/;"	e
E_INVALID_FLOAT_CONST	SDCCerr.h	/^  E_INVALID_FLOAT_CONST         = 105, \/* invalid floating point literal string *\/$/;"	e
E_INVALID_HEX	SDCCerr.h	/^  E_INVALID_HEX                 = 138, \/* \\x used with no following hex digits *\/$/;"	e
E_INVALID_OCLASS	SDCCerr.h	/^  E_INVALID_OCLASS              =   5, \/* output class invalid *\/$/;"	e
E_INVALID_OP	SDCCerr.h	/^  E_INVALID_OP                  = 106, \/* invalid operand for some operation *\/$/;"	e
E_INVALID_UNIVERSAL	SDCCerr.h	/^  E_INVALID_UNIVERSAL           = 204, \/* incomplete universal character name %s. *\/$/;"	e
E_LABEL_UNDEF	SDCCerr.h	/^  E_LABEL_UNDEF                 =  57, \/* undefined label used *\/$/;"	e
E_LONG_AND_SHORT_INVALID	SDCCerr.h	/^  E_LONG_AND_SHORT_INVALID      = 144, \/* long and short invalid for .. *\/$/;"	e
E_LONG_OR_SHORT_INVALID	SDCCerr.h	/^  E_LONG_OR_SHORT_INVALID       = 142, \/* long or short invalid for .. *\/$/;"	e
E_LVALUE_CONST	SDCCerr.h	/^  E_LVALUE_CONST                =  34, \/* lvalue is a const   *\/$/;"	e
E_LVALUE_REQUIRED	SDCCerr.h	/^  E_LVALUE_REQUIRED             =  10, \/* lvalue required      *\/$/;"	e
E_MULT_INTEGRAL	SDCCerr.h	/^  E_MULT_INTEGRAL               =  37, \/* mult opernd must b integral *\/$/;"	e
E_NEED_ARRAY_PTR	SDCCerr.h	/^  E_NEED_ARRAY_PTR              =  22, \/* array or pointer reqd*\/$/;"	e
E_NEED_OPT_O_IN_C1	SDCCerr.h	/^  E_NEED_OPT_O_IN_C1            = 161, \/* must specify assembler file name with -o in c1 mode *\/$/;"	e
E_NEGATIVE_ARRAY_SIZE	SDCCerr.h	/^  E_NEGATIVE_ARRAY_SIZE         = 195, \/* Size of array '%s' is negative *\/$/;"	e
E_NONRENT_ARGS	SDCCerr.h	/^  E_NONRENT_ARGS                =  92, \/* fptr non reentrant has args *\/$/;"	e
E_NOT_ALLOWED	SDCCerr.h	/^  E_NOT_ALLOWED                 = 172, \/* %s not allowed here *\/$/;"	e
E_NOT_MEMBER	SDCCerr.h	/^  E_NOT_MEMBER                  =  26, \/* !struct\/union member *\/$/;"	e
E_NO_MAIN	SDCCerr.h	/^  E_NO_MAIN                     =  74, \/* main function undefined *\/$/;"	e
E_NO_SUCH_BANK	SDCCerr.h	/^  E_NO_SUCH_BANK                = 140, \/* 'using' attribute specifies non-existant register bank. *\/$/;"	e
E_OFFSETOF_TYPE	SDCCerr.h	/^  E_OFFSETOF_TYPE               = 199, \/* offsetof can only be applied to structs\/unions *\/$/;"	e
E_OLD_STYLE	SDCCerr.h	/^  E_OLD_STYLE                   =   7, \/* old style C ! allowed*\/$/;"	e
E_OPS_INTEGRAL	SDCCerr.h	/^  E_OPS_INTEGRAL                = 100, \/* operans must be integral for certain assignments *\/$/;"	e
E_OP_UNKNOWN_SIZE	SDCCerr.h	/^  E_OP_UNKNOWN_SIZE             =  86, \/* unknown size for operand *\/$/;"	e
E_OUT_OF_MEM	SDCCerr.h	/^  E_OUT_OF_MEM                  =   3, \/* malloc failed        *\/$/;"	e
E_PARAM_NAME_OMITTED	SDCCerr.h	/^  E_PARAM_NAME_OMITTED          = 159, \/* { in function %s: name omitted for parameter %d *\/$/;"	e
E_PLUS_INVALID	SDCCerr.h	/^  E_PLUS_INVALID                =  41, \/* plus invalid        *\/$/;"	e
E_PREVIOUS_DEF	SDCCerr.h	/^  E_PREVIOUS_DEF                = 177, \/* previously defined here *\/$/;"	e
E_PREV_DEF_CONFLICT	SDCCerr.h	/^  E_PREV_DEF_CONFLICT           =  98, \/* previous definition conflicts with current *\/$/;"	e
E_PRE_PROC_FAILED	SDCCerr.h	/^  E_PRE_PROC_FAILED             =  76, \/* preprocessor failed *\/$/;"	e
E_PTR_PLUS_PTR	SDCCerr.h	/^  E_PTR_PLUS_PTR                =  42, \/* pointer + pointer   *\/$/;"	e
E_PTR_REQD	SDCCerr.h	/^  E_PTR_REQD                    =  27, \/* pointer required     *\/$/;"	e
E_RET_VALUE	SDCCerr.h	/^  E_RET_VALUE                   =  53, \/* return value mismatch *\/$/;"	e
E_SFR_ADDR_RANGE	SDCCerr.h	/^  E_SFR_ADDR_RANGE              =  89, \/* sfr address out of range *\/$/;"	e
E_SFR_INIT	SDCCerr.h	/^  E_SFR_INIT                    =  14, \/* init error for sbit  *\/$/;"	e
E_SHADOWREGS_NO_ISR	SDCCerr.h	/^  E_SHADOWREGS_NO_ISR           = 181, \/* shadowregs keyword following non-ISR function *\/$/;"	e
E_SHIFT_OP_INVALID	SDCCerr.h	/^  E_SHIFT_OP_INVALID            =  43, \/* shft op op invalid  *\/$/;"	e
E_SHORTLONG	SDCCerr.h	/^  E_SHORTLONG                   = 206, \/* Invalid combination of short \/ long *\/$/;"	e
E_SIGNED_AND_UNSIGNED_INVALID	SDCCerr.h	/^  E_SIGNED_AND_UNSIGNED_INVALID = 145, \/* signed and unsigned invalid for .. *\/$/;"	e
E_SIGNED_OR_UNSIGNED_INVALID	SDCCerr.h	/^  E_SIGNED_OR_UNSIGNED_INVALID  = 143, \/* signed or unsigned invalid for .. *\/$/;"	e
E_SIZEOF_INCOMPLETE_TYPE	SDCCerr.h	/^  E_SIZEOF_INCOMPLETE_TYPE      = 176, \/* sizeof applied to an incomplete type *\/$/;"	e
E_STACK_OUT	SDCCerr.h	/^  E_STACK_OUT                   =   8, \/* v r out of stack     *\/$/;"	e
E_STACK_VIOLATION	SDCCerr.h	/^  E_STACK_VIOLATION             = 164, \/* internal stack violation *\/$/;"	e
E_STORAGE_CLASS_FOR_PARAMETER	SDCCerr.h	/^  E_STORAGE_CLASS_FOR_PARAMETER = 198, \/* storage class specified for parameter '%s' *\/$/;"	e
E_STRUCT_AS_ARG	SDCCerr.h	/^  E_STRUCT_AS_ARG               =  97, \/* structure passed as argument *\/$/;"	e
E_STRUCT_REDEF	SDCCerr.h	/^  E_STRUCT_REDEF                = 210, \/* struct or union tag redefined *\/$/;"	e
E_STRUCT_UNION	SDCCerr.h	/^  E_STRUCT_UNION                =  25, \/* struct,union expected*\/$/;"	e
E_SWITCH_AGGR	SDCCerr.h	/^  E_SWITCH_AGGR                 =  64, \/* non integral for switch *\/$/;"	e
E_SWITCH_NON_INTEGER	SDCCerr.h	/^  E_SWITCH_NON_INTEGER          = 107, \/* switch value not integer *\/$/;"	e
E_SYNTAX_ERROR	SDCCerr.h	/^  E_SYNTAX_ERROR                =   1, \/* Syntax Error         *\/$/;"	e
E_TERMINATING	SDCCerr.h	/^  E_TERMINATING                 =  83, \/* compiler terminating *\/$/;"	e
E_TMPFILE_FAILED	SDCCerr.h	/^  E_TMPFILE_FAILED              =  11, \/* tmpfile creation failed *\/$/;"	e
E_TOO_FEW_PARMS	SDCCerr.h	/^  E_TOO_FEW_PARMS               = 102, \/* to few parameters   *\/$/;"	e
E_TOO_MANY_PARMS	SDCCerr.h	/^  E_TOO_MANY_PARMS              = 101, \/* too many parameters *\/$/;"	e
E_TWO_OR_MORE_DATA_TYPES	SDCCerr.h	/^  E_TWO_OR_MORE_DATA_TYPES      = 141, \/* two or more data types in declaration for '%s' *\/$/;"	e
E_TWO_OR_MORE_STORAGE_CLASSES	SDCCerr.h	/^  E_TWO_OR_MORE_STORAGE_CLASSES = 146, \/* two or more storage classes in declaration for '%s' *\/$/;"	e
E_TYPE_MISMATCH	SDCCerr.h	/^  E_TYPE_MISMATCH               =  47, \/* type mismatch       *\/$/;"	e
E_TYPE_MISMATCH_PARM	SDCCerr.h	/^  E_TYPE_MISMATCH_PARM          = 104, \/* type mismatch for parameter *\/$/;"	e
E_UNARY_OP	SDCCerr.h	/^  E_UNARY_OP                    =  28, \/* unary operator bad op*\/$/;"	e
E_UNKNOWN_SIZE	SDCCerr.h	/^  E_UNKNOWN_SIZE                =  66, \/* variable has unknown size *\/$/;"	e
E_UNKNOWN_TARGET	SDCCerr.h	/^  E_UNKNOWN_TARGET              = 131, \/* target not defined  *\/$/;"	e
E_UNUSED_75	SDCCerr.h	/^  E_UNUSED_75                   =  75, \/* - removed error code - *\/$/;"	e
E_USING_ERROR	SDCCerr.h	/^  E_USING_ERROR                 =  13, \/* using in error       *\/$/;"	e
E_VOID_VALUE_USED	SDCCerr.h	/^  E_VOID_VALUE_USED             = 153, \/* void value not ignored as it ought to be *\/$/;"	e
ErrTab	SDCCerr.c	/^} ErrTab [] =$/;"	v
FALSE	SDCCglobl.h	36;"	d
FALSE	SDCCglobl.h	44;"	d
FALSE	SDCCglobl.h	52;"	d
FALSE	SDCCsystem.c	30;"	d	file:
FALSE	SDCCutil.c	32;"	d	file:
FBYNAME	SDCCpeeph.c	/^FBYNAME (canAssign)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (deadMove)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (flat24bitMode)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelInRange)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelIsReturnOnly)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelIsUncondJump)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelJTInRange)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelRefCount)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (labelRefCountChange)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (notSame)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (notUsed)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (notUsedFrom)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (notVolatile)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (okToRemoveSLOC)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (operandsLiteral)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (operandsNotRelated)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (optimizeReturn)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (portIsDS390)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (useAcallAjmp)$/;"	f
FBYNAME	SDCCpeeph.c	/^FBYNAME (xramMovcOption)$/;"	f
FBYNAME	SDCCpeeph.c	48;"	d	file:
FILENAME_CMP	SDCCglobl.h	85;"	d
FILENAME_CMP	SDCCglobl.h	91;"	d
FIXED16X16	SDCCy.c	/^     FIXED16X16 = 321,$/;"	e	enum:yytokentype	file:
FIXED16X16	SDCCy.c	246;"	d	file:
FIXED16X16	SDCCy.h	/^     FIXED16X16 = 321,$/;"	e	enum:yytokentype
FIXED16X16	SDCCy.h	222;"	d
FLEXARRAY	SDCCsymt.c	1054;"	d	file:
FLEX_SCANNER	SDCClex.c	7;"	d	file:
FLOATSIZE	SDCCglobl.h	152;"	d
FOR	SDCCy.c	/^     FOR = 338,$/;"	e	enum:yytokentype	file:
FOR	SDCCy.c	263;"	d	file:
FOR	SDCCy.h	/^     FOR = 338,$/;"	e	enum:yytokentype
FOR	SDCCy.h	239;"	d
FPOINTER	SDCCsymt.h	/^  FPOINTER,                         \/* pointer to far data  *\/$/;"	e
FPTRSIZE	SDCCglobl.h	149;"	d
FUNCTION	SDCCsymt.h	/^  FUNCTION$/;"	e
FUNC_ARGS	SDCCsymt.h	406;"	d
FUNC_BANKED	SDCCsymt.h	434;"	d
FUNC_CALLEESAVES	SDCCsymt.h	412;"	d
FUNC_DEBUG	SDCCsymt.h	403;"	d
FUNC_HASBODY	SDCCsymt.h	410;"	d
FUNC_HASFCALL	SDCCsymt.h	408;"	d
FUNC_HASSTACKPARM	SDCCsymt.h	418;"	d
FUNC_HASVARARGS	SDCCsymt.h	404;"	d
FUNC_INTNO	SDCCsymt.h	416;"	d
FUNC_ISBUILTIN	SDCCsymt.h	438;"	d
FUNC_ISCRITICAL	SDCCsymt.h	436;"	d
FUNC_ISINLINE	SDCCsymt.h	419;"	d
FUNC_ISISR	SDCCsymt.h	414;"	d
FUNC_ISJAVANATIVE	SDCCsymt.h	440;"	d
FUNC_ISNAKED	SDCCsymt.h	430;"	d
FUNC_ISNORETURN	SDCCsymt.h	421;"	d
FUNC_ISOVERLAY	SDCCsymt.h	442;"	d
FUNC_ISREENT	SDCCsymt.h	424;"	d
FUNC_ISSHADOWREGS	SDCCsymt.h	426;"	d
FUNC_ISSMALLC	SDCCsymt.h	444;"	d
FUNC_ISWPARAM	SDCCsymt.h	428;"	d
FUNC_NONBANKED	SDCCsymt.h	432;"	d
FUNC_REGBANK	SDCCsymt.h	417;"	d
FileBaseName	SDCCasm.c	/^FileBaseName (const char *fileFullName)$/;"	f
GETABIT	SDCCy.c	/^     GETABIT = 354,$/;"	e	enum:yytokentype	file:
GETABIT	SDCCy.c	279;"	d	file:
GETABIT	SDCCy.h	/^     GETABIT = 354,$/;"	e	enum:yytokentype
GETABIT	SDCCy.h	255;"	d
GETBYTE	SDCCy.c	/^     GETBYTE = 355,$/;"	e	enum:yytokentype	file:
GETBYTE	SDCCy.c	280;"	d	file:
GETBYTE	SDCCy.h	/^     GETBYTE = 355,$/;"	e	enum:yytokentype
GETBYTE	SDCCy.h	256;"	d
GETC	altlex.c	110;"	d	file:
GETHBIT	SDCCy.c	/^     GETHBIT = 353,$/;"	e	enum:yytokentype	file:
GETHBIT	SDCCy.c	278;"	d	file:
GETHBIT	SDCCy.h	/^     GETHBIT = 353,$/;"	e	enum:yytokentype
GETHBIT	SDCCy.h	254;"	d
GETWORD	SDCCy.c	/^     GETWORD = 356,$/;"	e	enum:yytokentype	file:
GETWORD	SDCCy.c	281;"	d	file:
GETWORD	SDCCy.h	/^     GETWORD = 356,$/;"	e	enum:yytokentype
GETWORD	SDCCy.h	257;"	d
GET_VALUE_AT_ADDRESS	SDCCy.c	/^     GET_VALUE_AT_ADDRESS = 350,$/;"	e	enum:yytokentype	file:
GET_VALUE_AT_ADDRESS	SDCCy.c	275;"	d	file:
GET_VALUE_AT_ADDRESS	SDCCy.h	/^     GET_VALUE_AT_ADDRESS = 350,$/;"	e	enum:yytokentype
GET_VALUE_AT_ADDRESS	SDCCy.h	251;"	d
GE_OP	SDCCy.c	/^     GE_OP = 271,$/;"	e	enum:yytokentype	file:
GE_OP	SDCCy.c	196;"	d	file:
GE_OP	SDCCy.h	/^     GE_OP = 271,$/;"	e	enum:yytokentype
GE_OP	SDCCy.h	172;"	d
GOTO	SDCCy.c	/^     GOTO = 339,$/;"	e	enum:yytokentype	file:
GOTO	SDCCy.c	264;"	d	file:
GOTO	SDCCy.h	/^     GOTO = 339,$/;"	e	enum:yytokentype
GOTO	SDCCy.h	240;"	d
GPOINTER	SDCCsymt.h	/^  GPOINTER,                         \/* _generic pointer     *\/$/;"	e
GPTRSIZE	SDCCglobl.h	150;"	d
GPTYPE_CODE	SDCCsymt.h	71;"	d
GPTYPE_CODE	SDCCsymt.h	76;"	d
GPTYPE_FAR	SDCCsymt.h	68;"	d
GPTYPE_FAR	SDCCsymt.h	73;"	d
GPTYPE_NEAR	SDCCsymt.h	69;"	d
GPTYPE_NEAR	SDCCsymt.h	74;"	d
GPTYPE_XSTACK	SDCCsymt.h	70;"	d
GPTYPE_XSTACK	SDCCsymt.h	75;"	d
GcurMemmap	SDCCast.c	/^memmap *GcurMemmap = NULL;      \/* points to the memmap that's currently active *\/$/;"	v
HASHTAB_SIZE	SDCCsymt.h	79;"	d
HAVE_DOS_BASED_FILE_SYSTEM	SDCCglobl.h	76;"	d
HOME_NAME	SDCCmem.h	57;"	d
HTAB_SIZE	SDCCpeeph.c	32;"	d	file:
IABS_NAME	SDCCmem.h	62;"	d
IC_ARRAYILIST	SDCCicode.h	130;"	d
IC_COND	SDCCicode.h	123;"	d
IC_FALSE	SDCCicode.h	125;"	d
IC_INLINE	SDCCicode.h	129;"	d
IC_JTCOND	SDCCicode.h	127;"	d
IC_JTLABELS	SDCCicode.h	128;"	d
IC_LABEL	SDCCicode.h	126;"	d
IC_LEFT	SDCCicode.h	121;"	d
IC_RESULT	SDCCicode.h	120;"	d
IC_RIGHT	SDCCicode.h	122;"	d
IC_TRUE	SDCCicode.h	124;"	d
IDATA	SDCCy.c	/^     IDATA = 304,$/;"	e	enum:yytokentype	file:
IDATA	SDCCy.c	229;"	d	file:
IDATA	SDCCy.h	/^     IDATA = 304,$/;"	e	enum:yytokentype
IDATA	SDCCy.h	205;"	d
IDATA_NAME	SDCCmem.h	49;"	d
IDENTIFIER	SDCCy.c	/^     IDENTIFIER = 258,$/;"	e	enum:yytokentype	file:
IDENTIFIER	SDCCy.c	183;"	d	file:
IDENTIFIER	SDCCy.h	/^     IDENTIFIER = 258,$/;"	e	enum:yytokentype
IDENTIFIER	SDCCy.h	159;"	d
IF	SDCCy.c	/^     IF = 333,$/;"	e	enum:yytokentype	file:
IF	SDCCy.c	258;"	d	file:
IF	SDCCy.h	/^     IF = 333,$/;"	e	enum:yytokentype
IF	SDCCy.h	234;"	d
IFFUNC_ARGS	SDCCsymt.h	407;"	d
IFFUNC_BANKED	SDCCsymt.h	435;"	d
IFFUNC_CALLEESAVES	SDCCsymt.h	413;"	d
IFFUNC_HASBODY	SDCCsymt.h	411;"	d
IFFUNC_HASFCALL	SDCCsymt.h	409;"	d
IFFUNC_HASVARARGS	SDCCsymt.h	405;"	d
IFFUNC_ISBANKEDCALL	SDCCsymt.h	450;"	d
IFFUNC_ISBUILTIN	SDCCsymt.h	439;"	d
IFFUNC_ISCRITICAL	SDCCsymt.h	437;"	d
IFFUNC_ISINLINE	SDCCsymt.h	420;"	d
IFFUNC_ISISR	SDCCsymt.h	415;"	d
IFFUNC_ISJAVANATIVE	SDCCsymt.h	441;"	d
IFFUNC_ISNAKED	SDCCsymt.h	431;"	d
IFFUNC_ISNORETURN	SDCCsymt.h	422;"	d
IFFUNC_ISOVERLAY	SDCCsymt.h	443;"	d
IFFUNC_ISREENT	SDCCsymt.h	425;"	d
IFFUNC_ISSHADOWREGS	SDCCsymt.h	427;"	d
IFFUNC_ISSMALLC	SDCCsymt.h	445;"	d
IFFUNC_ISWPARAM	SDCCsymt.h	429;"	d
IFFUNC_NONBANKED	SDCCsymt.h	433;"	d
IFX	SDCCy.c	/^     IFX = 348,$/;"	e	enum:yytokentype	file:
IFX	SDCCy.c	273;"	d	file:
IFX	SDCCy.h	/^     IFX = 348,$/;"	e	enum:yytokentype
IFX	SDCCy.h	249;"	d
INCOMPLETE	SDCCsymt.c	1055;"	d	file:
INC_OP	SDCCy.c	/^     INC_OP = 266,$/;"	e	enum:yytokentype	file:
INC_OP	SDCCy.c	191;"	d	file:
INC_OP	SDCCy.h	/^     INC_OP = 266,$/;"	e	enum:yytokentype
INC_OP	SDCCy.h	167;"	d
INDENT	SDCCast.c	6795;"	d	file:
INITIAL	SDCClex.c	15330;"	d	file:
INITIAL_INLINEASM	SDCCglobl.h	159;"	d
INIT_DEEP	SDCCval.h	/^  INIT_DEEP,$/;"	e
INIT_HOLE	SDCCval.h	/^  INIT_HOLE$/;"	e
INIT_NODE	SDCCval.h	/^  INIT_NODE,$/;"	e
INLINE	SDCCy.c	/^     INLINE = 378,$/;"	e	enum:yytokentype	file:
INLINE	SDCCy.c	303;"	d	file:
INLINE	SDCCy.h	/^     INLINE = 378,$/;"	e	enum:yytokentype
INLINE	SDCCy.h	279;"	d
INLINE	altlex.c	59;"	d	file:
INLINE	altlex.c	61;"	d	file:
INLINEASM	SDCCy.c	/^     INLINEASM = 347,$/;"	e	enum:yytokentype	file:
INLINEASM	SDCCy.c	272;"	d	file:
INLINEASM	SDCCy.h	/^     INLINEASM = 347,$/;"	e	enum:yytokentype
INLINEASM	SDCCy.h	248;"	d
INTERRUPT	SDCCy.c	/^     INTERRUPT = 293,$/;"	e	enum:yytokentype	file:
INTERRUPT	SDCCy.c	218;"	d	file:
INTERRUPT	SDCCy.h	/^     INTERRUPT = 293,$/;"	e	enum:yytokentype
INTERRUPT	SDCCy.h	194;"	d
INTNO_MAX	SDCCsymt.h	34;"	d
INTNO_UNSPEC	SDCCsymt.h	35;"	d
INTSIZE	SDCCglobl.h	145;"	d
INTTYPE	SDCCsymt.h	608;"	d
IN_BITSPACE	SDCCmem.h	95;"	d
IN_CODESPACE	SDCCmem.h	100;"	d
IN_DIRSPACE	SDCCmem.h	98;"	d
IN_FARSPACE	SDCCmem.h	97;"	d
IN_PAGEDSPACE	SDCCmem.h	99;"	d
IN_REGSP	SDCCmem.h	101;"	d
IN_STACK	SDCCmem.h	96;"	d
IPOINTER	SDCCsymt.h	/^  IPOINTER,                         \/* pointer to upper 128 bytes *\/$/;"	e
IPOP	SDCCy.c	/^     IPOP = 360,$/;"	e	enum:yytokentype	file:
IPOP	SDCCy.c	285;"	d	file:
IPOP	SDCCy.h	/^     IPOP = 360,$/;"	e	enum:yytokentype
IPOP	SDCCy.h	261;"	d
IPUSH	SDCCy.c	/^     IPUSH = 359,$/;"	e	enum:yytokentype	file:
IPUSH	SDCCy.c	284;"	d	file:
IPUSH	SDCCy.h	/^     IPUSH = 359,$/;"	e	enum:yytokentype
IPUSH	SDCCy.h	260;"	d
ISALNUM	altlex.c	116;"	d	file:
ISCHARALNUM	SDCCpeeph.c	27;"	d	file:
ISCHARDIGIT	SDCCpeeph.c	25;"	d	file:
ISCHARSPACE	SDCCpeeph.c	26;"	d	file:
ISHEX	altlex.c	117;"	d	file:
ISL	altlex.c	115;"	d	file:
ISTACK_NAME	SDCCmem.h	46;"	d
IS_ABSOLUTE	SDCCsymt.h	521;"	d
IS_ABSOLUTE_PATH	SDCCglobl.h	84;"	d
IS_ABSOLUTE_PATH	SDCCglobl.h	90;"	d
IS_ADDRESS_OF_OP	SDCCast.h	143;"	d
IS_AGGREGATE	SDCCsymt.h	556;"	d
IS_AND	SDCCast.c	5056;"	d	file:
IS_ANDORNOT	SDCCast.c	5059;"	d	file:
IS_ARITHMETIC	SDCCsymt.h	555;"	d
IS_ARITHMETIC_OP	SDCCicode.h	254;"	d
IS_ARRAY	SDCCsymt.h	494;"	d
IS_ARRAY_OP	SDCCast.h	132;"	d
IS_ASSIGN_ICODE	SDCCicode.h	297;"	d
IS_ASSIGN_OP	SDCCast.h	176;"	d
IS_AST_LINK	SDCCast.h	130;"	d
IS_AST_LIT_VALUE	SDCCast.h	146;"	d
IS_AST_NOT_OPER	SDCCast.h	131;"	d
IS_AST_OP	SDCCast.h	121;"	d
IS_AST_PARAM	SDCCast.h	157;"	d
IS_AST_SYM_VALUE	SDCCast.h	148;"	d
IS_AST_VALUE	SDCCast.h	129;"	d
IS_AUTO	SDCCsymt.h	564;"	d
IS_AUTOSYM	SDCClrange.c	36;"	d	file:
IS_BIT	SDCCsymt.h	546;"	d
IS_BITAND	SDCCast.h	124;"	d
IS_BITFIELD	SDCCsymt.h	540;"	d
IS_BITOR	SDCCast.h	123;"	d
IS_BITVAR	SDCCsymt.h	542;"	d
IS_BITWISE_OP	SDCCicode.h	259;"	d
IS_BOOL	SDCCsymt.h	529;"	d
IS_BOOLEAN	SDCCsymt.h	548;"	d
IS_CALLOP	SDCCast.h	122;"	d
IS_CAST_ICODE	SDCCicode.h	294;"	d
IS_CAST_OP	SDCCast.h	140;"	d
IS_CHAR	SDCCsymt.h	530;"	d
IS_CODE	SDCCsymt.h	558;"	d
IS_CODEPTR	SDCCsymt.h	510;"	d
IS_COLON_OP	SDCCast.h	142;"	d
IS_COMMUTATIVE	SDCCicode.h	263;"	d
IS_COMPARE_OP	SDCCast.h	133;"	d
IS_CONDITIONAL	SDCCicode.h	237;"	d
IS_CONSTANT	SDCCsymt.h	518;"	d
IS_DATA_PTR	SDCCsymt.h	495;"	d
IS_DECL	SDCCsymt.h	491;"	d
IS_DEREF_OP	SDCCast.h	179;"	d
IS_DIR_SEPARATOR	SDCCglobl.h	79;"	d
IS_DIR_SEPARATOR	SDCCglobl.h	89;"	d
IS_EXTERN	SDCCsymt.h	531;"	d
IS_FARPTR	SDCCsymt.h	509;"	d
IS_FIXED	SDCCsymt.h	554;"	d
IS_FIXED16X16	SDCCsymt.h	553;"	d
IS_FLOAT	SDCCsymt.h	552;"	d
IS_FOR_STMT	SDCCast.h	126;"	d
IS_FUNC	SDCCsymt.h	513;"	d
IS_FUNCPTR	SDCCsymt.h	512;"	d
IS_GENPTR	SDCCsymt.h	511;"	d
IS_GT	SDCCast.c	5062;"	d	file:
IS_IFX	SDCCast.c	5060;"	d	file:
IS_INLINE	SDCCsymt.h	525;"	d
IS_INT	SDCCsymt.h	527;"	d
IS_INTEGRAL	SDCCsymt.h	533;"	d
IS_ITEMP	SDCCicode.h	62;"	d
IS_ITEMPLBL	SDCCicode.h	64;"	d
IS_LEFT_OP	SDCCast.h	127;"	d
IS_LITERAL	SDCCsymt.h	557;"	d
IS_LONG	SDCCsymt.h	514;"	d
IS_LONGLONG	SDCCsymt.h	515;"	d
IS_LT	SDCCast.c	5061;"	d	file:
IS_MODIFYING_OP	SDCCast.h	173;"	d
IS_NORETURN	SDCCsymt.h	526;"	d
IS_NOT	SDCCast.c	5058;"	d	file:
IS_OP_ACCUSE	SDCCsymt.h	393;"	d
IS_OP_GLOBAL	SDCCicode.h	67;"	d
IS_OP_LITERAL	SDCCicode.h	66;"	d
IS_OP_PARM	SDCCicode.h	69;"	d
IS_OP_POINTER	SDCCicode.h	68;"	d
IS_OP_RUONLY	SDCCsymt.h	392;"	d
IS_OP_VOLATILE	SDCCicode.h	65;"	d
IS_OR	SDCCast.c	5057;"	d	file:
IS_PARM	SDCCicode.h	63;"	d
IS_PTR	SDCCsymt.h	499;"	d
IS_PTR_CONST	SDCCsymt.h	507;"	d
IS_PTR_RESTRICT	SDCCsymt.h	508;"	d
IS_REGISTER	SDCCsymt.h	522;"	d
IS_REGPARM	SDCCsymt.h	559;"	d
IS_RENT	SDCCsymt.h	523;"	d
IS_RESTRICT	SDCCsymt.h	519;"	d
IS_RIGHT_OP	SDCCast.h	128;"	d
IS_SDASLD	port.h	52;"	d
IS_SMALL_PTR	SDCCsymt.h	496;"	d
IS_SPEC	SDCCsymt.h	492;"	d
IS_STATIC	SDCCsymt.h	524;"	d
IS_STRUCT	SDCCsymt.h	520;"	d
IS_SYMOP	SDCCicode.h	51;"	d
IS_TERNARY_OP	SDCCast.h	141;"	d
IS_TRUE_SYMOP	SDCCicode.h	244;"	d
IS_TYPEDEF	SDCCsymt.h	517;"	d
IS_TYPOP	SDCCicode.h	53;"	d
IS_UNSIGNED	SDCCsymt.h	516;"	d
IS_VALID_PARAMETER_STORAGE_CLASS_SPEC	SDCCsymt.h	561;"	d
IS_VALOP	SDCCicode.h	52;"	d
IS_VARG	SDCCval.h	106;"	d
IS_VOID	SDCCsymt.h	528;"	d
IS_VOLATILE	SDCCsymt.h	532;"	d
I_CYCLOMATIC	SDCCerr.h	/^  I_CYCLOMATIC                  = 121, \/* information message *\/$/;"	e
I_EXTENDED_STACK_SPILS	SDCCerr.h	/^  I_EXTENDED_STACK_SPILS        = 114, \/* too many spils occured *\/$/;"	e
JAVANATIVE	SDCCy.c	/^     JAVANATIVE = 344,$/;"	e	enum:yytokentype	file:
JAVANATIVE	SDCCy.c	269;"	d	file:
JAVANATIVE	SDCCy.h	/^     JAVANATIVE = 344,$/;"	e	enum:yytokentype
JAVANATIVE	SDCCy.h	245;"	d
JUMPTABLE	SDCCy.c	/^     JUMPTABLE = 363,$/;"	e	enum:yytokentype	file:
JUMPTABLE	SDCCy.c	288;"	d	file:
JUMPTABLE	SDCCy.h	/^     JUMPTABLE = 363,$/;"	e	enum:yytokentype
JUMPTABLE	SDCCy.h	264;"	d
LABEL	SDCCy.c	/^     LABEL = 371,$/;"	e	enum:yytokentype	file:
LABEL	SDCCy.c	296;"	d	file:
LABEL	SDCCy.h	/^     LABEL = 371,$/;"	e	enum:yytokentype
LABEL	SDCCy.h	272;"	d
LARGE_MODEL	SDCCglobl.h	156;"	d
LEAF	SDCCicode.h	/^  LEAF$/;"	e
LEFT_ASSIGN	SDCCy.c	/^     LEFT_ASSIGN = 281,$/;"	e	enum:yytokentype	file:
LEFT_ASSIGN	SDCCy.c	206;"	d	file:
LEFT_ASSIGN	SDCCy.h	/^     LEFT_ASSIGN = 281,$/;"	e	enum:yytokentype
LEFT_ASSIGN	SDCCy.h	182;"	d
LEFT_FIRST	SDCCast.h	167;"	d
LEFT_OP	SDCCy.c	/^     LEFT_OP = 268,$/;"	e	enum:yytokentype	file:
LEFT_OP	SDCCy.c	193;"	d	file:
LEFT_OP	SDCCy.h	/^     LEFT_OP = 268,$/;"	e	enum:yytokentype
LEFT_OP	SDCCy.h	169;"	d
LENGTH	SDCCmain.c	94;"	d	file:
LETYPE	SDCCast.c	51;"	d	file:
LE_OP	SDCCy.c	/^     LE_OP = 270,$/;"	e	enum:yytokentype	file:
LE_OP	SDCCy.c	195;"	d	file:
LE_OP	SDCCy.h	/^     LE_OP = 270,$/;"	e	enum:yytokentype
LE_OP	SDCCy.h	171;"	d
LLVAL	SDCCast.c	45;"	d	file:
LONGLONGSIZE	SDCCglobl.h	147;"	d
LONGLONGTYPE	SDCCsymt.h	612;"	d
LONGSIZE	SDCCglobl.h	146;"	d
LONGTYPE	SDCCsymt.h	610;"	d
LOOPEXITLBL	SDCCicode.h	325;"	d
LRETYPE	SDCCicode.h	59;"	d
LRFTYPE	SDCCicode.h	57;"	d
LRTYPE	SDCCicode.h	61;"	d
LRVAL	SDCCast.c	42;"	d	file:
LTYPE	SDCCast.c	50;"	d	file:
LabelTab	SDCCsymt.c	/^bucket *LabelTab[256];          \/* the Label     table  *\/$/;"	v
MAXBASESIZE	SDCCglobl.h	153;"	d
MAX_BUILTIN_ARGS	port.h	54;"	d
MAX_NEST_LEVEL	SDCCsymt.h	27;"	d
MAX_PATTERN_LEN	SDCCpeeph.h	27;"	d
MAX_REG_PARMS	SDCCglobl.h	121;"	d
MAX_TVAR	SDCCglobl.h	158;"	d
MODEL_COMPACT	SDCCglobl.h	/^    MODEL_COMPACT = 2,$/;"	e
MODEL_FLAT24	SDCCglobl.h	/^    MODEL_FLAT24 = 16,$/;"	e
MODEL_HUGE	SDCCglobl.h	/^    MODEL_HUGE = 64   \/* for banked support *\/$/;"	e
MODEL_LARGE	SDCCglobl.h	/^    MODEL_LARGE = 8,$/;"	e
MODEL_MEDIUM	SDCCglobl.h	/^    MODEL_MEDIUM = 4,$/;"	e
MODEL_PAGE0	SDCCglobl.h	/^    MODEL_PAGE0 = 32, \/* for the xa51 port *\/$/;"	e
MODEL_SMALL	SDCCglobl.h	/^    MODEL_SMALL = 1,$/;"	e
MOD_ASSIGN	SDCCy.c	/^     MOD_ASSIGN = 278,$/;"	e	enum:yytokentype	file:
MOD_ASSIGN	SDCCy.c	203;"	d	file:
MOD_ASSIGN	SDCCy.h	/^     MOD_ASSIGN = 278,$/;"	e	enum:yytokentype
MOD_ASSIGN	SDCCy.h	179;"	d
MSVC_style	SDCCerr.c	/^MSVC_style (int style)$/;"	f
MUL_ASSIGN	SDCCy.c	/^     MUL_ASSIGN = 276,$/;"	e	enum:yytokentype	file:
MUL_ASSIGN	SDCCy.c	201;"	d	file:
MUL_ASSIGN	SDCCy.h	/^     MUL_ASSIGN = 276,$/;"	e	enum:yytokentype
MUL_ASSIGN	SDCCy.h	177;"	d
NAKED	SDCCy.c	/^     NAKED = 343,$/;"	e	enum:yytokentype	file:
NAKED	SDCCy.c	268;"	d	file:
NAKED	SDCCy.h	/^     NAKED = 343,$/;"	e	enum:yytokentype
NAKED	SDCCy.h	244;"	d
NATIVE_WIN32	SDCCglobl.h	96;"	d
NELEM	SDCCerr.c	24;"	d	file:
NE_OP	SDCCy.c	/^     NE_OP = 273,$/;"	e	enum:yytokentype	file:
NE_OP	SDCCy.c	198;"	d	file:
NE_OP	SDCCy.h	/^     NE_OP = 273,$/;"	e	enum:yytokentype
NE_OP	SDCCy.h	174;"	d
NONBANKED	SDCCy.c	/^     NONBANKED = 308,$/;"	e	enum:yytokentype	file:
NONBANKED	SDCCy.c	233;"	d	file:
NONBANKED	SDCCy.h	/^     NONBANKED = 308,$/;"	e	enum:yytokentype
NONBANKED	SDCCy.h	209;"	d
NORETURN	SDCCy.c	/^     NORETURN = 379,$/;"	e	enum:yytokentype	file:
NORETURN	SDCCy.c	304;"	d	file:
NORETURN	SDCCy.h	/^     NORETURN = 379,$/;"	e	enum:yytokentype
NORETURN	SDCCy.h	280;"	d
NOUN	SDCCsymt.h	/^NOUN;$/;"	t
NO_MODEL	SDCCglobl.h	/^    NO_MODEL = 0,     \/* no model applicable *\/$/;"	e
NULLOP	SDCCy.c	/^     NULLOP = 369,$/;"	e	enum:yytokentype	file:
NULLOP	SDCCy.c	294;"	d	file:
NULLOP	SDCCy.h	/^     NULLOP = 369,$/;"	e	enum:yytokentype
NULLOP	SDCCy.h	270;"	d
NUMBER_OF_ERROR_MESSAGES	SDCCerr.h	/^  NUMBER_OF_ERROR_MESSAGES             \/* Number of error messages *\/$/;"	e
NUM_PORTS	SDCCmain.c	353;"	d	file:
NestLevel	SDCCy.c	/^int NestLevel = 0;      \/* current NestLevel       *\/$/;"	v
OFFSETOF	SDCCy.c	/^     OFFSETOF = 264,$/;"	e	enum:yytokentype	file:
OFFSETOF	SDCCy.c	189;"	d	file:
OFFSETOF	SDCCy.h	/^     OFFSETOF = 264,$/;"	e	enum:yytokentype
OFFSETOF	SDCCy.h	165;"	d
OPTION	SDCCargs.h	/^  } OPTION;$/;"	t
OPTION_CALLEE_SAVES	SDCCmain.c	106;"	d	file:
OPTION_CODE_LOC	SDCCmain.c	112;"	d	file:
OPTION_CODE_SEG	SDCCmain.c	141;"	d	file:
OPTION_CODE_SIZE	SDCCmain.c	115;"	d	file:
OPTION_CONST_SEG	SDCCmain.c	142;"	d	file:
OPTION_DATA_LOC	SDCCmain.c	109;"	d	file:
OPTION_DEBUG	SDCCmain.c	123;"	d	file:
OPTION_DISABLE_WARNING	SDCCmain.c	121;"	d	file:
OPTION_DOLLARS_IN_IDENT	SDCCmain.c	143;"	d	file:
OPTION_DUMP_ALL	SDCCmain.c	103;"	d	file:
OPTION_DUMP_GRAPHS	SDCCmain.c	149;"	d	file:
OPTION_HELP	SDCCmain.c	96;"	d	file:
OPTION_HUGE_MODEL	SDCCmain.c	99;"	d	file:
OPTION_ICODE_IN_ASM	SDCCmain.c	128;"	d	file:
OPTION_IDATA_LOC	SDCCmain.c	110;"	d	file:
OPTION_IRAM_SIZE	SDCCmain.c	113;"	d	file:
OPTION_LARGE_MODEL	SDCCmain.c	100;"	d	file:
OPTION_LESS_PEDANTIC	SDCCmain.c	120;"	d	file:
OPTION_LIB_PATH	SDCCmain.c	105;"	d	file:
OPTION_MAX_ALLOCS_PER_NODE	SDCCmain.c	150;"	d	file:
OPTION_MEDIUM_MODEL	SDCCmain.c	101;"	d	file:
OPTION_MSVC_ERROR_STYLE	SDCCmain.c	130;"	d	file:
OPTION_NO_CCODE_IN_ASM	SDCCmain.c	127;"	d	file:
OPTION_NO_GCSE	SDCCmain.c	124;"	d	file:
OPTION_NO_LABEL_OPT	SDCCmain.c	117;"	d	file:
OPTION_NO_LOOP_IND	SDCCmain.c	119;"	d	file:
OPTION_NO_LOOP_INV	SDCCmain.c	118;"	d	file:
OPTION_NO_OPTSDCC_IN_ASM	SDCCmain.c	148;"	d	file:
OPTION_NO_PEEP_COMMENTS	SDCCmain.c	132;"	d	file:
OPTION_NO_PEEP_RETURN	SDCCmain.c	147;"	d	file:
OPTION_NO_XINIT_OPT	SDCCmain.c	126;"	d	file:
OPTION_OPT_CODE_SIZE	SDCCmain.c	135;"	d	file:
OPTION_OPT_CODE_SPEED	SDCCmain.c	134;"	d	file:
OPTION_OUT_FMT_IHX	SDCCmain.c	97;"	d	file:
OPTION_OUT_FMT_S19	SDCCmain.c	98;"	d	file:
OPTION_PEEP_FILE	SDCCmain.c	104;"	d	file:
OPTION_PEEP_RETURN	SDCCmain.c	146;"	d	file:
OPTION_PRINT_SEARCH_DIRS	SDCCmain.c	129;"	d	file:
OPTION_SHORT_IS_8BITS	SDCCmain.c	125;"	d	file:
OPTION_SMALL_MODEL	SDCCmain.c	102;"	d	file:
OPTION_STACK_LOC	SDCCmain.c	107;"	d	file:
OPTION_STD_C11	SDCCmain.c	138;"	d	file:
OPTION_STD_C89	SDCCmain.c	136;"	d	file:
OPTION_STD_C99	SDCCmain.c	137;"	d	file:
OPTION_STD_SDCC89	SDCCmain.c	139;"	d	file:
OPTION_STD_SDCC99	SDCCmain.c	140;"	d	file:
OPTION_UNSIGNED_CHAR	SDCCmain.c	144;"	d	file:
OPTION_USE_NON_FREE	SDCCmain.c	145;"	d	file:
OPTION_USE_STDOUT	SDCCmain.c	131;"	d	file:
OPTION_VERBOSE_ASM	SDCCmain.c	133;"	d	file:
OPTION_VERSION	SDCCmain.c	116;"	d	file:
OPTION_WERROR	SDCCmain.c	122;"	d	file:
OPTION_XRAM_LOC	SDCCmain.c	111;"	d	file:
OPTION_XRAM_SIZE	SDCCmain.c	114;"	d	file:
OPTION_XSTACK_LOC	SDCCmain.c	108;"	d	file:
OPTYPE	SDCCicode.h	/^OPTYPE;$/;"	t
OP_DEFS	SDCCicode.h	299;"	d
OP_ISLIVE_FCALL	SDCCicode.h	70;"	d
OP_KEY	SDCCicode.h	116;"	d
OP_LIVEFROM	SDCCicode.h	113;"	d
OP_LIVETO	SDCCicode.h	114;"	d
OP_REQV	SDCCicode.h	115;"	d
OP_SYMBOL	SDCCicode.h	107;"	d
OP_SYMBOL_CONST	SDCCicode.h	108;"	d
OP_SYM_ETYPE	SDCCicode.h	111;"	d
OP_SYM_TYPE	SDCCicode.h	110;"	d
OP_TYPE	SDCCicode.h	117;"	d
OP_USES	SDCCicode.h	300;"	d
OP_VALUE	SDCCicode.h	109;"	d
OR_ASSIGN	SDCCy.c	/^     OR_ASSIGN = 285,$/;"	e	enum:yytokentype	file:
OR_ASSIGN	SDCCy.c	210;"	d	file:
OR_ASSIGN	SDCCy.h	/^     OR_ASSIGN = 285,$/;"	e	enum:yytokentype
OR_ASSIGN	SDCCy.h	186;"	d
OR_OP	SDCCy.c	/^     OR_OP = 275,$/;"	e	enum:yytokentype	file:
OR_OP	SDCCy.c	200;"	d	file:
OR_OP	SDCCy.h	/^     OR_OP = 275,$/;"	e	enum:yytokentype
OR_OP	SDCCy.h	176;"	d
OTHERS_PARM	SDCCcse.c	1523;"	d	file:
OVERLAY	SDCCy.c	/^     OVERLAY = 345,$/;"	e	enum:yytokentype	file:
OVERLAY	SDCCy.c	270;"	d	file:
OVERLAY	SDCCy.h	/^     OVERLAY = 345,$/;"	e	enum:yytokentype
OVERLAY	SDCCy.h	246;"	d
OVERLAY_NAME	SDCCmem.h	58;"	d
PA	SDCCast.c	/^PA (ast * t)$/;"	f
PARAM	SDCCy.c	/^     PARAM = 368,$/;"	e	enum:yytokentype	file:
PARAM	SDCCy.c	293;"	d	file:
PARAM	SDCCy.h	/^     PARAM = 368,$/;"	e	enum:yytokentype
PARAM	SDCCy.h	269;"	d
PATH_MAX	SDCCglobl.h	117;"	d
PATH_MAX	SDCCglobl.h	118;"	d
PATH_MAX	SDCCglobl.h	98;"	d
PCALL	SDCCy.c	/^     PCALL = 361,$/;"	e	enum:yytokentype	file:
PCALL	SDCCy.c	286;"	d	file:
PCALL	SDCCy.h	/^     PCALL = 361,$/;"	e	enum:yytokentype
PCALL	SDCCy.h	262;"	d
PDATA	SDCCy.c	/^     PDATA = 305,$/;"	e	enum:yytokentype	file:
PDATA	SDCCy.c	230;"	d	file:
PDATA	SDCCy.h	/^     PDATA = 305,$/;"	e	enum:yytokentype
PDATA	SDCCy.h	206;"	d
PDATA_NAME	SDCCmem.h	50;"	d
PEEK	SDCCglobl.h	166;"	d
PICC	SDCCicode.c	/^PICC (iCode * ic)$/;"	f
POINTER	SDCCsymt.h	/^  POINTER = 0,                      \/* pointer to near data *\/$/;"	e
POINTER_GET	SDCCicode.h	250;"	d
POINTER_SET	SDCCicode.h	246;"	d
POP	SDCCglobl.h	167;"	d
PORT	port.h	/^PORT;$/;"	t
PORT_INCLUDE	port.h	6;"	d
PORT_MAGIC	port.h	386;"	d
PPOINTER	SDCCsymt.h	/^  PPOINTER,                         \/* paged area pointer   *\/$/;"	e
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picAddrOf)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picAssign)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picCast)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picCritical)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picDummyRead)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picEndCritical)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picGeneric)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picGenericOne)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picGetValueAtAddr)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picGoto)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picIfx)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picInline)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picJumpTable)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picLabel)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picReceive)$/;"	f
PRINTFUNC	SDCCicode.c	/^PRINTFUNC (picSetValueAtAddr)$/;"	f
PRINTFUNC	SDCCicode.c	57;"	d	file:
PT	SDCCsymt.c	/^PT (sym_link * type)$/;"	f
PTRSIZE	SDCCglobl.h	148;"	d
PTR_OP	SDCCy.c	/^     PTR_OP = 265,$/;"	e	enum:yytokentype	file:
PTR_OP	SDCCy.c	190;"	d	file:
PTR_OP	SDCCy.h	/^     PTR_OP = 265,$/;"	e	enum:yytokentype
PTR_OP	SDCCy.h	166;"	d
PTR_TYPE	SDCCmem.h	102;"	d
PUSH	SDCCglobl.h	165;"	d
P_CALLEE_SAVES	SDCClex.c	/^   P_CALLEE_SAVES,$/;"	e	file:
P_CODESEG	SDCClex.c	/^   P_CODESEG,$/;"	e	file:
P_CONSTSEG	SDCClex.c	/^   P_CONSTSEG$/;"	e	file:
P_DISABLEWARN	SDCClex.c	/^   P_DISABLEWARN,$/;"	e	file:
P_EXCLUDE	SDCClex.c	/^   P_EXCLUDE,$/;"	e	file:
P_INDUCTION	SDCClex.c	/^   P_INDUCTION,$/;"	e	file:
P_LESSPEDANTIC	SDCClex.c	/^   P_LESSPEDANTIC,$/;"	e	file:
P_LOOPREV	SDCClex.c	/^   P_LOOPREV,$/;"	e	file:
P_NOGCSE	SDCClex.c	/^   P_NOGCSE,$/;"	e	file:
P_NOINDUCTION	SDCClex.c	/^   P_NOINDUCTION,$/;"	e	file:
P_NOINVARIANT	SDCClex.c	/^   P_NOINVARIANT,$/;"	e	file:
P_NOIV	SDCClex.c	/^   P_NOIV,$/;"	e	file:
P_NOJTBOUND	SDCClex.c	/^   P_NOJTBOUND,$/;"	e	file:
P_NOOVERLAY	SDCClex.c	/^   P_NOOVERLAY,$/;"	e	file:
P_OPTCODEBALANCED	SDCClex.c	/^   P_OPTCODEBALANCED,$/;"	e	file:
P_OPTCODESIZE	SDCClex.c	/^   P_OPTCODESIZE,$/;"	e	file:
P_OPTCODESPEED	SDCClex.c	/^   P_OPTCODESPEED,$/;"	e	file:
P_OVERLAY_	SDCClex.c	/^   P_OVERLAY_,     \/* I had a strange conflict with P_OVERLAY while *\/$/;"	e	file:
P_RESTORE	SDCClex.c	/^   P_RESTORE,$/;"	e	file:
P_SAVE	SDCClex.c	/^   P_SAVE = 1,$/;"	e	file:
P_STACKAUTO	SDCClex.c	/^   P_STACKAUTO,$/;"	e	file:
P_STD_C11	SDCClex.c	/^   P_STD_C11,$/;"	e	file:
P_STD_C89	SDCClex.c	/^   P_STD_C89,$/;"	e	file:
P_STD_C99	SDCClex.c	/^   P_STD_C99,$/;"	e	file:
P_STD_SDCC89	SDCClex.c	/^   P_STD_SDCC89,$/;"	e	file:
P_STD_SDCC99	SDCClex.c	/^   P_STD_SDCC99,$/;"	e	file:
RANGE	SDCCy.c	/^     RANGE = 329,$/;"	e	enum:yytokentype	file:
RANGE	SDCCy.c	254;"	d	file:
RANGE	SDCCy.h	/^     RANGE = 329,$/;"	e	enum:yytokentype
RANGE	SDCCy.h	230;"	d
RECEIVE	SDCCy.c	/^     RECEIVE = 372,$/;"	e	enum:yytokentype	file:
RECEIVE	SDCCy.c	297;"	d	file:
RECEIVE	SDCCy.h	/^     RECEIVE = 372,$/;"	e	enum:yytokentype
RECEIVE	SDCCy.h	273;"	d
REENTRANT	SDCCy.c	/^     REENTRANT = 300,$/;"	e	enum:yytokentype	file:
REENTRANT	SDCCy.c	225;"	d	file:
REENTRANT	SDCCy.h	/^     REENTRANT = 300,$/;"	e	enum:yytokentype
REENTRANT	SDCCy.h	201;"	d
REGA	SDCCicode.c	177;"	d	file:
REGISTER	SDCCy.c	/^     REGISTER = 290,$/;"	e	enum:yytokentype	file:
REGISTER	SDCCy.c	215;"	d	file:
REGISTER	SDCCy.h	/^     REGISTER = 290,$/;"	e	enum:yytokentype
REGISTER	SDCCy.h	191;"	d
REG_NAME	SDCCmem.h	55;"	d
REJECT	SDCClex.c	15324;"	d	file:
RESTRICT	SDCCy.c	/^     RESTRICT = 380,$/;"	e	enum:yytokentype	file:
RESTRICT	SDCCy.c	305;"	d	file:
RESTRICT	SDCCy.h	/^     RESTRICT = 380,$/;"	e	enum:yytokentype
RESTRICT	SDCCy.h	281;"	d
RESULT_TYPE	SDCCsymt.h	/^} RESULT_TYPE;$/;"	t
RESULT_TYPE_BIT	SDCCsymt.h	/^  RESULT_TYPE_BIT,$/;"	e
RESULT_TYPE_CHAR	SDCCsymt.h	/^  RESULT_TYPE_CHAR,$/;"	e
RESULT_TYPE_GPTR	SDCCsymt.h	/^  RESULT_TYPE_GPTR              \/* operands will be promoted to generic ptr *\/$/;"	e
RESULT_TYPE_IFX	SDCCsymt.h	/^  RESULT_TYPE_IFX,$/;"	e
RESULT_TYPE_INT	SDCCsymt.h	/^  RESULT_TYPE_INT,$/;"	e
RESULT_TYPE_NONE	SDCCsymt.h	/^  RESULT_TYPE_NONE = 0,         \/* operands will be promoted to int *\/$/;"	e
RESULT_TYPE_OTHER	SDCCsymt.h	/^  RESULT_TYPE_OTHER,            \/* operands will be promoted to int *\/$/;"	e
RETURN	SDCCy.c	/^     RETURN = 342,$/;"	e	enum:yytokentype	file:
RETURN	SDCCy.c	267;"	d	file:
RETURN	SDCCy.h	/^     RETURN = 342,$/;"	e	enum:yytokentype
RETURN	SDCCy.h	243;"	d
RETYPE	SDCCast.c	49;"	d	file:
RIGHT_ASSIGN	SDCCy.c	/^     RIGHT_ASSIGN = 282,$/;"	e	enum:yytokentype	file:
RIGHT_ASSIGN	SDCCy.c	207;"	d	file:
RIGHT_ASSIGN	SDCCy.h	/^     RIGHT_ASSIGN = 282,$/;"	e	enum:yytokentype
RIGHT_ASSIGN	SDCCy.h	183;"	d
RIGHT_OP	SDCCy.c	/^     RIGHT_OP = 269,$/;"	e	enum:yytokentype	file:
RIGHT_OP	SDCCy.c	194;"	d	file:
RIGHT_OP	SDCCy.h	/^     RIGHT_OP = 269,$/;"	e	enum:yytokentype
RIGHT_OP	SDCCy.h	170;"	d
RLC	SDCCy.c	/^     RLC = 365,$/;"	e	enum:yytokentype	file:
RLC	SDCCy.c	290;"	d	file:
RLC	SDCCy.h	/^     RLC = 365,$/;"	e	enum:yytokentype
RLC	SDCCy.h	266;"	d
RLVAL	SDCCast.c	46;"	d	file:
RRC	SDCCy.c	/^     RRC = 364,$/;"	e	enum:yytokentype	file:
RRC	SDCCy.c	289;"	d	file:
RRC	SDCCy.h	/^     RRC = 364,$/;"	e	enum:yytokentype
RRC	SDCCy.h	265;"	d
RRVAL	SDCCast.c	43;"	d	file:
RTYPE	SDCCast.c	48;"	d	file:
RegBankUsed	SDCCmain.c	/^int RegBankUsed[4] = { 1, 0, 0, 0 };    \/*JCF: Reg Bank 0 used by default *\/$/;"	v
ReplaceOpWithCheaperOp	SDCCcse.c	/^void ReplaceOpWithCheaperOp(operand **op, operand *cop) {$/;"	f
SAVE_RESTORE_SIZE	SDCClex.c	17512;"	d	file:
SBIT	SDCCy.c	/^     SBIT = 299,$/;"	e	enum:yytokentype	file:
SBIT	SDCCy.c	224;"	d	file:
SBIT	SDCCy.h	/^     SBIT = 299,$/;"	e	enum:yytokentype
SBIT	SDCCy.h	200;"	d
SCHARTYPE	SDCCsymt.h	606;"	d
SDCCARGS_H	SDCCargs.h	30;"	d
SDCCASM_H	SDCCasm.h	22;"	d
SDCCAST_H	SDCCast.h	26;"	d
SDCCBBLOCK_H	SDCCBBlock.h	27;"	d
SDCCBITV_H	SDCCbitv.h	29;"	d
SDCCCFLOW_H	SDCCcflow.h	29;"	d
SDCCCSE_H	SDCCcse.h	29;"	d
SDCCDFLOW_H	SDCCdflow.h	30;"	d
SDCCDWARF2_H	SDCCdwarf2.h	26;"	d
SDCCERRG	SDCCerr.h	/^struct SDCCERRG {$/;"	s
SDCCGEN_H	SDCCgen.h	22;"	d
SDCCGLOBL_H	SDCCglobl.h	22;"	d
SDCCGLUE_H	SDCCglue.h	28;"	d
SDCCHASHT_H	SDCChasht.h	27;"	d
SDCCICODE_H	SDCCicode.h	28;"	d
SDCCLABEL_H	SDCClabel.h	29;"	d
SDCCLOOP_H	SDCCloop.h	29;"	d
SDCCLRANGE_H	SDCClrange.h	27;"	d
SDCCMACRO_H	SDCCmacro.h	27;"	d
SDCCMEM_H	SDCCmem.h	6;"	d
SDCCOPT_H	SDCCopt.h	28;"	d
SDCCPEEPH_H	SDCCpeeph.h	23;"	d
SDCCPTROPT_H	SDCCptropt.h	27;"	d
SDCCSET_H	SDCCset.h	26;"	d
SDCCSYMT_H	SDCCsymt.h	25;"	d
SDCCSYSTEM_H	SDCCsystem.h	26;"	d
SDCCUTIL_H	SDCCutil.h	26;"	d
SDCCVAL_H	SDCCval.h	24;"	d
SDCC_BUILD_NR	version.h	13;"	d
SDCC_BUILD_NR	version.h	17;"	d
SDCC_BUILD_NUMBER	version.h	12;"	d
SDCC_BUILD_NUMBER	version.h	16;"	d
SDCC_NAME_MAX	SDCCsymt.h	29;"	d
SDCC_SYMNAME_MAX	SDCCsymt.h	28;"	d
SDCCsnprintf	SDCCutil.c	/^SDCCsnprintf (char *dst, size_t n, const char *fmt, ...)$/;"	f
SD_BOOL	SDCCy.c	/^     SD_BOOL = 312,$/;"	e	enum:yytokentype	file:
SD_BOOL	SDCCy.c	237;"	d	file:
SD_BOOL	SDCCy.h	/^     SD_BOOL = 312,$/;"	e	enum:yytokentype
SD_BOOL	SDCCy.h	213;"	d
SD_CHAR	SDCCy.c	/^     SD_CHAR = 313,$/;"	e	enum:yytokentype	file:
SD_CHAR	SDCCy.c	238;"	d	file:
SD_CHAR	SDCCy.h	/^     SD_CHAR = 313,$/;"	e	enum:yytokentype
SD_CHAR	SDCCy.h	214;"	d
SD_CONST	SDCCy.c	/^     SD_CONST = 322,$/;"	e	enum:yytokentype	file:
SD_CONST	SDCCy.c	247;"	d	file:
SD_CONST	SDCCy.h	/^     SD_CONST = 322,$/;"	e	enum:yytokentype
SD_CONST	SDCCy.h	223;"	d
SD_FAR	SDCCy.c	/^     SD_FAR = 330,$/;"	e	enum:yytokentype	file:
SD_FAR	SDCCy.c	255;"	d	file:
SD_FAR	SDCCy.h	/^     SD_FAR = 330,$/;"	e	enum:yytokentype
SD_FAR	SDCCy.h	231;"	d
SD_FLOAT	SDCCy.c	/^     SD_FLOAT = 319,$/;"	e	enum:yytokentype	file:
SD_FLOAT	SDCCy.c	244;"	d	file:
SD_FLOAT	SDCCy.h	/^     SD_FLOAT = 319,$/;"	e	enum:yytokentype
SD_FLOAT	SDCCy.h	220;"	d
SD_INT	SDCCy.c	/^     SD_INT = 315,$/;"	e	enum:yytokentype	file:
SD_INT	SDCCy.c	240;"	d	file:
SD_INT	SDCCy.h	/^     SD_INT = 315,$/;"	e	enum:yytokentype
SD_INT	SDCCy.h	216;"	d
SD_LONG	SDCCy.c	/^     SD_LONG = 316,$/;"	e	enum:yytokentype	file:
SD_LONG	SDCCy.c	241;"	d	file:
SD_LONG	SDCCy.h	/^     SD_LONG = 316,$/;"	e	enum:yytokentype
SD_LONG	SDCCy.h	217;"	d
SD_SHORT	SDCCy.c	/^     SD_SHORT = 314,$/;"	e	enum:yytokentype	file:
SD_SHORT	SDCCy.c	239;"	d	file:
SD_SHORT	SDCCy.h	/^     SD_SHORT = 314,$/;"	e	enum:yytokentype
SD_SHORT	SDCCy.h	215;"	d
SD_VOID	SDCCy.c	/^     SD_VOID = 324,$/;"	e	enum:yytokentype	file:
SD_VOID	SDCCy.c	249;"	d	file:
SD_VOID	SDCCy.h	/^     SD_VOID = 324,$/;"	e	enum:yytokentype
SD_VOID	SDCCy.h	225;"	d
SD_WPARAM	SDCCy.c	/^     SD_WPARAM = 311,$/;"	e	enum:yytokentype	file:
SD_WPARAM	SDCCy.c	236;"	d	file:
SD_WPARAM	SDCCy.h	/^     SD_WPARAM = 311,$/;"	e	enum:yytokentype
SD_WPARAM	SDCCy.h	212;"	d
SEND	SDCCy.c	/^     SEND = 373,$/;"	e	enum:yytokentype	file:
SEND	SDCCy.c	298;"	d	file:
SEND	SDCCy.h	/^     SEND = 373,$/;"	e	enum:yytokentype
SEND	SDCCy.h	274;"	d
SET_ISADDR	SDCCicode.h	295;"	d
SET_RESULT_RIGHT	SDCCicode.h	296;"	d
SFR	SDCCy.c	/^     SFR = 294,$/;"	e	enum:yytokentype	file:
SFR	SDCCy.c	219;"	d	file:
SFR	SDCCy.h	/^     SFR = 294,$/;"	e	enum:yytokentype
SFR	SDCCy.h	195;"	d
SFR16	SDCCy.c	/^     SFR16 = 295,$/;"	e	enum:yytokentype	file:
SFR16	SDCCy.c	220;"	d	file:
SFR16	SDCCy.h	/^     SFR16 = 295,$/;"	e	enum:yytokentype
SFR16	SDCCy.h	196;"	d
SFR32	SDCCy.c	/^     SFR32 = 296,$/;"	e	enum:yytokentype	file:
SFR32	SDCCy.c	221;"	d	file:
SFR32	SDCCy.h	/^     SFR32 = 296,$/;"	e	enum:yytokentype
SFR32	SDCCy.h	197;"	d
SHADOWREGS	SDCCy.c	/^     SHADOWREGS = 310,$/;"	e	enum:yytokentype	file:
SHADOWREGS	SDCCy.c	235;"	d	file:
SHADOWREGS	SDCCy.h	/^     SHADOWREGS = 310,$/;"	e	enum:yytokentype
SHADOWREGS	SDCCy.h	211;"	d
SHORTSIZE	SDCCglobl.h	144;"	d
SIDE_EFFECTS_CHECK	SDCCast.h	169;"	d
SIGNED	SDCCy.c	/^     SIGNED = 317,$/;"	e	enum:yytokentype	file:
SIGNED	SDCCy.c	242;"	d	file:
SIGNED	SDCCy.h	/^     SIGNED = 317,$/;"	e	enum:yytokentype
SIGNED	SDCCy.h	218;"	d
SIZEOF	SDCCy.c	/^     SIZEOF = 262,$/;"	e	enum:yytokentype	file:
SIZEOF	SDCCy.c	187;"	d	file:
SIZEOF	SDCCy.h	/^     SIZEOF = 262,$/;"	e	enum:yytokentype
SIZEOF	SDCCy.h	163;"	d
SKIP_IC	SDCCicode.h	223;"	d
SKIP_IC1	SDCCicode.h	220;"	d
SKIP_IC2	SDCCicode.h	214;"	d
SKIP_IC3	SDCCicode.h	234;"	d
SKIP_SPACE	SDCCpeeph.c	1343;"	d	file:
SMALLC	SDCCy.c	/^     SMALLC = 381,$/;"	e	enum:yytokentype	file:
SMALLC	SDCCy.c	306;"	d	file:
SMALLC	SDCCy.h	/^     SMALLC = 381,$/;"	e	enum:yytokentype
SMALLC	SDCCy.h	282;"	d
SMALL_MODEL	SDCCglobl.h	155;"	d
SNPRINTF	SDCCutil.h	134;"	d
SNPRINTF	SDCCutil.h	141;"	d
SNPRINTF	SDCCutil.h	147;"	d
SPACE	SDCCglobl.h	112;"	d
SPECIFIER	SDCCsymt.h	/^  SPECIFIER$/;"	e
SPEC_ABSA	SDCCsymt.h	464;"	d
SPEC_ADDR	SDCCsymt.h	466;"	d
SPEC_ADDRSPACE	SDCCsymt.h	482;"	d
SPEC_ARGREG	SDCCsymt.h	486;"	d
SPEC_BANK	SDCCsymt.h	465;"	d
SPEC_BLEN	SDCCsymt.h	470;"	d
SPEC_BSTR	SDCCsymt.h	469;"	d
SPEC_BUNNAMED	SDCCsymt.h	471;"	d
SPEC_CODE	SDCCsymt.h	463;"	d
SPEC_CONST	SDCCsymt.h	480;"	d
SPEC_CVAL	SDCCsymt.h	468;"	d
SPEC_ENUM	SDCCsymt.h	459;"	d
SPEC_EXTR	SDCCsymt.h	462;"	d
SPEC_INLINE	SDCCsymt.h	487;"	d
SPEC_ISR_SAVED_BANKS	SDCCsymt.h	478;"	d
SPEC_LONG	SDCCsymt.h	454;"	d
SPEC_LONGLONG	SDCCsymt.h	455;"	d
SPEC_NORETURN	SDCCsymt.h	488;"	d
SPEC_NOUN	SDCCsymt.h	453;"	d
SPEC_OCLS	SDCCsymt.h	460;"	d
SPEC_REGPARM	SDCCsymt.h	485;"	d
SPEC_RESTRICT	SDCCsymt.h	481;"	d
SPEC_SCLS	SDCCsymt.h	458;"	d
SPEC_SHORT	SDCCsymt.h	456;"	d
SPEC_STAK	SDCCsymt.h	467;"	d
SPEC_STAT	SDCCsymt.h	461;"	d
SPEC_STRUCT	SDCCsymt.h	483;"	d
SPEC_TYPEDEF	SDCCsymt.h	484;"	d
SPEC_USIGN	SDCCsymt.h	457;"	d
SPEC_VOLATILE	SDCCsymt.h	479;"	d
SPIL	SDCCy.c	/^     SPIL = 351,$/;"	e	enum:yytokentype	file:
SPIL	SDCCy.c	276;"	d	file:
SPIL	SDCCy.h	/^     SPIL = 351,$/;"	e	enum:yytokentype
SPIL	SDCCy.h	252;"	d
SPIL_LOC	SDCCicode.h	112;"	d
SP_BP	SDCCmem.c	1084;"	d	file:
STACK_DCL	SDCCglobl.h	181;"	d
STACK_EMPTY	SDCCglobl.h	192;"	d
STACK_ERR	SDCCglobl.h	211;"	d
STACK_FULL	SDCCglobl.h	193;"	d
STACK_PEEK	SDCCglobl.h	207;"	d
STACK_POP	SDCCglobl.h	203;"	d
STACK_POP_	SDCCglobl.h	197;"	d
STACK_PUSH	SDCCglobl.h	199;"	d
STACK_PUSH_	SDCCglobl.h	196;"	d
STATEMENT	SDCCicode.h	/^  STATEMENT,$/;"	e
STATIC	SDCCy.c	/^     STATIC = 288,$/;"	e	enum:yytokentype	file:
STATIC	SDCCy.c	213;"	d	file:
STATIC	SDCCy.h	/^     STATIC = 288,$/;"	e	enum:yytokentype
STATIC	SDCCy.h	189;"	d
STATIC_NAME	SDCCmem.h	56;"	d
STDERR_FILENO	SDCCglobl.h	433;"	d
STDIN_FILENO	SDCCglobl.h	427;"	d
STDOUT_FILENO	SDCCglobl.h	430;"	d
STORAGE_CLASS	SDCCsymt.h	/^STORAGE_CLASS;$/;"	t
STRCASECMP	SDCCglobl.h	66;"	d
STRCASECMP	SDCCglobl.h	69;"	d
STRING_LITERAL	SDCCy.c	/^     STRING_LITERAL = 346,$/;"	e	enum:yytokentype	file:
STRING_LITERAL	SDCCy.c	271;"	d	file:
STRING_LITERAL	SDCCy.h	/^     STRING_LITERAL = 346,$/;"	e	enum:yytokentype
STRING_LITERAL	SDCCy.h	247;"	d
STRNCASECMP	SDCCglobl.h	67;"	d
STRNCASECMP	SDCCglobl.h	70;"	d
STRUCT	SDCCy.c	/^     STRUCT = 326,$/;"	e	enum:yytokentype	file:
STRUCT	SDCCy.c	251;"	d	file:
STRUCT	SDCCy.h	/^     STRUCT = 326,$/;"	e	enum:yytokentype
STRUCT	SDCCy.h	227;"	d
STR_BUF_CHUNCK_LEN	SDCClex.c	17343;"	d	file:
SUB_ASSIGN	SDCCy.c	/^     SUB_ASSIGN = 280,$/;"	e	enum:yytokentype	file:
SUB_ASSIGN	SDCCy.c	205;"	d	file:
SUB_ASSIGN	SDCCy.h	/^     SUB_ASSIGN = 280,$/;"	e	enum:yytokentype
SUB_ASSIGN	SDCCy.h	181;"	d
SWAP	SDCCy.c	/^     SWAP = 377,$/;"	e	enum:yytokentype	file:
SWAP	SDCCy.c	302;"	d	file:
SWAP	SDCCy.h	/^     SWAP = 377,$/;"	e	enum:yytokentype
SWAP	SDCCy.h	278;"	d
SWITCH	SDCCy.c	/^     SWITCH = 335,$/;"	e	enum:yytokentype	file:
SWITCH	SDCCy.c	260;"	d	file:
SWITCH	SDCCy.h	/^     SWITCH = 335,$/;"	e	enum:yytokentype
SWITCH	SDCCy.h	236;"	d
SYMBOL	SDCCicode.h	/^  SYMBOL = 1,$/;"	e
SYM_BP	SDCCmem.c	1085;"	d	file:
SYM_LINK_CLASS	SDCCsymt.h	/^} SYM_LINK_CLASS;$/;"	t
SYM_SPIL_LOC	SDCCicode.h	71;"	d
S_AUTO	SDCCsymt.h	/^  S_AUTO,$/;"	e
S_BIT	SDCCsymt.h	/^  S_BIT,$/;"	e
S_CODE	SDCCsymt.h	/^  S_CODE,$/;"	e
S_DATA	SDCCsymt.h	/^  S_DATA,$/;"	e
S_EEPROM	SDCCsymt.h	/^  S_EEPROM$/;"	e
S_FIXED	SDCCsymt.h	/^  S_FIXED = 0,$/;"	e
S_IDATA	SDCCsymt.h	/^  S_IDATA,$/;"	e
S_LITERAL	SDCCsymt.h	/^  S_LITERAL,$/;"	e
S_PDATA	SDCCsymt.h	/^  S_PDATA,$/;"	e
S_REGISTER	SDCCsymt.h	/^  S_REGISTER,$/;"	e
S_SBIT	SDCCsymt.h	/^  S_SBIT,$/;"	e
S_SFR	SDCCsymt.h	/^  S_SFR,$/;"	e
S_STACK	SDCCsymt.h	/^  S_STACK,$/;"	e
S_SYNTAX_ERROR	SDCCerr.h	/^  S_SYNTAX_ERROR                = 213, \/* syntax error *\/$/;"	e
S_XDATA	SDCCsymt.h	/^  S_XDATA,$/;"	e
S_XSTACK	SDCCsymt.h	/^  S_XSTACK,$/;"	e
SetErrorOut	SDCCerr.c	/^SetErrorOut (FILE *NewErrorOut)$/;"	f
StructTab	SDCCsymt.c	/^bucket *StructTab[256];         \/* the structure table  *\/$/;"	v
SymbolTab	SDCCsymt.c	/^bucket *SymbolTab[256];         \/* the symbol    table  *\/$/;"	v
TARGET_HC08_LIKE	port.h	49;"	d
TARGET_ID_AVR	port.h	16;"	d
TARGET_ID_DS390	port.h	17;"	d
TARGET_ID_DS400	port.h	21;"	d
TARGET_ID_GBZ80	port.h	14;"	d
TARGET_ID_HC08	port.h	22;"	d
TARGET_ID_MCS51	port.h	13;"	d
TARGET_ID_PIC14	port.h	18;"	d
TARGET_ID_PIC16	port.h	19;"	d
TARGET_ID_R2K	port.h	24;"	d
TARGET_ID_R3KA	port.h	25;"	d
TARGET_ID_S08	port.h	26;"	d
TARGET_ID_XA51	port.h	20;"	d
TARGET_ID_Z180	port.h	23;"	d
TARGET_ID_Z80	port.h	15;"	d
TARGET_IS_AVR	port.h	32;"	d
TARGET_IS_DS390	port.h	33;"	d
TARGET_IS_DS400	port.h	34;"	d
TARGET_IS_GBZ80	port.h	42;"	d
TARGET_IS_HC08	port.h	43;"	d
TARGET_IS_MCS51	port.h	31;"	d
TARGET_IS_PIC14	port.h	35;"	d
TARGET_IS_PIC16	port.h	36;"	d
TARGET_IS_R2K	port.h	40;"	d
TARGET_IS_R3KA	port.h	41;"	d
TARGET_IS_RABBIT	port.h	48;"	d
TARGET_IS_S08	port.h	44;"	d
TARGET_IS_XA51	port.h	37;"	d
TARGET_IS_Z180	port.h	39;"	d
TARGET_IS_Z80	port.h	38;"	d
TARGET_MCS51_LIKE	port.h	46;"	d
TARGET_PIC_LIKE	port.h	50;"	d
TARGET_Z80_LIKE	port.h	47;"	d
TEST	altlex.c	914;"	d	file:
TETYPE	SDCCast.c	53;"	d	file:
THROWS	SDCCglobl.h	134;"	d
THROWS	SDCCset.h	31;"	d
THROW_BOTH	SDCCglobl.h	138;"	d
THROW_BOTH	SDCCset.h	35;"	d
THROW_DEST	SDCCglobl.h	137;"	d
THROW_DEST	SDCCset.h	34;"	d
THROW_NONE	SDCCglobl.h	135;"	d
THROW_NONE	SDCCset.h	32;"	d
THROW_SRC	SDCCglobl.h	136;"	d
THROW_SRC	SDCCset.h	33;"	d
TKEYWORD	SDCClex.c	15370;"	d	file:
TKEYWORD99	SDCClex.c	15373;"	d	file:
TLVAL	SDCCast.c	47;"	d	file:
TOKEN_EOL	SDCCutil.h	/^{ TOKEN_UNKNOWN, TOKEN_STR, TOKEN_INT, TOKEN_EOL };$/;"	e	enum:pragma_token_e
TOKEN_INT	SDCCutil.h	/^{ TOKEN_UNKNOWN, TOKEN_STR, TOKEN_INT, TOKEN_EOL };$/;"	e	enum:pragma_token_e
TOKEN_STR	SDCCutil.h	/^{ TOKEN_UNKNOWN, TOKEN_STR, TOKEN_INT, TOKEN_EOL };$/;"	e	enum:pragma_token_e
TOKEN_UNKNOWN	SDCCutil.h	/^{ TOKEN_UNKNOWN, TOKEN_STR, TOKEN_INT, TOKEN_EOL };$/;"	e	enum:pragma_token_e
TRUE	SDCCglobl.h	33;"	d
TRUE	SDCCglobl.h	41;"	d
TRUE	SDCCglobl.h	49;"	d
TRUE	SDCCsystem.c	29;"	d	file:
TRUE	SDCCutil.c	31;"	d	file:
TRVAL	SDCCast.c	44;"	d	file:
TTYPE	SDCCast.c	52;"	d	file:
TYPE	SDCCicode.h	/^  TYPE$/;"	e
TYPEDEF	SDCCy.c	/^     TYPEDEF = 286,$/;"	e	enum:yytokentype	file:
TYPEDEF	SDCCy.c	211;"	d	file:
TYPEDEF	SDCCy.h	/^     TYPEDEF = 286,$/;"	e	enum:yytokentype
TYPEDEF	SDCCy.h	187;"	d
TYPEOF	SDCCy.c	/^     TYPEOF = 263,$/;"	e	enum:yytokentype	file:
TYPEOF	SDCCy.c	188;"	d	file:
TYPEOF	SDCCy.h	/^     TYPEOF = 263,$/;"	e	enum:yytokentype
TYPEOF	SDCCy.h	164;"	d
TYPEOF_ARRAY	SDCCsymt.h	/^  TYPEOF_ARRAY,$/;"	e
TYPEOF_BIT	SDCCsymt.h	/^  TYPEOF_BIT,$/;"	e
TYPEOF_BITFIELD	SDCCsymt.h	/^  TYPEOF_BITFIELD,$/;"	e
TYPEOF_BOOL	SDCCsymt.h	/^  TYPEOF_BOOL,$/;"	e
TYPEOF_CHAR	SDCCsymt.h	/^  TYPEOF_CHAR,$/;"	e
TYPEOF_CPOINTER	SDCCsymt.h	/^  TYPEOF_CPOINTER,$/;"	e
TYPEOF_EEPPOINTER	SDCCsymt.h	/^  TYPEOF_EEPPOINTER$/;"	e
TYPEOF_FIXED16X16	SDCCsymt.h	/^  TYPEOF_FIXED16X16,$/;"	e
TYPEOF_FLOAT	SDCCsymt.h	/^  TYPEOF_FLOAT,$/;"	e
TYPEOF_FPOINTER	SDCCsymt.h	/^  TYPEOF_FPOINTER,$/;"	e
TYPEOF_FUNCTION	SDCCsymt.h	/^  TYPEOF_FUNCTION,$/;"	e
TYPEOF_GPOINTER	SDCCsymt.h	/^  TYPEOF_GPOINTER,$/;"	e
TYPEOF_INT	SDCCsymt.h	/^  TYPEOF_INT = 1,$/;"	e
TYPEOF_IPOINTER	SDCCsymt.h	/^  TYPEOF_IPOINTER,$/;"	e
TYPEOF_LONG	SDCCsymt.h	/^  TYPEOF_LONG,$/;"	e
TYPEOF_LONGLONG	SDCCsymt.h	/^  TYPEOF_LONGLONG,$/;"	e
TYPEOF_POINTER	SDCCsymt.h	/^  TYPEOF_POINTER,$/;"	e
TYPEOF_PPOINTER	SDCCsymt.h	/^  TYPEOF_PPOINTER,$/;"	e
TYPEOF_SBIT	SDCCsymt.h	/^  TYPEOF_SBIT,$/;"	e
TYPEOF_SFR	SDCCsymt.h	/^  TYPEOF_SFR,$/;"	e
TYPEOF_SHORT	SDCCsymt.h	/^  TYPEOF_SHORT,$/;"	e
TYPEOF_STRUCT	SDCCsymt.h	/^  TYPEOF_STRUCT,$/;"	e
TYPEOF_VOID	SDCCsymt.h	/^  TYPEOF_VOID,$/;"	e
TYPE_NAME	SDCCy.c	/^     TYPE_NAME = 259,$/;"	e	enum:yytokentype	file:
TYPE_NAME	SDCCy.c	184;"	d	file:
TYPE_NAME	SDCCy.h	/^     TYPE_NAME = 259,$/;"	e	enum:yytokentype
TYPE_NAME	SDCCy.h	160;"	d
TYPE_TARGET_CHAR	SDCCsymt.h	147;"	d
TYPE_TARGET_INT	SDCCsymt.h	148;"	d
TYPE_TARGET_LONG	SDCCsymt.h	149;"	d
TYPE_TARGET_LONGLONG	SDCCsymt.h	153;"	d
TYPE_TARGET_UCHAR	SDCCsymt.h	150;"	d
TYPE_TARGET_UINT	SDCCsymt.h	151;"	d
TYPE_TARGET_ULONG	SDCCsymt.h	152;"	d
TYPE_TARGET_ULONGLONG	SDCCsymt.h	154;"	d
TypedefTab	SDCCsymt.c	/^bucket *TypedefTab[256];        \/* the typedef   table  *\/$/;"	v
UCHARTYPE	SDCCsymt.h	607;"	d
UINTTYPE	SDCCsymt.h	609;"	d
ULONGLONGTYPE	SDCCsymt.h	613;"	d
ULONGTYPE	SDCCsymt.h	611;"	d
UNARYMINUS	SDCCy.c	/^     UNARYMINUS = 358,$/;"	e	enum:yytokentype	file:
UNARYMINUS	SDCCy.c	283;"	d	file:
UNARYMINUS	SDCCy.h	/^     UNARYMINUS = 358,$/;"	e	enum:yytokentype
UNARYMINUS	SDCCy.h	259;"	d
UNGETC	altlex.c	111;"	d	file:
UNION	SDCCy.c	/^     UNION = 327,$/;"	e	enum:yytokentype	file:
UNION	SDCCy.c	252;"	d	file:
UNION	SDCCy.h	/^     UNION = 327,$/;"	e	enum:yytokentype
UNION	SDCCy.h	228;"	d
UNIX_DIR_SEPARATOR_CHAR	SDCCglobl.h	63;"	d
UNSIGNED	SDCCy.c	/^     UNSIGNED = 318,$/;"	e	enum:yytokentype	file:
UNSIGNED	SDCCy.c	243;"	d	file:
UNSIGNED	SDCCy.h	/^     UNSIGNED = 318,$/;"	e	enum:yytokentype
UNSIGNED	SDCCy.h	219;"	d
UNSPIL	SDCCy.c	/^     UNSPIL = 352,$/;"	e	enum:yytokentype	file:
UNSPIL	SDCCy.c	277;"	d	file:
UNSPIL	SDCCy.h	/^     UNSPIL = 352,$/;"	e	enum:yytokentype
UNSPIL	SDCCy.h	253;"	d
UNSUPPORTEDOPT	SDCCmain.c	/^} UNSUPPORTEDOPT;$/;"	t	file:
UPOINTER	SDCCsymt.h	/^  UPOINTER,                         \/* unknown pointer used only when parsing *\/$/;"	e
USE_STDOUT_FOR_ERRORS	SDCCerr.c	26;"	d	file:
USING	SDCCy.c	/^     USING = 301,$/;"	e	enum:yytokentype	file:
USING	SDCCy.c	226;"	d	file:
USING	SDCCy.h	/^     USING = 301,$/;"	e	enum:yytokentype
USING	SDCCy.h	202;"	d
VALUE	SDCCicode.h	/^  VALUE,$/;"	e
VAR_ARGS	SDCCy.c	/^     VAR_ARGS = 306,$/;"	e	enum:yytokentype	file:
VAR_ARGS	SDCCy.c	231;"	d	file:
VAR_ARGS	SDCCy.h	/^     VAR_ARGS = 306,$/;"	e	enum:yytokentype
VAR_ARGS	SDCCy.h	207;"	d
VOLATILE	SDCCy.c	/^     VOLATILE = 323,$/;"	e	enum:yytokentype	file:
VOLATILE	SDCCy.c	248;"	d	file:
VOLATILE	SDCCy.h	/^     VOLATILE = 323,$/;"	e	enum:yytokentype
VOLATILE	SDCCy.h	224;"	d
V_ARG	SDCCset.h	48;"	d
V_BBITFIELD	SDCCsymt.h	/^  V_BBITFIELD,$/;"	e
V_BIT	SDCCsymt.h	/^  V_BIT,$/;"	e
V_BITFIELD	SDCCsymt.h	/^  V_BITFIELD,$/;"	e
V_BOOL	SDCCsymt.h	/^  V_BOOL,$/;"	e
V_CHAR	SDCCsymt.h	/^  V_CHAR,$/;"	e
V_DOUBLE	SDCCsymt.h	/^  V_DOUBLE$/;"	e
V_FIXED16X16	SDCCsymt.h	/^  V_FIXED16X16,$/;"	e
V_FLOAT	SDCCsymt.h	/^  V_FLOAT,$/;"	e
V_INT	SDCCsymt.h	/^  V_INT = 1,$/;"	e
V_LABEL	SDCCsymt.h	/^  V_LABEL,$/;"	e
V_SBIT	SDCCsymt.h	/^  V_SBIT,$/;"	e
V_STRUCT	SDCCsymt.h	/^  V_STRUCT,$/;"	e
V_VOID	SDCCsymt.h	/^  V_VOID,$/;"	e
WHILE	SDCCy.c	/^     WHILE = 336,$/;"	e	enum:yytokentype	file:
WHILE	SDCCy.c	261;"	d	file:
WHILE	SDCCy.h	/^     WHILE = 336,$/;"	e	enum:yytokentype
WHILE	SDCCy.h	237;"	d
WRITE_SEG_LOC	SDCCmain.c	1591;"	d	file:
W_BAD_COMPARE	SDCCerr.h	/^  W_BAD_COMPARE                 =  82, \/* bad comparison      *\/$/;"	e
W_BAD_PRAGMA_ARGUMENTS	SDCCerr.h	/^  W_BAD_PRAGMA_ARGUMENTS        = 191, \/* #pragma %s: bad argument(s); pragma ignored *\/$/;"	e
W_BANKED_WITH_NONBANKED	SDCCerr.h	/^  W_BANKED_WITH_NONBANKED       = 134, \/* banked and nonbanked attributes mixed *\/$/;"	e
W_BANKED_WITH_STATIC	SDCCerr.h	/^  W_BANKED_WITH_STATIC          = 135, \/* banked and static mixed *\/$/;"	e
W_BITFLD_NAMED	SDCCerr.h	/^  W_BITFLD_NAMED                = 168, \/* declarator used with 0 length bit-field *\/$/;"	e
W_C89_NO_FLEXARRAY	SDCCerr.h	/^  W_C89_NO_FLEXARRAY            = 187, \/* ISO C90 does not support flexible array members *\/$/;"	e
W_CAST_STRUCT_PTR	SDCCerr.h	/^  W_CAST_STRUCT_PTR             = 157, \/* pointer to different structure types *\/$/;"	e
W_CMP_SU_CHAR	SDCCerr.h	/^  W_CMP_SU_CHAR                 = 185, \/* comparison of 'signed char' with 'unsigned char' requires promotion to int *\/$/;"	e
W_CODE_UNREACH	SDCCerr.h	/^  W_CODE_UNREACH                = 126, \/* unreachable code    *\/$/;"	e
W_COMPLEMENT	SDCCerr.h	/^  W_COMPLEMENT                  = 180, \/* ~bit can give unexpected results *\/$/;"	e
W_COMP_RANGE	SDCCerr.h	/^  W_COMP_RANGE                  =  94, \/* comparison is always %s due to limited range of data type *\/$/;"	e
W_CONST_RANGE	SDCCerr.h	/^  W_CONST_RANGE                 = 125, \/* constant too large  *\/$/;"	e
W_CONST_TOO_LARGE	SDCCerr.h	/^  W_CONST_TOO_LARGE             =  81, \/* constant out of range *\/$/;"	e
W_CONTINUE	SDCCerr.h	/^  W_CONTINUE                    = 113, \/* more than one line  *\/$/;"	e
W_CONTROL_FLOW	SDCCerr.h	/^  W_CONTROL_FLOW                = 110, \/* control flow changed due to optimization *\/$/;"	e
W_DEPRECATED_KEYWORD	SDCCerr.h	/^  W_DEPRECATED_KEYWORD          = 197, \/* keyword '%s' is deprecated, use '%s' instead *\/$/;"	e
W_DEPRECATED_OPTION	SDCCerr.h	/^  W_DEPRECATED_OPTION           = 201, \/* deprecated compiler option '%s' *\/$/;"	e
W_DEPRECATED_PRAGMA	SDCCerr.h	/^  W_DEPRECATED_PRAGMA           = 175, \/* deprecated pragma *\/$/;"	e
W_DOUBLE_UNSUPPORTED	SDCCerr.h	/^  W_DOUBLE_UNSUPPORTED          =  93, \/* 'double' not supported yet *\/$/;"	e
W_DUPLICATE_INIT	SDCCerr.h	/^  W_DUPLICATE_INIT              = 203, \/* duplicate initializer *\/$/;"	e
W_EMPTY_SOURCE_FILE	SDCCerr.h	/^  W_EMPTY_SOURCE_FILE           = 190, \/* ISO C forbids an empty source file *\/$/;"	e
W_ESC_SEQ_OOR_FOR_CHAR	SDCCerr.h	/^  W_ESC_SEQ_OOR_FOR_CHAR        = 137, \/* Escape sequence of of range for char *\/$/;"	e
W_EXCESS_INITIALIZERS	SDCCerr.h	/^  W_EXCESS_INITIALIZERS         = 147, \/* too much initializers for array *\/$/;"	e
W_EXCESS_SHORT_OPTIONS	SDCCerr.h	/^  W_EXCESS_SHORT_OPTIONS        = 152, \/* Only one short option can be specified at a time.  Rest of %s ignored. *\/$/;"	e
W_FUNCPTR_IN_USING_ISR	SDCCerr.h	/^  W_FUNCPTR_IN_USING_ISR        = 139, \/* Call via function pointer in ISR with using attribute. *\/$/;"	e
W_FUNC_NO_RETURN	SDCCerr.h	/^  W_FUNC_NO_RETURN              =  95, \/* no return statement found *\/$/;"	e
W_FUNC_TOO_LARGE	SDCCerr.h	/^  W_FUNC_TOO_LARGE              = 109, \/* function too large  *\/$/;"	e
W_IDX_OUT_OF_BOUNDS	SDCCerr.h	/^  W_IDX_OUT_OF_BOUNDS           =  24, \/* array index out of bounds *\/$/;"	e
W_ILLEGAL_OPT_COMBINATION	SDCCerr.h	/^  W_ILLEGAL_OPT_COMBINATION     = 162, \/* illegal combination of options (--c1mode, -E, -S -c) *\/$/;"	e
W_IMPLICIT_FUNC	SDCCerr.h	/^  W_IMPLICIT_FUNC               = 112, \/* function declared implicitly *\/$/;"	e
W_INDIR_BANKED	SDCCerr.h	/^  W_INDIR_BANKED                = 132, \/* Indirect call to a banked fun *\/$/;"	e
W_INIT_IGNORED	SDCCerr.h	/^  W_INIT_IGNORED                =  15, \/* initialiser ignored  *\/$/;"	e
W_INIT_WRONG	SDCCerr.h	/^  W_INIT_WRONG                  =  18, \/* initializer type !=  *\/$/;"	e
W_INTEGRAL2PTR_NOCAST	SDCCerr.h	/^  W_INTEGRAL2PTR_NOCAST         = 154, \/* converting integral to pointer without a cast *\/$/;"	e
W_INT_OVL	SDCCerr.h	/^  W_INT_OVL                     = 165, \/* integer overflow in expression *\/$/;"	e
W_INT_TO_GEN_PTR_CAST	SDCCerr.h	/^  W_INT_TO_GEN_PTR_CAST         = 136, \/* Converting integer type to generic pointer. *\/$/;"	e
W_INVALID_FLEXARRAY	SDCCerr.h	/^  W_INVALID_FLEXARRAY           = 186, \/* invalid use of structure with flexible array member *\/$/;"	e
W_INVALID_INT_CONST	SDCCerr.h	/^  W_INVALID_INT_CONST           = 184, \/* invalid integer literal string *\/$/;"	e
W_LITERAL_GENERIC	SDCCerr.h	/^  W_LITERAL_GENERIC             =  88, \/* literal being cast to generic pointer *\/$/;"	e
W_LIT_OVERFLOW	SDCCerr.h	/^  W_LIT_OVERFLOW                = 158, \/* overflow in implicit constant conversion *\/$/;"	e
W_LOCAL_NOINIT	SDCCerr.h	/^  W_LOCAL_NOINIT                =  84, \/* local reference before assignment *\/$/;"	e
W_LONGLONG_LITERAL	SDCCerr.h	/^  W_LONGLONG_LITERAL            = 212, \/* long long literal *\/$/;"	e
W_LONG_UNSUPPORTED	SDCCerr.h	/^  W_LONG_UNSUPPORTED            =  87, \/* 'long' not supported yet *\/$/;"	e
W_LOOP_ELIMINATE	SDCCerr.h	/^  W_LOOP_ELIMINATE              =  79, \/* loop eliminated     *\/$/;"	e
W_NEWLINE_IN_STRING	SDCCerr.h	/^  W_NEWLINE_IN_STRING           = 150, \/* newline in string constant *\/$/;"	e
W_NONPTR2_GENPTR	SDCCerr.h	/^  W_NONPTR2_GENPTR              = 127, \/* non pointer cast to generic pointer *\/$/;"	e
W_NORETURNRETURN	SDCCerr.h	/^  W_NORETURNRETURN              = 209, \/* return in _noreturn function *\/$/;"	e
W_NO_FILE_ARG_IN_C1	SDCCerr.h	/^  W_NO_FILE_ARG_IN_C1           = 160, \/* only standard input is compiled in c1 mode. file '%s' ignored *\/$/;"	e
W_NO_REFERENCE	SDCCerr.h	/^  W_NO_REFERENCE                =  85, \/* no reference to local variable *\/$/;"	e
W_NO_SIDE_EFFECTS	SDCCerr.h	/^  W_NO_SIDE_EFFECTS             =  80, \/* expression has no side effects *\/$/;"	e
W_POSSBUG	SDCCerr.h	/^  W_POSSBUG                     = 128, \/* possible code generation error *\/$/;"	e
W_POSSBUG2	SDCCerr.h	/^  W_POSSBUG2                    = 179, \/* possible bug, new format *\/$/;"	e
W_PRE_PROC_WARNING	SDCCerr.h	/^  W_PRE_PROC_WARNING            =  96, \/* preprocessor generated warning *\/$/;"	e
W_PTR2INTEGRAL_NOCAST	SDCCerr.h	/^  W_PTR2INTEGRAL_NOCAST         = 155, \/* converting pointer to integral without a cast *\/$/;"	e
W_PTR_TYPE_INVALID	SDCCerr.h	/^  W_PTR_TYPE_INVALID            = 111, \/* invalid type specifier for pointer *\/$/;"	e
W_RETURN_MISMATCH	SDCCerr.h	/^  W_RETURN_MISMATCH             =  60, \/* return value mismatch *\/$/;"	e
W_SAVE_RESTORE	SDCCerr.h	/^  W_SAVE_RESTORE                = 170, \/* unmatched #pragma SAVE and #pragma RESTORE *\/$/;"	e
W_SFR_ABSRANGE	SDCCerr.h	/^  W_SFR_ABSRANGE                = 182, \/* sfr at address out of range *\/$/;"	e
W_SHIFT_CHANGED	SDCCerr.h	/^  W_SHIFT_CHANGED               = 116, \/* shift changed to zero *\/$/;"	e
W_SIZEOF_VOID	SDCCerr.h	/^  W_SIZEOF_VOID                 = 178, \/* size of void is zero *\/$/;"	e
W_STACK_OVERFLOW	SDCCerr.h	/^  W_STACK_OVERFLOW              =  21, \/* stack overflow       *\/$/;"	e
W_STRAY_BACKSLASH	SDCCerr.h	/^  W_STRAY_BACKSLASH             = 149, \/* stray '\\\\' at column %d" *\/$/;"	e
W_STRING_CANNOT_BE_TERMINATED	SDCCerr.h	/^  W_STRING_CANNOT_BE_TERMINATED = 211, \/* string cannot be terminated within array *\/$/;"	e
W_SYMBOL_NAME_TOO_LONG	SDCCerr.h	/^  W_SYMBOL_NAME_TOO_LONG        = 156, \/* symbol name too long, truncated to %d chars *\/$/;"	e
W_TARGET_LOST_QUALIFIER	SDCCerr.h	/^  W_TARGET_LOST_QUALIFIER       = 196, \/* Pointer target lost qualifier *\/$/;"	e
W_TOO_MANY_SRC	SDCCerr.h	/^  W_TOO_MANY_SRC                = 120, \/* can only compile one .c file at a time *\/$/;"	e
W_TRUNCATION	SDCCerr.h	/^  W_TRUNCATION                  =  32, \/* high order trucation *\/$/;"	e
W_UNIVERSAL_C99	SDCCerr.h	/^  W_UNIVERSAL_C99               = 205, \/* universal character names are only valid in C99 *\/$/;"	e
W_UNKNOWN_FEXT	SDCCerr.h	/^  W_UNKNOWN_FEXT                = 119, \/* unknown file extension *\/$/;"	e
W_UNKNOWN_MODEL	SDCCerr.h	/^  W_UNKNOWN_MODEL               = 130, \/* Unknown memory model *\/$/;"	e
W_UNKNOWN_OPTION	SDCCerr.h	/^  W_UNKNOWN_OPTION              = 117, \/* don't know the option *\/$/;"	e
W_UNKNOWN_PRAGMA	SDCCerr.h	/^  W_UNKNOWN_PRAGMA              = 115, \/* #pragma directive unsupported *\/$/;"	e
W_UNSUPPORTED_MODEL	SDCCerr.h	/^  W_UNSUPPORTED_MODEL           = 133, \/* Unsupported model, ignored *\/$/;"	e
W_UNSUPP_OPTION	SDCCerr.h	/^  W_UNSUPP_OPTION               = 118, \/* processor reset has been redifned *\/$/;"	e
W_USELESS_DECL	SDCCerr.h	/^  W_USELESS_DECL                = 166, \/* useless declaration *\/$/;"	e
W_USING_GENERIC_POINTER	SDCCerr.h	/^  W_USING_GENERIC_POINTER       = 151, \/* using generic pointer %s to initialize %s *\/$/;"	e
W_VOID_FUNC	SDCCerr.h	/^  W_VOID_FUNC                   =  59, \/* func must return value *\/$/;"	e
XABS_NAME	SDCCmem.h	61;"	d
XDATA	SDCCy.c	/^     XDATA = 302,$/;"	e	enum:yytokentype	file:
XDATA	SDCCy.c	227;"	d	file:
XDATA	SDCCy.h	/^     XDATA = 302,$/;"	e	enum:yytokentype
XDATA	SDCCy.h	203;"	d
XDATA_NAME	SDCCmem.h	51;"	d
XIDATA_NAME	SDCCmem.h	52;"	d
XINIT_NAME	SDCCmem.h	53;"	d
XOR_ASSIGN	SDCCy.c	/^     XOR_ASSIGN = 284,$/;"	e	enum:yytokentype	file:
XOR_ASSIGN	SDCCy.c	209;"	d	file:
XOR_ASSIGN	SDCCy.h	/^     XOR_ASSIGN = 284,$/;"	e	enum:yytokentype
XOR_ASSIGN	SDCCy.h	185;"	d
XSTACK_NAME	SDCCmem.h	45;"	d
YYABORT	SDCCy.c	1448;"	d	file:
YYACCEPT	SDCCy.c	1447;"	d	file:
YYBACKUP	SDCCy.c	1460;"	d	file:
YYBISON	SDCCy.c	37;"	d	file:
YYCOPY	SDCCy.c	464;"	d	file:
YYCOPY	SDCCy.c	467;"	d	file:
YYDEBUG	SDCCy.c	355;"	d	file:
YYDEBUG	SDCCy.c	361;"	d	file:
YYDPRINTF	SDCCy.c	1507;"	d	file:
YYDPRINTF	SDCCy.c	1591;"	d	file:
YYDSYMPRINT	SDCCy.c	1513;"	d	file:
YYDSYMPRINT	SDCCy.c	1592;"	d	file:
YYDSYMPRINTF	SDCCy.c	1519;"	d	file:
YYDSYMPRINTF	SDCCy.c	1593;"	d	file:
YYEMPTY	SDCCy.c	1444;"	d	file:
YYEOF	SDCCy.c	1445;"	d	file:
YYERRCODE	SDCCy.c	1478;"	d	file:
YYERROR	SDCCy.c	1449;"	d	file:
YYERROR_VERBOSE	SDCCy.c	366;"	d	file:
YYERROR_VERBOSE	SDCCy.c	367;"	d	file:
YYERROR_VERBOSE	SDCCy.c	369;"	d	file:
YYFAIL	SDCCy.c	1456;"	d	file:
YYFINAL	SDCCy.c	503;"	d	file:
YYFPRINTF	SDCCy.c	1504;"	d	file:
YYFREE	SDCCy.c	404;"	d	file:
YYINITDEPTH	SDCCy.c	1601;"	d	file:
YYLAST	SDCCy.c	505;"	d	file:
YYLEX	SDCCy.c	1494;"	d	file:
YYLEX	SDCCy.c	1496;"	d	file:
YYLLOC_DEFAULT	SDCCy.c	1484;"	d	file:
YYLSP_NEEDED	SDCCy.c	46;"	d	file:
YYMALLOC	SDCCy.c	407;"	d	file:
YYMAXDEPTH	SDCCy.c	1612;"	d	file:
YYMAXDEPTH	SDCCy.c	1616;"	d	file:
YYMAXUTOK	SDCCy.c	518;"	d	file:
YYNNTS	SDCCy.c	510;"	d	file:
YYNRULES	SDCCy.c	512;"	d	file:
YYNSTATES	SDCCy.c	514;"	d	file:
YYNTOKENS	SDCCy.c	508;"	d	file:
YYPACT_NINF	SDCCy.c	963;"	d	file:
YYPOPSTACK	SDCCy.c	1820;"	d	file:
YYPURE	SDCCy.c	43;"	d	file:
YYRECOVERING	SDCCy.c	1458;"	d	file:
YYSIZE_T	SDCCy.c	1427;"	d	file:
YYSIZE_T	SDCCy.c	1430;"	d	file:
YYSIZE_T	SDCCy.c	1435;"	d	file:
YYSIZE_T	SDCCy.c	1439;"	d	file:
YYSIZE_T	SDCCy.c	432;"	d	file:
YYSKELETON_NAME	SDCCy.c	40;"	d	file:
YYSTACK_ALLOC	SDCCy.c	414;"	d	file:
YYSTACK_ALLOC	SDCCy.c	418;"	d	file:
YYSTACK_ALLOC	SDCCy.c	421;"	d	file:
YYSTACK_ALLOC	SDCCy.c	434;"	d	file:
YYSTACK_BYTES	SDCCy.c	456;"	d	file:
YYSTACK_FREE	SDCCy.c	428;"	d	file:
YYSTACK_FREE	SDCCy.c	435;"	d	file:
YYSTACK_GAP_MAXIMUM	SDCCy.c	452;"	d	file:
YYSTACK_RELOCATE	SDCCy.c	1909;"	d	file:
YYSTACK_RELOCATE	SDCCy.c	483;"	d	file:
YYSTATE	SDCClex.c	86;"	d	file:
YYSTYPE	SDCCy.c	/^typedef union YYSTYPE {$/;"	u	file:
YYSTYPE	SDCCy.c	/^} YYSTYPE;$/;"	t	file:
YYSTYPE	SDCCy.h	/^typedef union YYSTYPE {$/;"	u
YYSTYPE	SDCCy.h	/^} YYSTYPE;$/;"	t
YYSTYPE_IS_DECLARED	SDCCy.c	389;"	d	file:
YYSTYPE_IS_DECLARED	SDCCy.h	305;"	d
YYSTYPE_IS_TRIVIAL	SDCCy.c	390;"	d	file:
YYSTYPE_IS_TRIVIAL	SDCCy.h	306;"	d
YYTABLE_NINF	SDCCy.c	1036;"	d	file:
YYTERROR	SDCCy.c	1477;"	d	file:
YYTOKENTYPE	SDCCy.c	52;"	d	file:
YYTOKENTYPE	SDCCy.h	28;"	d
YYTRANSLATE	SDCCy.c	520;"	d	file:
YYUNDEFTOK	SDCCy.c	517;"	d	file:
YY_AT_BOL	SDCClex.c	262;"	d	file:
YY_BREAK	SDCClex.c	15520;"	d	file:
YY_BUFFER_EOF_PENDING	SDCClex.c	198;"	d	file:
YY_BUFFER_NEW	SDCClex.c	186;"	d	file:
YY_BUFFER_NORMAL	SDCClex.c	187;"	d	file:
YY_BUFFER_STATE	SDCClex.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	file:
YY_BUF_SIZE	SDCClex.c	97;"	d	file:
YY_CHAR	SDCClex.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	SDCClex.c	207;"	d	file:
YY_DECL	SDCClex.c	15508;"	d	file:
YY_DO_BEFORE_ACTION	SDCClex.c	15197;"	d	file:
YY_END_OF_BUFFER	SDCClex.c	15205;"	d	file:
YY_END_OF_BUFFER_CHAR	SDCClex.c	94;"	d	file:
YY_EXIT_FAILURE	SDCClex.c	17104;"	d	file:
YY_FATAL_ERROR	SDCClex.c	15501;"	d	file:
YY_FLEX_MAJOR_VERSION	SDCClex.c	8;"	d	file:
YY_FLEX_MINOR_VERSION	SDCClex.c	9;"	d	file:
YY_FLUSH_BUFFER	SDCClex.c	236;"	d	file:
YY_INPUT	SDCClex.c	15481;"	d	file:
YY_MORE_ADJ	SDCClex.c	15326;"	d	file:
YY_NEW_FILE	SDCClex.c	92;"	d	file:
YY_NO_POP_STATE	SDCClex.c	15444;"	d	file:
YY_NO_PUSH_STATE	SDCClex.c	15443;"	d	file:
YY_NO_TOP_STATE	SDCClex.c	15445;"	d	file:
YY_NULL	SDCClex.c	66;"	d	file:
YY_NUM_RULES	SDCClex.c	15204;"	d	file:
YY_PROTO	SDCClex.c	60;"	d	file:
YY_PROTO	SDCClex.c	62;"	d	file:
YY_READ_BUF_SIZE	SDCClex.c	15465;"	d	file:
YY_REDUCE_PRINT	SDCCy.c	1581;"	d	file:
YY_REDUCE_PRINT	SDCCy.c	1595;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	SDCClex.c	15327;"	d	file:
YY_RULE_SETUP	SDCClex.c	15523;"	d	file:
YY_SC_TO_UI	SDCClex.c	73;"	d	file:
YY_STACK_PRINT	SDCCy.c	1551;"	d	file:
YY_STACK_PRINT	SDCCy.c	1594;"	d	file:
YY_START	SDCClex.c	85;"	d	file:
YY_START_STACK_INCR	SDCClex.c	15496;"	d	file:
YY_STATE_EOF	SDCClex.c	89;"	d	file:
YY_USER_ACTION	SDCClex.c	15515;"	d	file:
YY_USE_CONST	SDCClex.c	31;"	d	file:
YY_USE_CONST	SDCClex.c	38;"	d	file:
YY_USE_CONST	SDCClex.c	48;"	d	file:
YY_USE_PROTOS	SDCClex.c	28;"	d	file:
YY_USE_PROTOS	SDCClex.c	37;"	d	file:
YY_USE_PROTOS	SDCClex.c	49;"	d	file:
ZERO	SDCCglobl.h	113;"	d
_ASM_MAPPINGS	SDCCasm.h	/^struct _ASM_MAPPINGS$/;"	s
_DEBUG_INCLUDE_	SDCCdebug.h	22;"	d
_ERROR_LOG_LEVEL	SDCCerr.h	/^enum _ERROR_LOG_LEVEL {$/;"	g
_G	SDCCpeeph.c	/^} _G;$/;"	v	file:
_G	common.h	31;"	d
_SDCCERRG	SDCCerr.c	/^struct SDCCERRG _SDCCERRG; $/;"	v
__SDCCERR_H	SDCCerr.h	21;"	d
__VERSION_H__	version.h	10;"	d
__cplusplus	SDCClex.c	18;"	d	file:
_a390_mapping	SDCCasm.c	/^static const ASM_MAPPING _a390_mapping[] = {$/;"	v	file:
_addr	SDCCsymt.h	/^  unsigned _addr;                   \/* address of symbol          *\/$/;"	m	struct:specifier
_asxxxx_mapping	SDCCasm.c	/^static const ASM_MAPPING _asxxxx_mapping[] = {$/;"	v	file:
_baseValues	SDCCmain.c	/^static const char *_baseValues[] = {$/;"	v	file:
_bitLength	SDCCsymt.h	/^  int _bitLength;                   \/* bit length                 *\/$/;"	m	struct:specifier
_bitStart	SDCCsymt.h	/^  unsigned _bitStart;               \/* bit start position         *\/$/;"	m	struct:specifier
_compare	SDCChasht.c	/^_compare (const void *s1, const void *s2)$/;"	f	file:
_dumpFiles	SDCCglobl.h	/^struct _dumpFiles {$/;"	s
_findByKey	SDCChasht.c	/^_findByKey (hTab * htab, int key, const void *pkey, int (*compare) (const void *, const void *))$/;"	f	file:
_findItem	SDCChasht.c	/^_findItem (hTab * htab, int key, void *item, int (*compareFunc) (void *, void *))$/;"	f	file:
_findPort	SDCCmain.c	/^_findPort (int argc, char **argv)$/;"	f	file:
_findProcessor	SDCCmain.c	/^_findProcessor (int argc, char **argv)$/;"	f	file:
_gas_mapping	SDCCasm.c	/^static const ASM_MAPPING _gas_mapping[] = {$/;"	v	file:
_h	SDCCasm.c	/^static hTab *_h;$/;"	v	file:
_hash	SDCChasht.c	/^_hash (const char *sz)$/;"	f	file:
_isparm	SDCCsymt.h	/^  unsigned _isparm:1;               \/* is a parameter          *\/$/;"	m	struct:symbol
_mainValues	SDCCutil.c	/^static hTab *_mainValues;$/;"	v	file:
_mangleFunctionName	SDCCsymt.c	/^_mangleFunctionName (const char *in)$/;"	f	file:
_newHashtItem	SDCChasht.c	/^_newHashtItem (int key, void *pkey, void *item)$/;"	f	file:
_ports	SDCCmain.c	/^static PORT *_ports[] = {$/;"	v	file:
_preCmd	SDCCmain.c	/^static const char *_preCmd = "{cpp} -nostdinc -Wall {cppstd}{cppextraopts} \\"{fullsrcfilename}\\" \\"{cppoutfilename}\\"";$/;"	v	file:
_printPointerType	SDCCglue.c	/^_printPointerType (struct dbuf_s *oBuf, const char *name, int size)$/;"	f	file:
_setModel	SDCCmain.c	/^_setModel (int model, const char *sz)$/;"	f	file:
_setPort	SDCCmain.c	/^_setPort (const char *name)$/;"	f	file:
_setProcessor	SDCCmain.c	/^_setProcessor (char *_processor)$/;"	f	file:
_stack	SDCCsymt.h	/^  unsigned _stack;                  \/* stack offset for stacked v *\/$/;"	m	struct:specifier
_validatePorts	SDCCmain.c	/^_validatePorts (void)$/;"	f	file:
_xa_asm_mapping	SDCCasm.c	/^static const ASM_MAPPING _xa_asm_mapping[] = {$/;"	v	file:
_yylex	altlex.c	/^_yylex (void)$/;"	f	file:
abbrev	SDCCdwarf2.h	/^  int abbrev;$/;"	m	struct:dwtag
acall_ajmp	SDCCglobl.h	/^    int acall_ajmp;             \/* MCS51 - Use acall\/ajmp instead of lcall\/ljmp *\/$/;"	m	struct:options
accuse	SDCCsymt.h	/^  unsigned accuse;                  \/* can be left in the accumulator$/;"	m	struct:symbol
addCast	SDCCast.c	/^addCast (ast * tree, RESULT_TYPE resultType, bool promote)$/;"	f	file:
addDecl	SDCCsymt.c	/^addDecl (symbol * sym, int type, sym_link * p)$/;"	f
addLvaluereq	SDCCicode.c	/^addLvaluereq (int lvl)$/;"	f	file:
addPattern1	SDCCptropt.c	/^addPattern1 (iCode * ic)$/;"	f	file:
addPostLoopBlock	SDCCloop.c	/^addPostLoopBlock (region * loopReg, ebbIndex * ebbi, iCode * ic)$/;"	f	file:
addSet	SDCCset.c	/^addSet (set ** list, void *item)$/;"	f
addSetHead	SDCCset.c	/^addSetHead (set ** list, void *item)$/;"	f
addSetIfnotP	SDCCset.c	/^addSetIfnotP (set ** list, void *item)$/;"	f
addSuccessor	SDCCcflow.c	/^addSuccessor (eBBlock * thisBlock, eBBlock * succ)$/;"	f	file:
addSym	SDCCsymt.c	/^addSym (bucket ** stab, void *sym, char *sname, int level, int block, int checkType)$/;"	f
addSymChain	SDCCsymt.c	/^addSymChain (symbol ** symHead)$/;"	f
addSymToBlock	SDCCast.c	/^addSymToBlock (symbol * sym, ast * tree)$/;"	f
add_line_node	SDCCgen.c	/^add_line_node (const char *line)$/;"	f	file:
addiCodeToeBBlock	SDCCBBlock.c	/^addiCodeToeBBlock (eBBlock * ebp, iCode * ic, iCode * ip)$/;"	f
addrOf	SDCCBBlock.h	/^  set *addrOf;                  \/* symbols for which addres has been taken in the block *\/$/;"	m	struct:eBBlock
addressSize	port.h	/^      int addressSize;$/;"	m
addressTaken	SDCCloop.c	/^addressTaken (set * sset, operand * sym)$/;"	f	file:
addressmod	SDCCsymt.h	/^  struct symbol *addressmod[2];     \/* access functions for named address spaces *\/$/;"	m	struct:symbol
addrspace	SDCCsymt.h	/^  struct symbol *addrspace;         \/* is in named address space  *\/$/;"	m	struct:specifier
addrtaken	SDCCsymt.h	/^  unsigned addrtaken:1;             \/* address of the symbol was taken *\/$/;"	m	struct:symbol
adjustIChain	SDCClrange.c	/^adjustIChain (eBBlock ** ebbs, int count)$/;"	f
aggr2ptr	SDCCicode.h	/^  unsigned int aggr2ptr:2;          \/* 1: must change aggregate to pointer to aggregate *\/$/;"	m	struct:operand
aggrToPtr	SDCCicode.c	/^aggrToPtr (sym_link * type, bool force)$/;"	f
aggrToPtrDclType	SDCCicode.c	/^aggrToPtrDclType (sym_link * type, bool force)$/;"	f
aggregateToPointer	SDCCsymt.c	/^aggregateToPointer (value * val)$/;"	f
algebraicOpts	SDCCcse.c	/^algebraicOpts (iCode * ic, eBBlock * ebp)$/;"	f	file:
allDefsOutOfRange	SDCClrange.c	/^allDefsOutOfRange (bitVect * defs, int fseq, int toseq)$/;"	f
all_callee_saves	SDCCglobl.h	/^    int all_callee_saves;       \/* callee saves for all functions *\/$/;"	m	struct:options
allocDefault	SDCCmem.c	/^allocDefault (struct symbol * sym)$/;"	f
allocGlobal	SDCCmem.c	/^allocGlobal (symbol * sym)$/;"	f
allocInfo	SDCCglue.c	/^int allocInfo = 1;$/;"	v
allocIntoSeg	SDCCmem.c	/^allocIntoSeg (symbol *sym)$/;"	f
allocLocal	SDCCmem.c	/^allocLocal (symbol * sym)$/;"	f
allocMap	SDCCmem.c	/^allocMap (char rspace,          \/* sfr space                   *\/$/;"	f
allocParms	SDCCmem.c	/^allocParms (value * val)$/;"	f
allocVariables	SDCCmem.c	/^allocVariables (symbol * symChain)$/;"	f
allocreq	SDCCsymt.h	/^  int allocreq;                     \/* allocation is required for this variable *\/$/;"	m	struct:symbol
aln	SDCCgen.h	/^  asmLineNodeBase *aln;$/;"	m	struct:lineElem_s
altlex_runtests	altlex.c	/^altlex_runtests (void)$/;"	f
altlex_testchar	altlex.c	/^altlex_testchar (const char *input)$/;"	f
altlex_testnum	altlex.c	/^altlex_testnum (const char *input)$/;"	f
altlex_testparse	altlex.c	/^altlex_testparse (const char *input)$/;"	f
ancestors	SDCCcse.h	/^    bitVect *ancestors;		\/* keys of the symbol's ancestors *\/$/;"	m	struct:cseDef
aop	SDCCicode.h	/^  struct asmop *aop;                \/* asm op for this operand *\/$/;"	m	struct:operand
aop	SDCCsymt.h	/^  struct asmop *aop;                \/* asmoperand for this symbol *\/$/;"	m	struct:symbol
aopLiteral	SDCCglue.c	/^aopLiteral (value * val, int offset)$/;"	f
aopLiteralGptr	SDCCglue.c	/^aopLiteralGptr (const char * name, value * val)$/;"	f
aopLiteralLong	SDCCglue.c	/^aopLiteralLong (value * val, int offset, int size)$/;"	f
appendStrSet	SDCCutil.c	/^appendStrSet (set * list, const char *pre, const char *post)$/;"	f
applyToSet	SDCCset.c	/^applyToSet (set * list, int (*somefunc) (void *, va_list),...)$/;"	f
applyToSetFTrue	SDCCset.c	/^applyToSetFTrue (set * list, int (*somefunc) (void *, va_list),...)$/;"	f
arg_type	SDCCargs.h	/^    enum cl_opt_arg_type arg_type;$/;"	m
argreg	SDCCast.h	/^    int argreg;                 \/* argreg number when operand type == EX_OPERAND *\/$/;"	m	union:ast::<anonymous>
argreg	SDCCicode.h	/^  int argreg;                   \/* argument regno for SEND\/RECEIVE *\/$/;"	m	struct:iCode
argreg	SDCCsymt.h	/^  int argreg;                       \/* reg no for regparm         *\/$/;"	m	struct:specifier
args	SDCCast.h	/^    value *args;                \/* if function then args    *\/$/;"	m	union:ast::<anonymous>
args	SDCCsymt.h	/^    struct value *args;             \/* the defined arguments                *\/$/;"	m	struct:sym_link::<anonymous>
arrayInitList	SDCCicode.h	/^  literalList *arrayInitList;   \/* point to array initializer list. *\/$/;"	m	struct:iCode
arrayInitializerSuppported	port.h	/^  bool arrayInitializerSuppported;$/;"	m
asm	SDCClex.c	15393;"	d	file:
asmLineNodeBase	SDCCgen.h	/^asmLineNodeBase;$/;"	t
asmLineNodeBase	SDCCgen.h	/^typedef struct asmLineNodeBase$/;"	s
asmOptionsSet	SDCCmain.c	/^set *asmOptionsSet = NULL;      \/* set of assembler options *\/$/;"	v
asm_a390_mapping	SDCCasm.c	/^const ASM_MAPPINGS asm_a390_mapping = {$/;"	v
asm_addTree	SDCCasm.c	/^asm_addTree (const ASM_MAPPINGS * pMappings)$/;"	f
asm_asxxxx_mapping	SDCCasm.c	/^const ASM_MAPPINGS asm_asxxxx_mapping = {$/;"	v
asm_gas_mapping	SDCCasm.c	/^const ASM_MAPPINGS asm_gas_mapping = {$/;"	v
asm_xa_asm_mapping	SDCCasm.c	/^const ASM_MAPPINGS asm_xa_asm_mapping = {$/;"	v
asmbuff	SDCClex.c	/^static struct dbuf_s asmbuff; \/* reusable _asm buffer *\/$/;"	v	file:
asmpeep	SDCCglobl.h	/^    int asmpeep;                \/* pass inline assembler thru peep hole *\/$/;"	m	struct:options
assemble	SDCCmain.c	/^assemble (char **envp)$/;"	f	file:
assembler	port.h	/^  assembler;$/;"	m
assert	SDCCerr.h	250;"	d
assert	SDCCerr.h	253;"	d
assert	SDCCerr.h	255;"	d
assignRegisters	port.h	/^  void (*assignRegisters) (struct ebbIndex *);$/;"	m
assignmentsToSym	SDCCloop.c	/^assignmentsToSym (set * sset, operand * sym)$/;"	f	file:
ast	SDCCast.h	/^ast;$/;"	t
ast	SDCCast.h	/^typedef struct ast$/;"	s
ast2iCode	SDCCicode.c	/^ast2iCode (ast * tree, int lvl)$/;"	f
astErrors	SDCCast.c	/^astErrors (ast * t)$/;"	f
astHasDeref	SDCCast.c	/^astHasDeref (ast * tree)$/;"	f	file:
astHasPointer	SDCCast.c	/^astHasPointer (ast * tree)$/;"	f
astHasSymbol	SDCCast.c	/^astHasSymbol (ast * tree, symbol * sym)$/;"	f
astHasVolatile	SDCCast.c	/^astHasVolatile (ast * tree)$/;"	f
astList	SDCCast.c	/^set *astList = NULL;$/;"	v
ast_print	SDCCast.c	/^ast_print (ast * tree, FILE * outfile, int indent)$/;"	f
asts	SDCCy.c	/^    ast        *asts;       \/* expression tree                        *\/$/;"	m	union:YYSTYPE	file:
asts	SDCCy.h	/^    ast        *asts;       \/* expression tree                        *\/$/;"	m	union:YYSTYPE
asym	SDCCloop.h	/^    operand *asym;$/;"	m	struct:induction
attr	SDCCdwarf2.h	/^  int attr;$/;"	m	struct:dwattr
attribs	SDCCdwarf2.h	/^  struct dwattr * attribs;$/;"	m	struct:dwtag
bSize	SDCCbitv.h	/^    int bSize;$/;"	m	struct:bitVect
b_absadr	SDCCsymt.h	/^  unsigned b_absadr:1;              \/* absolute address specfied  *\/$/;"	m	struct:specifier
b_bitUnnamed	SDCCsymt.h	/^  unsigned b_bitUnnamed:1;          \/* is an unnamed bit-field    *\/$/;"	m	struct:specifier
b_const	SDCCsymt.h	/^  unsigned b_const:1;               \/* is a constant              *\/$/;"	m	struct:specifier
b_extern	SDCCsymt.h	/^  unsigned b_extern:1;              \/* 1=extern found             *\/$/;"	m	struct:specifier
b_flexArrayMember	SDCCsymt.h	/^  bool b_flexArrayMember;       \/* has got a flexible array member,$/;"	m	struct:structdef
b_inline	SDCCsymt.h	/^  unsigned b_inline:1;              \/* inline function requested  *\/$/;"	m	struct:specifier
b_isenum	SDCCsymt.h	/^  unsigned b_isenum:1;              \/* is an enumerated type      *\/$/;"	m	struct:specifier
b_isregparm	SDCCsymt.h	/^  unsigned b_isregparm:1;           \/* is the first parameter     *\/$/;"	m	struct:specifier
b_long	SDCCsymt.h	/^  unsigned b_long:1;                \/* 1=long                     *\/$/;"	m	struct:specifier
b_longlong	SDCCsymt.h	/^  unsigned b_longlong:1;            \/* 1=long long                *\/$/;"	m	struct:specifier
b_noreturn	SDCCsymt.h	/^  unsigned b_noreturn:1;            \/* promised not to return     *\/$/;"	m	struct:specifier
b_restrict	SDCCsymt.h	/^  unsigned b_restrict:1;            \/* is restricted              *\/$/;"	m	struct:specifier
b_short	SDCCsymt.h	/^  unsigned b_short:1;               \/* 1=short int                *\/$/;"	m	struct:specifier
b_signed	SDCCsymt.h	/^  unsigned b_signed:1;              \/* just for sanity checks only*\/$/;"	m	struct:specifier
b_static	SDCCsymt.h	/^  unsigned b_static:1;              \/* 1=static keyword found     *\/$/;"	m	struct:specifier
b_typedef	SDCCsymt.h	/^  unsigned b_typedef:1;             \/* is typedefed               *\/$/;"	m	struct:specifier
b_unsigned	SDCCsymt.h	/^  unsigned b_unsigned:1;            \/* 1=unsigned, 0=signed       *\/$/;"	m	struct:specifier
b_volatile	SDCCsymt.h	/^  unsigned b_volatile:1;            \/* is marked as volatile      *\/$/;"	m	struct:specifier
backPatchLabels	SDCCast.c	/^backPatchLabels (ast * tree, symbol * trueLabel, symbol * falseLabel)$/;"	f	file:
bankSaved	SDCCicode.h	/^  unsigned bankSaved:1;         \/* register bank has been saved *\/$/;"	m	struct:iCode
bank_overhead	port.h	/^    int bank_overhead;$/;"	m
banked	SDCCsymt.h	/^    unsigned banked:1;              \/* function has the banked attribute    *\/$/;"	m	struct:sym_link::<anonymous>
banked_overhead	port.h	/^    int banked_overhead;$/;"	m
barrier	SDCCpeeph.h	/^    unsigned int barrier:1;$/;"	m	struct:peepRule
baseOffset	SDCCdwarf2.h	/^  int baseOffset;$/;"	m	struct:dwloclist
baseOffset	SDCCdwarf2.h	/^  int baseOffset;$/;"	m	struct:dwtag
basicInduction	SDCCloop.c	/^basicInduction (region * loopReg, ebbIndex * ebbi)$/;"	f	file:
basic_block	SDCCdwarf2.h	/^  unsigned basic_block:1;$/;"	m	struct:dwline
bbOrder	SDCCBBlock.h	/^  eBBlock **bbOrder;            \/* blocks in bbnum order *\/$/;"	m	struct:ebbIndex
bbnum	SDCCBBlock.h	/^  int bbnum;                    \/* index into array of numbers *\/$/;"	m	struct:eBBlock
begin_sequence	SDCCdwarf2.h	/^  unsigned begin_sequence:1;$/;"	m	struct:dwline
binPathSet	SDCCsystem.c	/^set *binPathSet = NULL; \/* set of binary paths *\/$/;"	v
bindVar	SDCCpeeph.c	/^bindVar (int key, char **s, hTab ** vtab)$/;"	f	file:
bit	SDCCmem.c	/^memmap *bit = NULL;             \/* bit addressable space       *\/$/;"	v
bitUnnamed	SDCCsymt.h	/^  char bitUnnamed:1;                \/* unnamed bit variable *\/$/;"	m	struct:symbol
bitVar	SDCCsymt.h	/^  char bitVar;                      \/* if bitVar != 0: this is a bit variable, bitVar is the size in bits *\/$/;"	m	struct:symbol
bitVect	SDCCbitv.h	/^bitVect;$/;"	t
bitVect	SDCCbitv.h	/^typedef struct bitVect$/;"	s
bitVectBitValue	SDCCbitv.c	/^bitVectBitValue (const bitVect *bvp, int pos)$/;"	f
bitVectBitsInCommon	SDCCbitv.c	/^bitVectBitsInCommon (bitVect * bvp1, bitVect * bvp2)$/;"	f
bitVectCopy	SDCCbitv.c	/^bitVectCopy (bitVect * bvp)$/;"	f
bitVectCplAnd	SDCCbitv.c	/^bitVectCplAnd (bitVect * bvp1, bitVect * bvp2)$/;"	f
bitVectDebugOn	SDCCbitv.c	/^bitVectDebugOn (bitVect * bvp, FILE * of)$/;"	f
bitVectDefault	SDCCbitv.c	/^int bitVectDefault = 1024;$/;"	v
bitVectEqual	SDCCbitv.c	/^bitVectEqual (bitVect * bvp1, bitVect * bvp2)$/;"	f
bitVectFirstBit	SDCCbitv.c	/^bitVectFirstBit (bitVect * bvp)$/;"	f
bitVectIntersect	SDCCbitv.c	/^bitVectIntersect (bitVect * bvp1, bitVect * bvp2)$/;"	f
bitVectIsZero	SDCCbitv.c	/^bitVectIsZero (bitVect * bvp)$/;"	f
bitVectResize	SDCCbitv.c	/^bitVectResize (bitVect * bvp, int size)$/;"	f
bitVectSetBit	SDCCbitv.c	/^bitVectSetBit (bitVect * bvp, int pos)$/;"	f
bitVectUnSetBit	SDCCbitv.c	/^bitVectUnSetBit (const bitVect *bvp, int pos)$/;"	f
bitVectUnion	SDCCbitv.c	/^bitVectUnion (bitVect * bvp1, bitVect * bvp2)$/;"	f
bitVectnBitsOn	SDCCbitv.c	/^bitVectnBitsOn (bitVect * bvp)$/;"	f
bit_name	port.h	/^    const char *const bit_name;$/;"	m
bit_size	port.h	/^    int bit_size;$/;"	m
bitsForType	SDCCsymt.c	/^bitsForType (sym_link * p)$/;"	f
bitsp	SDCCmem.h	/^    unsigned bitsp:1;           \/* 1 = bit addressable space   *\/$/;"	m	struct:memmap
block	SDCCast.h	/^  int block;                    \/* block number   *\/$/;"	m	struct:ast
block	SDCCdwarf2.h	/^    } block;$/;"	m	union:dwattr::<anonymous>
block	SDCCicode.c	/^int block;$/;"	v
block	SDCCicode.h	/^  short block;                  \/* sequential block number *\/$/;"	m	struct:iCode
block	SDCCsymt.h	/^  int block;                    \/* belongs to which block     *\/$/;"	m	struct:bucket
block	SDCCsymt.h	/^  int block;                    \/* belongs to which block     *\/$/;"	m	struct:structdef
block	SDCCsymt.h	/^  short block;                      \/* sequential block # of definition *\/$/;"	m	struct:symbol
blockNo	SDCCy.c	/^int blockNo   = 0;      \/* sequential block number  *\/$/;"	v
blockSpil	SDCCsymt.h	/^  unsigned blockSpil:1;             \/* spilt at block level       *\/$/;"	m	struct:symbol
bool	SDCCglobl.h	/^typedef unsigned char bool;$/;"	t
boolCast	SDCCcse.c	/^boolCast (iCode * ic, set * cseSet)$/;"	f	file:
bucket	SDCCsymt.h	/^bucket;$/;"	t
bucket	SDCCsymt.h	/^typedef struct bucket$/;"	s
buffer	SDCCmain.c	/^char buffer[PATH_MAX * 2];$/;"	v
buildCmdLine	SDCCutil.c	/^buildCmdLine (const char **cmds, const char *p1, const char *p2, const char *p3, set * list)$/;"	f
buildCmdLine2	SDCCutil.c	/^buildCmdLine2 (const char *pcmd, ...)$/;"	f
buildLabelRefCountHash	SDCCpeeph.c	/^buildLabelRefCountHash (lineNode * head)$/;"	f	file:
buildLabelRefTable	SDCClabel.c	/^buildLabelRefTable (iCode * ic)$/;"	f
buildMacros	SDCCutil.c	/^buildMacros (const char *cmd)$/;"	f
builtin	SDCCsymt.h	/^    unsigned builtin;               \/* is a builtin function                *\/$/;"	m	struct:sym_link::<anonymous>
builtinSEND	SDCCicode.h	/^  unsigned builtinSEND:1;       \/* SEND for parameter of builtin function *\/$/;"	m	struct:iCode
builtins	port.h	/^typedef struct builtins$/;"	s
builtins	port.h	/^} builtins;$/;"	t
builtintable	port.h	/^  builtins *builtintable;       \/* table of builtin functions *\/$/;"	m
byteOfVal	SDCCval.c	/^byteOfVal (value * val, int offset)$/;"	f
c1mode	SDCCglobl.h	/^    int c1mode;                 \/* Act like c1 - no pre-proc, asm or link *\/$/;"	m	struct:options
cNestLevel	SDCCval.c	/^int cNestLevel;$/;"	v
c_abs	SDCCmem.c	/^memmap *c_abs = NULL;           \/* constant absolute data      *\/$/;"	v
cabs_name	port.h	/^    const char *const cabs_name;        \/\/ const absolute data (code or not)$/;"	m
callFuncByName	SDCCpeeph.c	/^callFuncByName (char *fname,$/;"	f	file:
call_overhead	port.h	/^    int call_overhead;$/;"	m
calleeCmp	SDCCsymt.c	/^calleeCmp (void *p1, void *p2)$/;"	f	file:
calleeSaves	SDCCsymt.h	/^    unsigned calleeSaves:1;         \/* functions uses callee save           *\/$/;"	m	struct:sym_link::<anonymous>
calleeSavesSet	SDCCglobl.h	/^    set *calleeSavesSet;        \/* list of functions using callee save *\/$/;"	m	struct:options
canAssign	port.h	/^    bool (*canAssign) (const char *op1, const char *op2, const char *op3);$/;"	m
canOverlayLocals	SDCCmem.c	/^canOverlayLocals (eBBlock ** ebbs, int count)$/;"	f	file:
cast	SDCCast.h	/^    } cast;$/;"	m	union:ast::<anonymous>
cc_only	SDCCglobl.h	/^    int cc_only;                \/* compile only flag              *\/$/;"	m	struct:options
cdbCloseFile	cdbFile.c	/^cdbCloseFile (void)$/;"	f
cdbDebugFile	cdbFile.c	/^DEBUGFILE cdbDebugFile = $/;"	v
cdbFilePtr	cdbFile.c	/^FILE *cdbFilePtr = NULL;$/;"	v
cdbModuleName	cdbFile.c	/^const char *cdbModuleName = NULL;$/;"	v
cdbOpenFile	cdbFile.c	/^cdbOpenFile (const char *file)$/;"	f
cdbStructBlock	SDCCsymt.c	/^cdbStructBlock (int block)$/;"	f
cdbTypeInfo	cdbFile.c	/^cdbTypeInfo (sym_link * type)$/;"	f
cdbWriteALine	cdbFile.c	/^cdbWriteALine (const char *module, int Line)$/;"	f
cdbWriteBasicSymbol	cdbFile.c	/^cdbWriteBasicSymbol (symbol *sym, int isStructSym, int isFunc)$/;"	f
cdbWriteCLine	cdbFile.c	/^cdbWriteCLine (iCode *ic)$/;"	f
cdbWriteEndFunction	cdbFile.c	/^cdbWriteEndFunction (symbol *pSym, iCode *ic, int offset)$/;"	f
cdbWriteFrameAddress	cdbFile.c	/^cdbWriteFrameAddress (const char *variable, struct reg_info *reg, int offset)$/;"	f
cdbWriteFunction	cdbFile.c	/^cdbWriteFunction (symbol *pSym, iCode *ic)$/;"	f
cdbWriteLabel	cdbFile.c	/^cdbWriteLabel (symbol *pSym, iCode *ic)$/;"	f
cdbWriteModule	cdbFile.c	/^cdbWriteModule(const char *name)$/;"	f
cdbWriteScope	cdbFile.c	/^cdbWriteScope (iCode *ic)$/;"	f
cdbWriteSymbol	cdbFile.c	/^cdbWriteSymbol(symbol *pSym)$/;"	f
cdbWriteType	cdbFile.c	/^cdbWriteType (structdef *sdef, int block, int inStruct, const char *tag)$/;"	f
cdef	SDCCsymt.h	/^  unsigned cdef:1;                  \/* compiler defined symbol *\/$/;"	m	struct:symbol
cenum	SDCCy.c	/^value *cenum = NULL;        \/* current enumeration  type chain*\/$/;"	v
cfiSame	port.h	/^      bitVect *cfiSame;$/;"	m
cfiUndef	port.h	/^      bitVect *cfiUndef;$/;"	m
changePointer	SDCCsymt.c	/^changePointer (sym_link * p)$/;"	f
charType	SDCCsymt.c	/^sym_link *charType;$/;"	v
charVal	SDCCval.c	/^charVal (const char *s)$/;"	f
char_size	port.h	/^    int char_size;$/;"	m
cheapestVal	SDCCval.c	/^cheapestVal (value * val)$/;"	f	file:
checkConstantRange	SDCCval.c	/^checkConstantRange (sym_link * var, sym_link * lit, int op, bool exchangeLeftRight)$/;"	f
checkCurrFile	SDCClex.c	/^checkCurrFile (const char *s)$/;"	f	file:
checkDecl	SDCCsymt.c	/^checkDecl (symbol * sym, int isProto)$/;"	f
checkFunction	SDCCsymt.c	/^checkFunction (symbol * sym, symbol * csym)$/;"	f
checkPtrCast	SDCCast.c	/^checkPtrCast (sym_link * newType, sym_link * orgType, bool implicit)$/;"	f
checkPtrQualifiers	SDCCicode.c	/^checkPtrQualifiers (sym_link * ltype, sym_link * rtype)$/;"	f	file:
checkSClass	SDCCsymt.c	/^checkSClass (symbol * sym, int isProto)$/;"	f	file:
checkStructFlexArray	SDCCsymt.c	/^checkStructFlexArray (symbol * sym, sym_link * p)$/;"	f	file:
checkTypeSanity	SDCCsymt.c	/^checkTypeSanity (sym_link * etype, const char *name)$/;"	f
checkTypes	SDCCicode.c	/^checkTypes (operand * left, operand * right)$/;"	f	file:
check_newline	altlex.c	/^check_newline (void)$/;"	f	file:
check_token	altlex.c	/^check_token (const char *sz)$/;"	f	file:
check_type	SDCClex.c	/^check_type (void)$/;"	f	file:
chomp	SDCCutil.c	/^chomp (char *sz)$/;"	f
cl_opt_arg_type	SDCCargs.h	/^enum cl_opt_arg_type {$/;"	g
clashes	SDCCsymt.h	/^  struct bitVect *clashes;          \/* overlaps with what other symbols *\/$/;"	m	struct:symbol
cleanUpBlock	SDCCsymt.c	/^cleanUpBlock (bucket ** table, int block)$/;"	f
cleanUpLevel	SDCCsymt.c	/^cleanUpLevel (bucket ** table, int level)$/;"	f
clearLvaluereq	SDCCicode.c	/^clearLvaluereq ()$/;"	f	file:
cloneOptimize	SDCClex.c	/^cloneOptimize (struct optimize *opt)$/;"	f	file:
cloneOptions	SDCClex.c	/^cloneOptions (struct options *opt)$/;"	f	file:
cloneSDCCERRG	SDCClex.c	/^cloneSDCCERRG (struct SDCCERRG *val)$/;"	f	file:
closeDumpFiles	SDCCBBlock.c	/^closeDumpFiles ()$/;"	f
closeFile	SDCCdebug.h	/^  int (*closeFile) (void);$/;"	m	struct:DebugFile
cmd	port.h	/^    const char **cmd;$/;"	m
cnd	SDCCicode.h	/^    cnd;$/;"	m	union:iCode::<anonymous>
cnvFromFixed16x16Cast	SDCCopt.c	/^cnvFromFixed16x16Cast (iCode * ic, eBBlock * ebp)$/;"	f	file:
cnvFromFloatCast	SDCCopt.c	/^cnvFromFloatCast (iCode * ic, eBBlock * ebp)$/;"	f	file:
cnvToFcall	SDCCopt.c	/^cnvToFcall (iCode * ic, eBBlock * ebp)$/;"	f	file:
cnvToFixed16x16Cast	SDCCopt.c	/^cnvToFixed16x16Cast (iCode * ic, eBBlock * ebp)$/;"	f	file:
cnvToFloatCast	SDCCopt.c	/^cnvToFloatCast (iCode * ic, eBBlock * ebp)$/;"	f	file:
code	SDCCmem.c	/^memmap *code = NULL;            \/* code segment                *\/$/;"	v
codeOutBuf	SDCCast.c	/^struct dbuf_s *codeOutBuf;$/;"	v
codeSize	SDCCglobl.h	/^    int codeSize;$/;"	m	struct:optimize
codeSpeed	SDCCglobl.h	/^    int codeSpeed;$/;"	m	struct:optimize
codeTable	SDCCicode.c	/^iCodeTable codeTable[] = {$/;"	v
code_loc	SDCCglobl.h	/^    int code_loc;               \/* code location start           *\/$/;"	m	struct:options
code_name	port.h	/^    const char *code_name;$/;"	m
code_ro	port.h	/^    int code_ro;                \/* code space read-only 1=yes *\/$/;"	m
code_seg	SDCCglobl.h	/^    char *code_seg;             \/* segment name to use instead of CSEG *\/$/;"	m	struct:options
code_size	SDCCglobl.h	/^    int code_size;              \/* code size (used only for error checking) *\/$/;"	m	struct:options
codesp	SDCCmem.h	/^    unsigned codesp:1;          \/* 1 = code space              *\/$/;"	m	struct:memmap
column	SDCClex.c	/^int column = 0;         \/* current column *\/$/;"	v
compStructSize	SDCCsymt.c	/^compStructSize (int su, structdef * sdef)$/;"	f
compareFuncType	SDCCsymt.c	/^compareFuncType (sym_link * dest, sym_link * src)$/;"	f
comparePtrType	SDCCsymt.c	/^comparePtrType (sym_link * dest, sym_link * src, bool bMustCast)$/;"	f
compareType	SDCCsymt.c	/^compareType (sym_link * dest, sym_link * src)$/;"	f
compareTypeExact	SDCCsymt.c	/^compareTypeExact (sym_link * dest, sym_link * src, int level)$/;"	f
compose_command_line	SDCCsystem.c	/^compose_command_line (const char *path, const char *command, const char *args)$/;"	f	file:
computeClash	SDCClrange.c	/^computeClash (eBBlock ** ebbs, int count)$/;"	f	file:
computeControlFlow	SDCCcflow.c	/^computeControlFlow (ebbIndex * ebbi)$/;"	f
computeDFOrdering	SDCCcflow.c	/^computeDFOrdering (eBBlock * ebbp, int *count)$/;"	f	file:
computeDataFlow	SDCCdflow.c	/^computeDataFlow (ebbIndex * ebbi)$/;"	f
computeDominance	SDCCcflow.c	/^computeDominance (ebbIndex * ebbi)$/;"	f	file:
computeLiveRanges	SDCClrange.c	/^computeLiveRanges (eBBlock ** ebbs, int count, bool emitWarnings)$/;"	f
computeType	SDCCsymt.c	/^computeType (sym_link * type1, sym_link * type2, RESULT_TYPE resultType, int op)$/;"	f
computeTypeOr	SDCCsymt.c	/^computeTypeOr (sym_link * etype1, sym_link * etype2, sym_link * reType)$/;"	f	file:
cond	SDCCpeeph.h	/^    char *cond;$/;"	m	struct:peepRule
condExpr	SDCCast.h	/^      struct ast *condExpr;     \/* conditional portion   *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
condLabel	SDCCast.h	/^      symbol *condLabel;        \/* conditional label     *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
condition	SDCCicode.h	/^      operand *condition;       \/* condition for the jump *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
condition	SDCCicode.h	/^      operand *condition;       \/* if this is a conditional *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
connectLine	SDCCgen.c	/^connectLine (lineNode * pl1, lineNode * pl2)$/;"	f
constBoolVal	SDCCval.c	/^constBoolVal (bool v)$/;"	f
constCharVal	SDCCval.c	/^constCharVal (unsigned char v)$/;"	f
constExprTree	SDCCast.c	/^constExprTree (ast * cexpr)$/;"	f
constExprValue	SDCCast.c	/^constExprValue (ast * cexpr, int check)$/;"	f
constFixed16x16Val	SDCCval.c	/^constFixed16x16Val (const char *s)$/;"	f
constFloatVal	SDCCval.c	/^constFloatVal (const char *s)$/;"	f
constFold	SDCCcse.c	/^constFold (iCode * ic, set * cseSet)$/;"	f
constVal	SDCCval.c	/^constVal (const char *s)$/;"	f
const_name	port.h	/^    const char *const const_name;       \/\/ const data (code or not)$/;"	m
const_seg	SDCCglobl.h	/^    char *const_seg;            \/* segment name to use instead of CONST *\/$/;"	m	struct:options
const_val	SDCCsymt.h	/^  const_val;$/;"	m	struct:specifier
constlist	SDCCast.h	/^    literalList *constlist;     \/* init list for array initializer. *\/$/;"	m	union:ast::<anonymous>
containsLoops	SDCCloop.h	/^    int containsLoops;		\/* contains other loops *\/$/;"	m	struct:region
continueLabel	SDCCast.h	/^      symbol *continueLabel;    \/* conditional check     *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
conv	SDCCsymt.c	/^symbol *conv[2][4][2];$/;"	v
convbuiltin	SDCCopt.c	/^convbuiltin (iCode *const ic, eBBlock *ebp)$/;"	f	file:
convertIListToConstList	SDCCval.c	/^convertIListToConstList (initList * src, literalList ** lList, int size)$/;"	f
convertToFcall	SDCCopt.c	/^convertToFcall (eBBlock ** ebbs, int count)$/;"	f	file:
convilong	SDCCopt.c	/^convilong (iCode * ic, eBBlock * ebp)$/;"	f	file:
convsmallc	SDCCopt.c	/^convsmallc (iCode *ic, eBBlock *ebp)$/;"	f	file:
copyAndFreeOptimize	SDCClex.c	/^copyAndFreeOptimize (struct optimize *dest, struct optimize *src)$/;"	f	file:
copyAndFreeOptions	SDCClex.c	/^copyAndFreeOptions (struct options *dest, struct options *src)$/;"	f	file:
copyAndFreeSDCCERRG	SDCClex.c	/^copyAndFreeSDCCERRG (struct SDCCERRG *dest, struct SDCCERRG *src)$/;"	f	file:
copyAst	SDCCast.c	/^copyAst (ast * src)$/;"	f
copyAstLoc	SDCCast.c	/^copyAstLoc (ast * dest, ast * src)$/;"	f	file:
copyAstValues	SDCCast.c	/^copyAstValues (ast * dest, ast * src)$/;"	f
copyDesignation	SDCCval.c	/^copyDesignation (designation * src)$/;"	f
copyIlist	SDCCval.c	/^copyIlist (initList * src)$/;"	f
copyLinkChain	SDCCsymt.c	/^copyLinkChain (sym_link * p)$/;"	f
copyLiteralList	SDCCval.c	/^copyLiteralList (literalList * src)$/;"	f
copyStr	SDCCutil.c	/^copyStr (const char *src, size_t *size)$/;"	f
copySymbol	SDCCsymt.c	/^copySymbol (symbol * src)$/;"	f
copySymbolChain	SDCCsymt.c	/^copySymbolChain (symbol * src)$/;"	f
copyValue	SDCCval.c	/^copyValue (value * src)$/;"	f
copyValueChain	SDCCval.c	/^copyValueChain (value * src)$/;"	f
copyiCode	SDCCicode.c	/^copyiCode (iCode * ic)$/;"	f
count	SDCCBBlock.h	/^  int count;                    \/* number of blocks in the index *\/$/;"	m	struct:ebbIndex
count	SDCCast.c	/^  int count;                    \/* number of inline functions inserted *\/$/;"	m	file:
count	SDCClex.c	/^count (void)$/;"	f	file:
count	SDCCval.h	/^  unsigned count;$/;"	m	struct:literalList
count_char	SDCClex.c	/^count_char (int ch)$/;"	f	file:
createBlock	SDCCast.c	/^createBlock (symbol * decl, ast * body)$/;"	f
createCase	SDCCast.c	/^createCase (ast * swStat, ast * caseVal, ast * stmnt)$/;"	f
createConfigure	SDCCast.c	/^createConfigure (ast * body, const char * str)$/;"	f
createDefault	SDCCast.c	/^createDefault (ast * swStat, ast * defaultVal, ast * stmnt)$/;"	f
createDo	SDCCast.c	/^createDo (symbol * trueLabel, symbol * continueLabel, symbol * falseLabel, ast * condAst, ast * doBody)$/;"	f
createDumpFile	SDCCBBlock.c	/^createDumpFile (int id)$/;"	f
createFor	SDCCast.c	/^createFor (symbol * trueLabel, symbol * continueLabel,$/;"	f
createFunction	SDCCast.c	/^createFunction (symbol * name, ast * body)$/;"	f
createIf	SDCCast.c	/^createIf (ast * condAst, ast * ifBody, ast * elseBody)$/;"	f
createInterruptVect	SDCCglue.c	/^createInterruptVect (struct dbuf_s *vBuf)$/;"	f
createIval	SDCCast.c	/^createIval (ast * sym, sym_link * type, initList * ilist, ast * wid, ast * rootValue)$/;"	f	file:
createIvalArray	SDCCast.c	/^createIvalArray (ast * sym, sym_link * type, initList * ilist, ast * rootValue)$/;"	f	file:
createIvalCharPtr	SDCCast.c	/^createIvalCharPtr (ast * sym, sym_link * type, ast * iexpr, ast * rootVal)$/;"	f	file:
createIvalPtr	SDCCast.c	/^createIvalPtr (ast * sym, sym_link * type, initList * ilist, ast * rootVal)$/;"	f	file:
createIvalStruct	SDCCast.c	/^createIvalStruct (ast * sym, sym_link * type, initList * ilist, ast * rootValue)$/;"	f	file:
createIvalType	SDCCast.c	/^createIvalType (ast * sym, sym_link * type, initList * ilist)$/;"	f	file:
createLabel	SDCCast.c	/^createLabel (symbol * label, ast * stmnt)$/;"	f
createLoopRegions	SDCCloop.c	/^createLoopRegions (ebbIndex * ebbi)$/;"	f
createRMW	SDCCast.c	/^createRMW (ast * target, unsigned op, ast * operand)$/;"	f
createWhile	SDCCast.c	/^createWhile (symbol * trueLabel, symbol * continueLabel, symbol * falseLabel, ast * condExpr, ast * whileBody)$/;"	f
critical	SDCCsymt.h	/^    unsigned critical:1;            \/* critical function                    *\/$/;"	m	struct:sym_link::<anonymous>
crt	port.h	/^    const char *const *crt;$/;"	m
cseAllBlocks	SDCCcse.c	/^cseAllBlocks (ebbIndex * ebbi, int computeOnly)$/;"	f
cseBBlock	SDCCcse.c	/^cseBBlock (eBBlock * ebb, int computeOnly, ebbIndex * ebbi)$/;"	f
cseDef	SDCCcse.h	/^cseDef;$/;"	t
cseDef	SDCCcse.h	/^typedef struct cseDef$/;"	s
cseDefNum	SDCCopt.c	/^int cseDefNum = 0;$/;"	v
cseOk	port.h	/^  bool (*cseOk) (iCode * ic, iCode * pdic);$/;"	m
curr	SDCCset.h	/^    struct set *curr;$/;"	m	struct:set
currBlockno	SDCCy.c	/^int currBlockno=0;$/;"	v
currFname	altlex.c	/^char *currFname;$/;"	v
currFunc	SDCCast.c	/^symbol *currFunc = NULL;$/;"	v
currItem	SDCChasht.h	/^    hashtItem *currItem;	\/* current item within the list *\/$/;"	m	struct:hTab
currKey	SDCChasht.h	/^    int currKey;		\/* used for iteration *\/$/;"	m	struct:hTab
currLineno	SDCCast.c	/^int currLineno = 0;$/;"	v
currRegBank	SDCCmain.c	/^int currRegBank = 0;$/;"	v
currRule	SDCCpeeph.c	/^static peepRule *currRule = NULL;$/;"	v	file:
cval	SDCCloop.h	/^    long cval;$/;"	m	struct:induction
cyclomatic	SDCCglobl.h	/^    int cyclomatic;             \/* print cyclomatic information *\/$/;"	m	struct:options
d	SDCCsymt.h	/^    declarator d;                   \/* if CLASS == DECLARATOR     *\/$/;"	m	union:sym_link::<anonymous>
d_abs	SDCCmem.c	/^memmap *d_abs = NULL;           \/* absolute data upto 128      *\/$/;"	v
data	SDCCdwarf2.h	/^      unsigned char * data;$/;"	m	struct:dwattr::<anonymous>::<anonymous>
data	SDCCdwarf2.h	/^    int data;$/;"	m	union:dwattr::<anonymous>
data	SDCCmem.c	/^memmap *data = NULL;            \/* internal data upto 128      *\/$/;"	v
dataDirsSet	SDCCmain.c	/^set *dataDirsSet = NULL;        \/* list of data search directories *\/$/;"	v
data_loc	SDCCglobl.h	/^    int data_loc;               \/* interram start location       *\/$/;"	m	struct:options
data_name	port.h	/^    const char *data_name;$/;"	m
dbName	SDCCmem.h	/^    char dbName;                \/* debugger address space name *\/$/;"	m	struct:memmap
dbuf	SDCCutil.h	/^  struct dbuf_s dbuf;$/;"	m	struct:pragma_token_s
dbuf_makePath	SDCCutil.c	/^dbuf_makePath (struct dbuf_s *path, const char *dir, const char *file)$/;"	f
dbuf_printOperand	SDCCicode.c	/^dbuf_printOperand (operand * op, struct dbuf_s *dbuf)$/;"	f
dbuf_printTypeChain	SDCCsymt.c	/^dbuf_printTypeChain (sym_link * start, struct dbuf_s *dbuf)$/;"	f
dbuf_splitFile	SDCCutil.c	/^dbuf_splitFile (const char *path, struct dbuf_s *file, struct dbuf_s *ext)$/;"	f
dbuf_splitPath	SDCCutil.c	/^dbuf_splitPath (const char *path, struct dbuf_s *dir, struct dbuf_s *file)$/;"	f
dbuf_tprintf	SDCCasm.c	/^dbuf_tprintf (struct dbuf_s *dbuf, const char *szFormat, ...)$/;"	f
dbuf_tvprintf	SDCCasm.c	/^dbuf_tvprintf (struct dbuf_s *dbuf, const char *format, va_list ap)$/;"	f
dcl_type	SDCCsymt.h	/^  DECLARATOR_TYPE dcl_type;         \/* POINTER,ARRAY or FUNCTION  *\/$/;"	m	struct:declarator
deadMove	port.h	/^    bool (*deadMove) (const char *reg, lineNode * currPl, lineNode * head);$/;"	m
deallocLocal	SDCCmem.c	/^deallocLocal (symbol * csym)$/;"	f
deallocParms	SDCCmem.c	/^deallocParms (value * val)$/;"	f
debug	SDCCglobl.h	/^    int debug;                  \/* generate extra debug info *\/$/;"	m	struct:options
debugFile	SDCCdebug.c	/^DEBUGFILE *debugFile = &cdbDebugFile;$/;"	v
debug_opts	port.h	/^    const char *debug_opts;$/;"	m
debugger	port.h	/^  debugger;$/;"	m
declaration_specifiers	SDCC.y	/^declaration_specifiers : declaration_specifiers_ { $$ = finalizeSpec($1); };$/;"	l
declarator	SDCCsymt.h	/^declarator;$/;"	t
declarator	SDCCsymt.h	/^typedef struct declarator$/;"	s
decorateType	SDCCast.c	/^decorateType (ast * tree, RESULT_TYPE resultType)$/;"	f
decorated	SDCCast.h	/^  unsigned decorated:1;$/;"	m	struct:ast
deep	SDCCval.h	/^    struct initList *deep;$/;"	m	union:initList::<anonymous>
defKey	SDCCicode.h	/^  int defKey;                   \/* key for the operand being defined  *\/$/;"	m	struct:iCode
defSet	SDCCBBlock.h	/^  bitVect *defSet;              \/* symbols defined in block        *\/$/;"	m	struct:eBBlock
defaultOClass	SDCCmem.c	/^defaultOClass (symbol *sym)$/;"	f
default_globl_map	port.h	/^    struct memmap *default_globl_map;   \/\/ default location for globl vars$/;"	m
default_local_map	port.h	/^    struct memmap *default_local_map;   \/\/ default location for auto vars$/;"	m
default_model	port.h	/^    int default_model;$/;"	m
default_rules	port.h	/^    char *default_rules;$/;"	m
defs	SDCCsymt.h	/^  struct bitVect *defs;             \/* bit vector for definitions *\/$/;"	m	struct:symbol
delLvaluereq	SDCCicode.c	/^delLvaluereq ()$/;"	f	file:
deleteFromSeg	SDCCmem.c	/^void deleteFromSeg(symbol *sym)$/;"	f
deleteGetPointers	SDCCcse.c	/^deleteGetPointers (set ** cseSet, set ** pss, operand * op, eBBlock * ebb)$/;"	f	file:
deleteIfx	SDCClabel.c	/^deleteIfx (iCode * loop, int key)$/;"	f	file:
deleteItemIf	SDCCset.c	/^deleteItemIf (set ** sset, int (*cond) (void *, va_list),...)$/;"	f
deleteSet	SDCCset.c	/^deleteSet (set **s)$/;"	f
deleteSetItem	SDCCset.c	/^deleteSetItem (set ** list, void *item)$/;"	f
deleteSym	SDCCsymt.c	/^deleteSym (bucket ** stab, void *sym, const char *sname)$/;"	f
deprecated	port.h	/^  char deprecated;$/;"	m	struct:pragma_s
depth	SDCCBBlock.h	/^  int depth;                    \/* loop depth of this block *\/$/;"	m	struct:eBBlock
depth	SDCCicode.h	/^  short depth;                  \/* loop depth of this iCode *\/$/;"	m	struct:iCode
designation	SDCCval.h	/^  struct designation *designation;$/;"	m	struct:initList
designation	SDCCval.h	/^designation;$/;"	t
designation	SDCCval.h	/^typedef struct designation$/;"	s
designator	SDCCval.h	/^    designator;$/;"	m	struct:designation
destroy_line_list	SDCCgen.c	/^destroy_line_list (void)$/;"	f
dfNumCompare	SDCCcflow.c	/^dfNumCompare (const void *a, const void *b)$/;"	f
dfOrder	SDCCBBlock.h	/^  eBBlock **dfOrder;            \/* blocks in dfnum (depth first) order *\/$/;"	m	struct:ebbIndex
dfnum	SDCCBBlock.h	/^  int dfnum;                    \/* depth first number *\/$/;"	m	struct:eBBlock
diCode	SDCCcse.h	/^    iCode *diCode;		\/* defining instruction *\/$/;"	m	struct:cseDef
dirIndex	SDCCdwarf2.h	/^  int dirIndex;$/;"	m	struct:dwfile
direct	SDCCmem.h	/^    unsigned direct:1;          \/* 1 = indirect access only    *\/$/;"	m	struct:memmap
direction	port.h	/^    int direction;$/;"	m
disabled	SDCCerr.c	/^  char disabled;$/;"	m	file:
discardDeadParamReceives	SDCCopt.c	/^discardDeadParamReceives (eBBlock ** ebbs, int count)$/;"	f	file:
discard_comments	altlex.c	/^discard_comments (int type)$/;"	f	file:
disconBBlock	SDCCcflow.c	/^disconBBlock (eBBlock * ebp, ebbIndex * ebbi)$/;"	f
do	SDCC.y	/^do : DO {  \/* create and push the continue , break & body Labels *\/$/;"	l
doOverlays	SDCCmem.c	/^doOverlays (eBBlock ** ebbs, int count)$/;"	f
doPragma	SDCClex.c	/^doPragma (int id, const char *name, const char *cp)$/;"	f	file:
doPrintSearchDirs	SDCCmain.c	/^doPrintSearchDirs (void)$/;"	f	file:
do_assemble	port.h	/^    void (*do_assemble) (set *);$/;"	m
do_glue	port.h	/^    void (*do_glue) (void);$/;"	m
do_link	port.h	/^    void (*do_link) (void);$/;"	m
dollars_in_ident	SDCCglobl.h	/^    int dollars_in_ident;       \/* zero means dollar signs are punctuation *\/$/;"	m	struct:options
domSetFromVect	SDCCcflow.c	/^domSetFromVect (ebbIndex *ebbi, bitVect * domVect)$/;"	f	file:
domVect	SDCCBBlock.h	/^  bitVect *domVect;             \/* list of nodes this is dominated by (index is bbnum) *\/$/;"	m	struct:eBBlock
double2ul	SDCCval.c	/^double2ul (double val)$/;"	f
doubleFromFixed16x16	SDCCval.c	/^doubleFromFixed16x16 (TYPE_TARGET_ULONG value)$/;"	f
dptr	SDCCsymt.h	/^  unsigned dptr;                    \/* 8051 variants with multiple DPTRS$/;"	m	struct:symbol
ds390_jammed	SDCCmain.c	/^static int ds390_jammed = 0;$/;"	v	file:
dsgn	SDCCy.c	/^    designation*dsgn;       \/* designator                             *\/$/;"	m	union:YYSTYPE	file:
dsgn	SDCCy.h	/^    designation*dsgn;       \/* designator                             *\/$/;"	m	union:YYSTYPE
dstFileName	SDCCmain.c	/^const char *dstFileName;        \/* destination file name without extension *\/$/;"	v
dstPath	SDCCmain.c	/^static const char *dstPath = "";    \/* path for the output files; *\/$/;"	v	file:
dumpEbbsToFileExt	SDCCBBlock.c	/^dumpEbbsToFileExt (int id, ebbIndex * ebbi)$/;"	f
dumpFiles	SDCCBBlock.c	/^struct _dumpFiles dumpFiles[] = {$/;"	v
dumpLiveRanges	SDCCBBlock.c	/^dumpLiveRanges (int id, hTab * liveRanges)$/;"	f
dumpSymInfo	SDCCdebug.c	/^dumpSymInfo(const char *pcName, memmap *memItem)$/;"	f
dump_gcse	SDCCglobl.h	/^    int dump_gcse;              \/* dump after gcse *\/$/;"	m	struct:options
dump_graphs	SDCCglobl.h	/^    int dump_graphs;            \/* Dump graphs in .dot format (control-flow, conflict, etc) *\/$/;"	m	struct:options
dump_kill	SDCCglobl.h	/^    int dump_kill;              \/* dump after dead code elimination *\/$/;"	m	struct:options
dump_loop	SDCCglobl.h	/^    int dump_loop;              \/* dump after loop optimizations *\/$/;"	m	struct:options
dump_pack	SDCCglobl.h	/^    int dump_pack;              \/* dump after register packing *\/$/;"	m	struct:options
dump_range	SDCCglobl.h	/^    int dump_range;             \/* dump after live range analysis *\/$/;"	m	struct:options
dump_rassgn	SDCCglobl.h	/^    int dump_rassgn;            \/* dump after register assignment *\/$/;"	m	struct:options
dump_raw	SDCCglobl.h	/^    int dump_raw;               \/* dump after intermediate code generation *\/$/;"	m	struct:options
dump_tree	SDCCglobl.h	/^    int dump_tree;              \/* dump front-end tree before lowering to iCode *\/$/;"	m	struct:options
dwAbbrevNum	SDCCdwarf2.c	/^int dwAbbrevNum = 0;$/;"	v
dwAbbrevTable	SDCCdwarf2.c	/^hTab * dwAbbrevTable;$/;"	v
dwAddSibAttr	SDCCdwarf2.c	/^dwAddSibAttr (dwtag *tp, void *info)$/;"	f	file:
dwAddTagAttr	SDCCdwarf2.c	/^dwAddTagAttr (dwtag * tp, dwattr * ap)$/;"	f	file:
dwAddTagChild	SDCCdwarf2.c	/^dwAddTagChild (dwtag * parent, dwtag * child)$/;"	f	file:
dwAssignAbbrev	SDCCdwarf2.c	/^dwAssignAbbrev (dwtag *tp, void *info)$/;"	f	file:
dwAssignLocListAddresses	SDCCdwarf2.c	/^dwAssignLocListAddresses (void)$/;"	f	file:
dwAssignTagAddress	SDCCdwarf2.c	/^dwAssignTagAddress (dwtag *tp, void *info)$/;"	f	file:
dwCloseFile	SDCCdwarf2.c	/^dwCloseFile (void)$/;"	f
dwDebugSymbol	SDCCdwarf2.c	/^int dwDebugSymbol = 0;$/;"	v
dwDeleteTagAttr	SDCCdwarf2.c	/^dwDeleteTagAttr (dwtag *tp, void *info)$/;"	f	file:
dwFilenameSet	SDCCdwarf2.c	/^set * dwFilenameSet = NULL;$/;"	v
dwFindAttr	SDCCdwarf2.c	/^dwFindAttr (dwtag * tp, int attr)$/;"	f	file:
dwFindFileIndex	SDCCdwarf2.c	/^dwFindFileIndex (char * filename)$/;"	f	file:
dwFindScope	SDCCdwarf2.c	/^dwFindScope (dwtag * tp, int block)$/;"	f	file:
dwFrameLastLoc	SDCCdwarf2.c	/^dwlocregion * dwFrameLastLoc = NULL;$/;"	v
dwFrameLocList	SDCCdwarf2.c	/^dwloclist * dwFrameLocList = NULL;$/;"	v
dwFreeAttr	SDCCdwarf2.c	/^dwFreeAttr (dwattr * ap)$/;"	f	file:
dwFuncTag	SDCCdwarf2.c	/^dwtag *dwFuncTag = NULL;$/;"	v
dwGenerateScopes	SDCCdwarf2.c	/^dwGenerateScopes (dwtag *tp, ast * tree)$/;"	f	file:
dwHashTag	SDCCdwarf2.c	/^dwHashTag (dwtag * tp)$/;"	f	file:
dwHashType	SDCCdwarf2.c	/^dwHashType (sym_link * type)$/;"	f	file:
dwLineBase	SDCCdwarf2.c	/^int dwLineBase = -5;$/;"	v
dwLineFirst	SDCCdwarf2.c	/^dwline * dwLineFirst = NULL;$/;"	v
dwLineLast	SDCCdwarf2.c	/^dwline * dwLineLast = NULL;$/;"	v
dwLineOpcodeBase	SDCCdwarf2.c	/^int dwLineOpcodeBase = 10;$/;"	v
dwLineRange	SDCCdwarf2.c	/^int dwLineRange = 15;$/;"	v
dwMatchTagAttr	SDCCdwarf2.c	/^dwMatchTagAttr (const void * tp1v, const void * tp2v)$/;"	f	file:
dwMatchTypes	SDCCdwarf2.c	/^dwMatchTypes (const void * type1v, const void * type2v)$/;"	f	file:
dwModuleName	SDCCdwarf2.c	/^char *dwModuleName = NULL;$/;"	v
dwNewAttr	SDCCdwarf2.c	/^dwNewAttr (int attr)$/;"	f	file:
dwNewAttrAddrLabel	SDCCdwarf2.c	/^dwNewAttrAddrLabel (int attr, char * label, int offset)$/;"	f	file:
dwNewAttrAddrSymbol	SDCCdwarf2.c	/^dwNewAttrAddrSymbol (int attr, symbol * sym, int offset)$/;"	f	file:
dwNewAttrConst	SDCCdwarf2.c	/^dwNewAttrConst (int attr, unsigned int data)$/;"	f	file:
dwNewAttrFlag	SDCCdwarf2.c	/^dwNewAttrFlag (int attr, int data)$/;"	f	file:
dwNewAttrLabelRef	SDCCdwarf2.c	/^dwNewAttrLabelRef (int attr, char * label, int offset)$/;"	f	file:
dwNewAttrLoc	SDCCdwarf2.c	/^dwNewAttrLoc (int attr, dwloc * lp)$/;"	f
dwNewAttrLocRef	SDCCdwarf2.c	/^dwNewAttrLocRef (int attr, dwloclist * llp)$/;"	f	file:
dwNewAttrString	SDCCdwarf2.c	/^dwNewAttrString (int attr, const char * string)$/;"	f	file:
dwNewAttrTagRef	SDCCdwarf2.c	/^dwNewAttrTagRef (int attr, dwtag * tp)$/;"	f	file:
dwNewDebugSymbol	SDCCdwarf2.c	/^dwNewDebugSymbol (void)$/;"	f	file:
dwNewLoc	SDCCdwarf2.c	/^dwNewLoc (int opcode, const char * label, int offset)$/;"	f
dwNewLocList	SDCCdwarf2.c	/^dwNewLocList (void)$/;"	f	file:
dwNewTag	SDCCdwarf2.c	/^dwNewTag (int tag)$/;"	f	file:
dwOpenFile	SDCCdwarf2.c	/^dwOpenFile(const char *file)$/;"	f
dwRefNum	SDCCdwarf2.c	/^int dwRefNum = 0;$/;"	v
dwRootLocList	SDCCdwarf2.c	/^dwloclist * dwRootLocList = NULL;$/;"	v
dwRootTag	SDCCdwarf2.c	/^dwtag *dwRootTag = NULL;$/;"	v
dwScopeBlock	SDCCdwarf2.c	/^int dwScopeBlock = 0;$/;"	v
dwScopeLevel	SDCCdwarf2.c	/^int dwScopeLevel = 0;$/;"	v
dwScopeTag	SDCCdwarf2.c	/^dwtag *dwScopeTag = NULL;$/;"	v
dwSetTagAttr	SDCCdwarf2.c	/^dwSetTagAttr (dwtag *tp, dwattr * ap)$/;"	f	file:
dwSizeofAttr	SDCCdwarf2.c	/^dwSizeofAttr (dwattr * ap)$/;"	f	file:
dwSizeofLoc	SDCCdwarf2.c	/^dwSizeofLoc (dwloc * lp)$/;"	f	file:
dwSizeofLocRegion	SDCCdwarf2.c	/^dwSizeofLocRegion (dwlocregion * lrp)$/;"	f	file:
dwSizeofSLEB128	SDCCdwarf2.c	/^dwSizeofSLEB128 (int value)$/;"	f	file:
dwSizeofULEB128	SDCCdwarf2.c	/^dwSizeofULEB128 (int unsigned value)$/;"	f	file:
dwTagFromType	SDCCdwarf2.c	/^dwTagFromType (sym_link * type, dwtag * parent)$/;"	f	file:
dwTraverseTag	SDCCdwarf2.c	/^dwTraverseTag (dwtag *tp, int (*somefunc)(dwtag *tp, void * info), void * info)$/;"	f	file:
dwTypeTagTable	SDCCdwarf2.c	/^hTab * dwTypeTagTable;$/;"	v
dwWriteALine	SDCCdwarf2.c	/^dwWriteALine(const char *module, int Line)$/;"	f
dwWriteAbbrevs	SDCCdwarf2.c	/^dwWriteAbbrevs (void)$/;"	f	file:
dwWriteAddress	SDCCdwarf2.c	/^dwWriteAddress (const char * label, int offset, char * comment)$/;"	f	file:
dwWriteAttr	SDCCdwarf2.c	/^dwWriteAttr (dwattr * ap)$/;"	f	file:
dwWriteByte	SDCCdwarf2.c	/^dwWriteByte (const char * label, int offset, const char * comment)$/;"	f	file:
dwWriteCLine	SDCCdwarf2.c	/^dwWriteCLine (iCode *ic)$/;"	f
dwWriteEndFunction	SDCCdwarf2.c	/^dwWriteEndFunction (symbol *sym, iCode *ic, int offset)$/;"	f
dwWriteFrameAddress	SDCCdwarf2.c	/^dwWriteFrameAddress(const char *variable, struct reg_info *reg, int offset)$/;"	f
dwWriteFunction	SDCCdwarf2.c	/^dwWriteFunction (symbol *sym, iCode *ic)$/;"	f
dwWriteHalf	SDCCdwarf2.c	/^dwWriteHalf (const char * label, int offset, char * comment)$/;"	f	file:
dwWriteHalfDelta	SDCCdwarf2.c	/^dwWriteHalfDelta (char * label1, char * label2, int offset)$/;"	f	file:
dwWriteLabel	SDCCdwarf2.c	/^dwWriteLabel (symbol *sym, iCode *ic)$/;"	f
dwWriteLineNumber	SDCCdwarf2.c	/^dwWriteLineNumber (dwline * lp)$/;"	f	file:
dwWriteLineNumbers	SDCCdwarf2.c	/^dwWriteLineNumbers (void)$/;"	f	file:
dwWriteLoc	SDCCdwarf2.c	/^dwWriteLoc (dwloc *lp)$/;"	f	file:
dwWriteLocLists	SDCCdwarf2.c	/^dwWriteLocLists (void)$/;"	f	file:
dwWriteModule	SDCCdwarf2.c	/^dwWriteModule (const char *name)$/;"	f
dwWritePubnames	SDCCdwarf2.c	/^dwWritePubnames (void)$/;"	f	file:
dwWriteSLEB128	SDCCdwarf2.c	/^dwWriteSLEB128 (char * label, int offset, char * comment)$/;"	f	file:
dwWriteScope	SDCCdwarf2.c	/^dwWriteScope (iCode *ic)$/;"	f
dwWriteString	SDCCdwarf2.c	/^dwWriteString (const char * string, const char * comment)$/;"	f	file:
dwWriteSymbol	SDCCdwarf2.c	/^dwWriteSymbol (symbol *sym)$/;"	f
dwWriteSymbolInternal	SDCCdwarf2.c	/^dwWriteSymbolInternal (symbol *sym)$/;"	f	file:
dwWriteTag	SDCCdwarf2.c	/^dwWriteTag (dwtag *tp, void *info)$/;"	f	file:
dwWriteTags	SDCCdwarf2.c	/^dwWriteTags (void)$/;"	f	file:
dwWriteType	SDCCdwarf2.c	/^dwWriteType (structdef *sdef, int block, int inStruct, const char *tag)$/;"	f
dwWriteULEB128	SDCCdwarf2.c	/^dwWriteULEB128 (char * label, int offset, char * comment)$/;"	f	file:
dwWriteWord	SDCCdwarf2.c	/^dwWriteWord (const char * label, int offset, char * comment)$/;"	f	file:
dwWriteWordDelta	SDCCdwarf2.c	/^dwWriteWordDelta (char * label1, char * label2)$/;"	f	file:
dwarf	port.h	/^    dwarf;$/;"	m
dwarf2DebugFile	SDCCdwarf2.c	/^DEBUGFILE dwarf2DebugFile = $/;"	v
dwarf2FilePtr	SDCCdwarf2.c	/^FILE *dwarf2FilePtr = NULL;$/;"	v
dwarf2FinalizeFile	SDCCdwarf2.c	/^dwarf2FinalizeFile (FILE *of)$/;"	f
dwattr	SDCCdwarf2.h	/^typedef struct dwattr$/;"	s
dwattr	SDCCdwarf2.h	/^} dwattr;$/;"	t
dwfile	SDCCdwarf2.h	/^typedef struct dwfile$/;"	s
dwfile	SDCCdwarf2.h	/^} dwfile;$/;"	t
dwline	SDCCdwarf2.h	/^typedef struct dwline$/;"	s
dwline	SDCCdwarf2.h	/^} dwline;$/;"	t
dwloc	SDCCdwarf2.h	/^typedef struct dwloc$/;"	s
dwloc	SDCCdwarf2.h	/^} dwloc;$/;"	t
dwloclist	SDCCdwarf2.h	/^typedef struct dwloclist$/;"	s
dwloclist	SDCCdwarf2.h	/^} dwloclist;$/;"	t
dwlocregion	SDCCdwarf2.h	/^typedef struct dwlocregion$/;"	s
dwlocregion	SDCCdwarf2.h	/^} dwlocregion;$/;"	t
dwtag	SDCCdwarf2.h	/^typedef struct dwtag$/;"	s
dwtag	SDCCdwarf2.h	/^} dwtag;$/;"	t
eBBNum	SDCCBBlock.c	/^int eBBNum = 0;$/;"	v
eBBPredecessors	SDCCcflow.c	/^eBBPredecessors (ebbIndex * ebbi)$/;"	f	file:
eBBSuccessors	SDCCcflow.c	/^eBBSuccessors (ebbIndex * ebbi)$/;"	f	file:
eBBWithEntryLabel	SDCCBBlock.c	/^eBBWithEntryLabel (ebbIndex * ebbi, symbol * eLabel)$/;"	f
eBBlock	SDCCBBlock.h	/^eBBlock;$/;"	t
eBBlock	SDCCBBlock.h	/^typedef struct eBBlock$/;"	s
eBBlockFromiCode	SDCCopt.c	/^eBBlockFromiCode (iCode * ic)$/;"	f
eBBlockNum	SDCCicode.h	/^  int eBBlockNum;               \/* belongs to which eBBlock *\/$/;"	m	struct:iCode
ebbIndex	SDCCBBlock.h	/^ebbIndex;$/;"	t
ebbIndex	SDCCBBlock.h	/^typedef struct ebbIndex$/;"	s
ech	SDCCBBlock.h	/^  iCode *ech;                   \/* pointer to last of code chain  *\/$/;"	m	struct:eBBlock
edge	SDCCBBlock.h	/^edge;$/;"	t
edge	SDCCBBlock.h	/^typedef struct edge$/;"	s
edgesTo	SDCCBBlock.c	/^edgesTo (eBBlock * to)$/;"	f
eeprom	SDCCmem.c	/^memmap *eeprom = NULL;          \/* eeprom location             *\/$/;"	v
elementsInSet	SDCCset.c	/^elementsInSet (set * s)$/;"	f
elemno	SDCCval.h	/^        int elemno;                     \/* array element (constant expr)  *\/$/;"	m	union:designation::<anonymous>
emitDebugSym	SDCCglue.c	/^emitDebugSym (struct dbuf_s *oBuf, symbol * sym)$/;"	f	file:
emitDebuggerSymbol	SDCCdebug.c	/^emitDebuggerSymbol (const char * debugSym)$/;"	f
emitDebuggerSymbol	port.h	/^    void (*emitDebuggerSymbol) (const char *);$/;"	m
emitLabel	SDCCgen.c	/^emitLabel (symbol * tlbl)$/;"	f
emitMaps	SDCCglue.c	/^emitMaps (void)$/;"	f
emitOverlay	SDCCglue.c	/^emitOverlay (struct dbuf_s *aBuf)$/;"	f	file:
emitRegularMap	SDCCglue.c	/^emitRegularMap (memmap * map, bool addPublics, bool arFlag)$/;"	f	file:
emitStaticSeg	SDCCglue.c	/^emitStaticSeg (memmap * map, struct dbuf_s *oBuf)$/;"	f
emit_raw	SDCCgen.c	/^emit_raw (const char *line)$/;"	f
emitcode	SDCCgen.c	/^emitcode (const char *inst, const char *fmt, ...)$/;"	f
endLabel	SDCCdwarf2.h	/^  char * endLabel;$/;"	m	struct:dwlocregion
end_of_file	altlex.c	/^static int end_of_file;$/;"	v	file:
end_sequence	SDCCdwarf2.h	/^  unsigned end_sequence:1;$/;"	m	struct:dwline
entry	SDCCloop.h	/^    eBBlock *entry;		\/* entry Block *\/$/;"	m	struct:region
entryLabel	SDCCBBlock.h	/^  symbol *entryLabel;           \/* entry label *\/$/;"	m	struct:eBBlock
entryLabel	SDCCicode.c	/^symbol *entryLabel;             \/* function entry  label *\/$/;"	v
enumTab	SDCCsymt.c	/^bucket *enumTab[256];           \/* enumerated    table  *\/$/;"	v
eq_nne	port.h	/^  bool eq_nne;                  \/* transform a == b --> ! (a != b)  *\/$/;"	m
errIndex	SDCCerr.c	/^  int errIndex;$/;"	m	file:
errText	SDCCerr.c	/^  const char *errText;$/;"	m	file:
errType	SDCCerr.c	/^  ERROR_LOG_LEVEL errType;$/;"	m	file:
error	altlex.c	/^error (const char *sz,...)$/;"	f	file:
etype	SDCCast.h	/^  sym_link *etype;              \/* end of type chain for this subtree   *\/$/;"	m	struct:ast
etype	SDCCsymt.h	/^  struct sym_link *etype;           \/* last link to declarator chain *\/$/;"	m	struct:symbol
etype	SDCCval.h	/^  sym_link *etype;              \/* end of type chain                *\/$/;"	m	struct:value
eval_macros	SDCCmacro.c	/^eval_macros (hTab * pvals, const char *pfrom)$/;"	f
excludeRegsSet	SDCCglobl.h	/^    set *excludeRegsSet;        \/* registers excluded from saving *\/$/;"	m	struct:options
exits	SDCCloop.h	/^    set *exits;			\/* set of exits *\/$/;"	m	struct:region
expandInlineFuncs	SDCCast.c	/^expandInlineFuncs (ast * tree, ast * block)$/;"	f	file:
expandInlineFuncsInDeclarators	SDCCast.c	/^expandInlineFuncsInDeclarators (struct initList *ival, ast * block)$/;"	f	file:
ext	SDCCglobl.h	/^  char *ext;$/;"	m	struct:_dumpFiles
externGlobal	port.h	/^    int externGlobal;$/;"	m
externs	SDCCglue.c	/^set *externs = NULL;            \/* Variables that are declared as extern *\/$/;"	v
extraAreas	port.h	/^  extraAreas;$/;"	m
fSeq	SDCCBBlock.h	/^  int fSeq;                     \/* sequence number of first iCode *\/$/;"	m	struct:eBBlock
falseLabel	SDCCast.h	/^      symbol *falseLabel;       \/* exit point            *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
falseLabel	SDCCast.h	/^  symbol *falseLabel;           \/* if statement falseLabel *\/$/;"	m	struct:ast
falseLabel	SDCCicode.h	/^      symbol *falseLabel;       \/* false for conditional    *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
fatal	SDCCerr.c	/^fatal (int exitCode, int errNum, ...)$/;"	f
fatalError	SDCCmem.c	/^int fatalError = 0;             \/* fatal error flag            *\/$/;"	v
fields	SDCCsymt.h	/^  struct symbol *fields;        \/* pointer to fields          *\/$/;"	m	struct:structdef
fileDef	SDCCsymt.h	/^  char *fileDef;                    \/* defined filename           *\/$/;"	m	struct:symbol
fileIndex	SDCCdwarf2.h	/^  int fileIndex;$/;"	m	struct:dwline
filePtr	SDCCglobl.h	/^  FILE *filePtr;$/;"	m	struct:_dumpFiles
file_ext	port.h	/^    const char *file_ext;$/;"	m
filename	SDCCast.h	/^  char *filename;               \/* filename of the source file *\/$/;"	m	struct:ast
filename	SDCCicode.c	/^char *filename;                 \/* current file name *\/$/;"	v
filename	SDCCicode.h	/^  char *filename;$/;"	m	struct:iCode
filename	SDCCval.h	/^    char *filename;$/;"	m	struct:designation
filename	SDCCval.h	/^  char *filename;$/;"	m	struct:initList
finaliseOptions	port.h	/^  void (*finaliseOptions) (void);$/;"	m
finalizeOptions	SDCCmain.c	/^finalizeOptions (void)$/;"	f	file:
finalizeSpec	SDCCsymt.c	/^finalizeSpec (sym_link * lnk)$/;"	f
findBackwardDef	SDCCcse.c	/^iCode *findBackwardDef(operand *op,iCode *ic)$/;"	f
findCheaperOp	SDCCcse.h	/^DEFSETFUNC (findCheaperOp);$/;"	v
findDefInRegion	SDCCloop.c	/^findDefInRegion (set * regBlocks, operand * defOp, eBBlock ** owner)$/;"	f	file:
findNextUse	SDCClrange.c	/^findNextUse (eBBlock *ebp, iCode *ic, operand *op)$/;"	f	file:
findNextUseSym	SDCClrange.c	/^findNextUseSym (eBBlock *ebp, iCode *ic, symbol * sym)$/;"	f	file:
findPointerGetSet	SDCCptropt.c	/^findPointerGetSet (iCode * sic, operand * op)$/;"	f	file:
findPrevIc	SDCCcse.h	/^DEFSETFUNC (findPrevIc);$/;"	v
findPrevUse	SDCClrange.c	/^findPrevUse (eBBlock *ebp, iCode *ic, operand *op,$/;"	f	file:
findPrevUseSym	SDCClrange.c	/^findPrevUseSym  (eBBlock *ebp, iCode *ic, symbol * sym)$/;"	f	file:
findReqv	SDCCopt.c	/^findReqv (symbol * prereqv, eBBlock ** ebbs, int count)$/;"	f
findStructField	SDCCast.c	/^findStructField (symbol *fields, symbol *target)$/;"	f	file:
findStructField	SDCCval.c	/^findStructField (symbol *fields, symbol *target)$/;"	f	file:
findSym	SDCCsymt.c	/^findSym (bucket ** stab, void *sym, const char *sname)$/;"	f
findSymWithBlock	SDCCsymt.c	/^findSymWithBlock (bucket ** stab, symbol * sym, int block)$/;"	f
findSymWithLevel	SDCCsymt.c	/^findSymWithLevel (bucket ** stab, symbol * sym)$/;"	f
firstChild	SDCCdwarf2.h	/^  struct dwtag * firstChild;$/;"	m	struct:dwtag
fixUpTypes	SDCCcse.c	/^fixUpTypes (iCode * ic)$/;"	f	file:
fixed16x16FromDouble	SDCCval.c	/^fixed16x16FromDouble (double value)$/;"	f
fixed16x16Type	SDCCsymt.c	/^sym_link *fixed16x16Type;$/;"	v
fixupInline	SDCCast.c	/^fixupInline (ast * tree, int level)$/;"	f	file:
fixupInlineInDeclarators	SDCCast.c	/^fixupInlineInDeclarators (struct initList *ival, int level)$/;"	f	file:
fixupInlineLabel	SDCCast.c	/^fixupInlineLabel (symbol * sym)$/;"	f	file:
flexArrayLength	SDCCsymt.h	/^  unsigned flexArrayLength;         \/* if the symbol specifies a struct$/;"	m	struct:symbol
floatFromVal	SDCCval.c	/^floatFromVal (value * val)$/;"	f
floatType	SDCCsymt.c	/^sym_link *floatType;$/;"	v
float_rent	SDCCglobl.h	/^    int float_rent;             \/* floating point routines are reentrant *\/$/;"	m	struct:options
float_size	port.h	/^    int float_size;$/;"	m
flowChanged	SDCCopt.c	/^char flowChanged = 0;$/;"	v
flushStatics	SDCCglue.c	/^flushStatics (void)$/;"	f
fmap	SDCCmem.h	/^    unsigned fmap:1;            \/* 1 = 16bit addressing reqd   *\/$/;"	m	struct:memmap
fname	SDCCpeeph.c	/^  char *fname;$/;"	m	struct:ftab	file:
for	SDCC.y	/^for : FOR { \/* create & push continue, break & body labels *\/$/;"	l
forVals	SDCCast.h	/^    forVals;$/;"	m	union:ast::<anonymous>
for_newralloc	SDCCsymt.h	/^  bool for_newralloc;$/;"	m	struct:symbol
form	SDCCdwarf2.h	/^  int form;$/;"	m	struct:dwattr
format_opcode	SDCCgen.c	/^format_opcode (const char *inst, const char *fmt, va_list ap)$/;"	f
fp16x16conv	SDCCsymt.c	/^symbol *fp16x16conv[2][5][2];$/;"	v
fps16x16_add	SDCCsymt.c	/^symbol *fps16x16_add;$/;"	v
fps16x16_div	SDCCsymt.c	/^symbol *fps16x16_div;$/;"	v
fps16x16_eq	SDCCsymt.c	/^symbol *fps16x16_eq;$/;"	v
fps16x16_gt	SDCCsymt.c	/^symbol *fps16x16_gt;$/;"	v
fps16x16_gteq	SDCCsymt.c	/^symbol *fps16x16_gteq;$/;"	v
fps16x16_lt	SDCCsymt.c	/^symbol *fps16x16_lt;$/;"	v
fps16x16_lteq	SDCCsymt.c	/^symbol *fps16x16_lteq;$/;"	v
fps16x16_mul	SDCCsymt.c	/^symbol *fps16x16_mul;$/;"	v
fps16x16_neq	SDCCsymt.c	/^symbol *fps16x16_neq;$/;"	v
fps16x16_sub	SDCCsymt.c	/^symbol *fps16x16_sub;$/;"	v
fptr_size	port.h	/^    int fptr_size;              \/\/far$/;"	m
fputStrSet	SDCCutil.c	/^fputStrSet (FILE * fp, set * list)$/;"	f
freeBitVect	SDCCbitv.c	/^freeBitVect (bitVect * bvp)$/;"	f
freeStringSymbol	SDCCast.c	/^freeStringSymbol (symbol * sym)$/;"	f
free_pragma_token	SDCCutil.c	/^free_pragma_token (struct pragma_token_s *token)$/;"	f
from	SDCCBBlock.h	/^  eBBlock *from;                \/* from basic block *\/$/;"	m	struct:edge
fromAddrTaken	SDCCcse.h	/^    int fromAddrTaken:1;	\/* defining symbol's value computed from a *\/$/;"	m	struct:cseDef
fromGlobal	SDCCcse.h	/^    int fromGlobal;		\/* defining symbol's value computed from a global *\/$/;"	m	struct:cseDef
fsadd	SDCCsymt.c	/^symbol *fsadd;$/;"	v
fsdiv	SDCCsymt.c	/^symbol *fsdiv;$/;"	v
fseq	SDCCsymt.c	/^symbol *fseq;$/;"	v
fsgt	SDCCsymt.c	/^symbol *fsgt;$/;"	v
fsgteq	SDCCsymt.c	/^symbol *fsgteq;$/;"	v
fslt	SDCCsymt.c	/^symbol *fslt;$/;"	v
fslteq	SDCCsymt.c	/^symbol *fslteq;$/;"	v
fsmul	SDCCsymt.c	/^symbol *fsmul;$/;"	v
fsneq	SDCCsymt.c	/^symbol *fsneq;$/;"	v
fssub	SDCCsymt.c	/^symbol *fssub;$/;"	v
ftab	SDCCpeeph.c	/^ftab[] =                                            \/\/ sorted on the number of times used$/;"	v	file:
ftab	SDCCpeeph.c	/^static const struct ftab$/;"	s	file:
ftype	SDCCast.h	/^  sym_link *ftype;              \/* start of type chain for this subtree *\/$/;"	m	struct:ast
fullDstFileName	SDCCmain.c	/^const char *fullDstFileName;    \/* full name for the output file; *\/$/;"	v
fullSrcFileName	SDCCmain.c	/^const char *fullSrcFileName;    \/* full name for the source file; *\/$/;"	v
fun_prefix	port.h	/^  const char *fun_prefix;$/;"	m
func	SDCCpeeph.c	/^  int (*func) (hTab *, lineNode *, lineNode *, lineNode *, char *);$/;"	m	struct:ftab	file:
func	port.h	/^  int (*func) (int id, const char *name, const char *cp);$/;"	m	struct:pragma_s
funcAttrs	SDCCsymt.h	/^  } funcAttrs;$/;"	m	struct:sym_link
funcInChain	SDCCsymt.c	/^funcInChain (sym_link * lnk)$/;"	f
funcName	SDCCast.h	/^  unsigned funcName:1;$/;"	m	struct:ast
funcOfType	SDCCast.c	/^funcOfType (const char *name, sym_link * type, sym_link * argType, int nArgs, int rent)$/;"	f
funcOfTypeVarg	SDCCast.c	/^funcOfTypeVarg (const char *name, const char *rtype, int nArgs, const char **atypes)$/;"	f
funcTree	SDCCsymt.h	/^  struct ast *funcTree;             \/* function body ast if inlined *\/$/;"	m	struct:symbol
funcs	SDCCglobl.h	/^    char *funcs[128];   \/* function name that belong to this *\/$/;"	m
fuse	SDCCsymt.h	/^  struct iCode *fuse;               \/* furthest use *\/$/;"	m	struct:symbol
gatherAutoInit	SDCCast.c	/^gatherAutoInit (symbol * autoChain)$/;"	f	file:
gatherImplicitVariables	SDCCast.c	/^gatherImplicitVariables (ast * tree, ast * block)$/;"	f
ge_nlt	port.h	/^  bool ge_nlt;                  \/* transform (a >= b) to !(a < b)   *\/$/;"	m
genAssemblerEnd	port.h	/^  void (*genAssemblerEnd) (FILE * of);$/;"	m
genAssemblerPreamble	port.h	/^  void (*genAssemblerPreamble) (FILE * of);$/;"	m
genExtraAreaDeclaration	port.h	/^    void (*genExtraAreaDeclaration) (FILE *, bool);$/;"	m
genExtraAreaLinkOptions	port.h	/^    void (*genExtraAreaLinkOptions) (FILE *);$/;"	m
genIVT	port.h	/^  int (*genIVT) (struct dbuf_s * oBuf, symbol ** intTable, int intCount);$/;"	m
genInitStartup	port.h	/^  void (*genInitStartup) (FILE * of);$/;"	m
genInline	SDCCgen.c	/^genInline (iCode * ic)$/;"	f
genLine	SDCCgen.c	/^genLine_t genLine;$/;"	v
genLine_s	SDCCgen.h	/^typedef struct genLine_s$/;"	s
genLine_t	SDCCgen.h	/^} genLine_t;$/;"	t
genSymName	SDCCsymt.c	/^genSymName (int level)$/;"	f
genXINIT	port.h	/^  void (*genXINIT) (FILE * of);$/;"	m
general	port.h	/^  general;$/;"	m
generated	SDCCicode.h	/^  unsigned generated:1;         \/* code generated for this one *\/$/;"	m	struct:iCode
generated	SDCCsymt.h	/^  unsigned generated:1;             \/* code generated (function symbols only) *\/$/;"	m	struct:symbol
generic	SDCCmem.c	/^memmap *generic = NULL;         \/* is a generic pointer        *\/$/;"	v
geniCodeAdd	SDCCicode.c	/^geniCodeAdd (operand * left, operand * right, RESULT_TYPE resultType, int lvl)$/;"	f	file:
geniCodeAddressOf	SDCCicode.c	/^geniCodeAddressOf (operand * op)$/;"	f
geniCodeArray	SDCCicode.c	/^geniCodeArray (operand * left, operand * right, int lvl)$/;"	f	file:
geniCodeArray2Ptr	SDCCicode.c	/^geniCodeArray2Ptr (operand * op)$/;"	f	file:
geniCodeArrayInit	SDCCicode.c	/^geniCodeArrayInit (ast * tree, operand * array)$/;"	f	file:
geniCodeAssign	SDCCicode.c	/^geniCodeAssign (operand * left, operand * right, int nosupdate, int strictLval)$/;"	f
geniCodeBinary	SDCCicode.c	/^geniCodeBinary (operand * left, operand * right, int oper, sym_link * resType)$/;"	f
geniCodeBitwise	SDCCicode.c	/^geniCodeBitwise (operand * left, operand * right, int oper, sym_link * resType)$/;"	f
geniCodeCall	SDCCicode.c	/^geniCodeCall (operand * left, ast * parms, int lvl)$/;"	f
geniCodeCast	SDCCicode.c	/^geniCodeCast (sym_link *type, operand *op, bool implicit)$/;"	f	file:
geniCodeConditional	SDCCicode.c	/^geniCodeConditional (ast * tree, int lvl)$/;"	f
geniCodeCritical	SDCCicode.c	/^geniCodeCritical (ast * tree, int lvl)$/;"	f	file:
geniCodeDerefPtr	SDCCicode.c	/^geniCodeDerefPtr (operand * op, int lvl)$/;"	f
geniCodeDivision	SDCCicode.c	/^geniCodeDivision (operand *left, operand *right, RESULT_TYPE resultType)$/;"	f	file:
geniCodeDummyRead	SDCCicode.c	/^geniCodeDummyRead (operand * op)$/;"	f	file:
geniCodeFunctionBody	SDCCicode.c	/^geniCodeFunctionBody (ast * tree, int lvl)$/;"	f
geniCodeGoto	SDCCicode.c	/^geniCodeGoto (symbol * label)$/;"	f
geniCodeIfx	SDCCicode.c	/^geniCodeIfx (ast * tree, int lvl)$/;"	f
geniCodeInline	SDCCicode.c	/^geniCodeInline (ast * tree)$/;"	f	file:
geniCodeJumpTable	SDCCicode.c	/^geniCodeJumpTable (operand * cond, value * caseVals, ast * tree)$/;"	f
geniCodeLabel	SDCCicode.c	/^geniCodeLabel (symbol * label)$/;"	f
geniCodeLeftShift	SDCCicode.c	/^geniCodeLeftShift (operand * left, operand * right, RESULT_TYPE resultType)$/;"	f
geniCodeLogic	SDCCicode.c	/^geniCodeLogic (operand * left, operand * right, int op, ast * tree)$/;"	f	file:
geniCodeLogicAndOr	SDCCicode.c	/^geniCodeLogicAndOr (ast * tree, int lvl)$/;"	f	file:
geniCodeModulus	SDCCicode.c	/^geniCodeModulus (operand * left, operand * right, RESULT_TYPE resultType)$/;"	f	file:
geniCodeMultiply	SDCCicode.c	/^geniCodeMultiply (operand * left, operand * right, RESULT_TYPE resultType)$/;"	f	file:
geniCodeParms	SDCCicode.c	/^geniCodeParms (ast * parms, value * argVals, int *iArg, int *stack, sym_link * ftype, int lvl)$/;"	f
geniCodePostDec	SDCCicode.c	/^geniCodePostDec (operand * op)$/;"	f
geniCodePostInc	SDCCicode.c	/^geniCodePostInc (operand * op)$/;"	f
geniCodePreDec	SDCCicode.c	/^geniCodePreDec (operand * op, bool lvalue)$/;"	f
geniCodePreInc	SDCCicode.c	/^geniCodePreInc (operand * op, bool lvalue)$/;"	f
geniCodePtrPtrSubtract	SDCCicode.c	/^geniCodePtrPtrSubtract (operand * left, operand * right)$/;"	f
geniCodeRValue	SDCCicode.c	/^geniCodeRValue (operand * op, bool force)$/;"	f
geniCodeReceive	SDCCicode.c	/^geniCodeReceive (value * args, operand * func)$/;"	f	file:
geniCodeReturn	SDCCicode.c	/^geniCodeReturn (operand * op)$/;"	f
geniCodeRightShift	SDCCicode.c	/^geniCodeRightShift (operand * left, operand * right)$/;"	f
geniCodeSEParms	SDCCicode.c	/^geniCodeSEParms (ast * parms, int lvl)$/;"	f	file:
geniCodeStruct	SDCCicode.c	/^geniCodeStruct (operand * left, operand * right, bool islval)$/;"	f
geniCodeSubtract	SDCCicode.c	/^geniCodeSubtract (operand * left, operand * right, RESULT_TYPE resultType)$/;"	f	file:
geniCodeSwitch	SDCCicode.c	/^geniCodeSwitch (ast * tree, int lvl)$/;"	f
geniCodeUnary	SDCCicode.c	/^geniCodeUnary (operand * op, int oper, sym_link * resType)$/;"	f
geniCodeUnaryMinus	SDCCicode.c	/^geniCodeUnaryMinus (operand * op)$/;"	f
getAddrspace	SDCCsymt.c	/^getAddrspace (sym_link *type)$/;"	f
getAddrspaceiCode	SDCCopt.c	/^getAddrspaceiCode (const iCode *ic)$/;"	f
getArraySizePtr	SDCCicode.c	/^getArraySizePtr (operand * op)$/;"	f	file:
getBinPath	SDCCutil.c	/^getBinPath (const char *prel)$/;"	f
getBuildDate	SDCCutil.c	/^getBuildDate (void)$/;"	f
getBuildEnvironment	SDCCutil.c	/^getBuildEnvironment (void)$/;"	f
getBuildNumber	SDCCutil.c	/^getBuildNumber (void)$/;"	f
getBuiltinParms	SDCCicode.c	/^getBuiltinParms (iCode * fic, int *pcount, operand ** parms)$/;"	f
getIntArg	SDCCmain.c	/^getIntArg (const char *szStart, char **argv, int *pi, int argc)$/;"	f
getLabelRef	SDCCpeeph.c	/^getLabelRef (const char *label, lineNode *head)$/;"	f
getLeftResultType	SDCCast.c	/^getLeftResultType (ast * tree, RESULT_TYPE resultType)$/;"	f	file:
getMangledFunctionName	port.h	/^  const char *(*getMangledFunctionName) (const char *szOrginial);$/;"	m
getNelements	SDCCval.c	/^getNelements (sym_link * type, initList * ilist)$/;"	f
getOutFmtExt	SDCCmain.c	/^getOutFmtExt (void)$/;"	f	file:
getPatternVar	SDCCpeeph.c	/^getPatternVar (hTab *vars, char **cmdLine)$/;"	f	file:
getPeepLine	SDCCpeeph.c	/^getPeepLine (lineNode ** head, char **bpp)$/;"	f	file:
getRegName	port.h	/^  const char *(*getRegName) (const struct reg_info *reg);$/;"	m
getRegsRead	port.h	/^    bitVect *(*getRegsRead) (lineNode * line);$/;"	m
getRegsWritten	port.h	/^    bitVect *(*getRegsWritten) (lineNode * line);$/;"	m
getResultTypeFromType	SDCCast.c	/^getResultTypeFromType (sym_link * type)$/;"	f
getRuntimeVariables	SDCCutil.c	/^getRuntimeVariables (void)$/;"	f
getSet	SDCCset.c	/^getSet (set ** list)$/;"	f
getSize	SDCCsymt.c	/^getSize (sym_link * p)$/;"	f
getSize	port.h	/^    int (*getSize) (lineNode * line);$/;"	m
getSpec	SDCCsymt.c	/^getSpec (sym_link * p)$/;"	f
getStringArg	SDCCmain.c	/^getStringArg (const char *szStart, char **argv, int *pi, int argc)$/;"	f
getStructElement	SDCCsymt.c	/^getStructElement (structdef * sdef, symbol * sym)$/;"	f
getTableEntry	SDCCicode.c	/^getTableEntry (int oper)$/;"	f
get_model	port.h	/^    const char *(*get_model) (void);$/;"	m
get_path	SDCCsystem.c	/^get_path (const char *cmd)$/;"	f	file:
get_pragma_string	SDCCutil.c	/^get_pragma_string (struct pragma_token_s *token)$/;"	f
get_pragma_token	SDCCutil.c	/^get_pragma_token (const char *s, struct pragma_token_s *token)$/;"	f
global_cse	SDCCglobl.h	/^    int global_cse;$/;"	m	struct:optimize
globals_allowed	port.h	/^  int globals_allowed;          \/* global & static locals not allowed ?  0 ONLY TININative *\/$/;"	m
glue	SDCCglue.c	/^glue (void)$/;"	f
glue_up_main	port.h	/^    bool glue_up_main;$/;"	m
gp_tags	port.h	/^  gp_tags;$/;"	m
gptr_size	port.h	/^    int gptr_size;              \/\/generic$/;"	m
graphEdges	SDCCBBlock.c	/^set *graphEdges = NULL;         \/* list of edges in this flow graph *\/$/;"	v
gt_nle	port.h	/^  bool gt_nle;                  \/* transform (a > b)  to !(a <= b)  *\/$/;"	m
hTab	SDCChasht.h	/^hTab;$/;"	t
hTab	SDCChasht.h	/^typedef struct hTab$/;"	s
hTabAddItem	SDCChasht.c	/^hTabAddItem (hTab ** htab, int key, void *item)$/;"	f
hTabAddItemIfNotP	SDCChasht.c	/^hTabAddItemIfNotP (hTab ** htab, int key, void *item)$/;"	f
hTabAddItemLong	SDCChasht.c	/^hTabAddItemLong (hTab ** htab, int key, void *pkey, void *item)$/;"	f
hTabClearAll	SDCChasht.c	/^hTabClearAll (hTab * htab)$/;"	f
hTabDeleteAll	SDCChasht.c	/^hTabDeleteAll (hTab * p)$/;"	f
hTabDeleteByKey	SDCChasht.c	/^hTabDeleteByKey (hTab ** h, int key, const void *pkey, int (*compare) (const void *, const void *))$/;"	f
hTabDeleteItem	SDCChasht.c	/^hTabDeleteItem (hTab ** htab, int key,$/;"	f
hTabFindByKey	SDCChasht.c	/^hTabFindByKey (hTab * h, int key, const void *pkey, int (*compare) (const void *, const void *))$/;"	f
hTabFirstItem	SDCChasht.c	/^hTabFirstItem (hTab * htab, int *k)$/;"	f
hTabFirstItemWK	SDCChasht.c	/^hTabFirstItemWK (hTab * htab, int wk)$/;"	f
hTabFromTable	SDCChasht.c	/^hTabFromTable (hTab * htab)$/;"	f
hTabIsInTable	SDCChasht.c	/^hTabIsInTable (hTab * htab, int key,$/;"	f
hTabItemWithKey	SDCChasht.c	/^hTabItemWithKey (hTab * htab, int key)$/;"	f
hTabMaxKey	SDCChasht.c	/^int hTabMaxKey (hTab *htab)$/;"	f
hTabNextItem	SDCChasht.c	/^hTabNextItem (hTab * htab, int *k)$/;"	f
hTabNextItemWK	SDCChasht.c	/^hTabNextItemWK (hTab * htab)$/;"	f
hTabSearch	SDCChasht.c	/^hTabSearch (hTab * htab, int key)$/;"	f
handle_line	altlex.c	/^handle_line (void)$/;"	f	file:
handle_pragma	altlex.c	/^handle_pragma (void)$/;"	f	file:
hasExtBitOp	port.h	/^  bool (*hasExtBitOp) (int op, int size);$/;"	m
hasFcall	SDCCBBlock.h	/^  unsigned int hasFcall:1;      \/* has a function call *\/$/;"	m	struct:eBBlock
hasFcall	SDCCsymt.h	/^    unsigned hasFcall:1;            \/* does it call other functions         *\/$/;"	m	struct:sym_link::<anonymous>
hasNativeMulFor	port.h	/^  bool (*hasNativeMulFor) (iCode * ic, sym_link * left, sym_link * right);$/;"	m
hasSEFcalls	SDCCast.c	/^hasSEFcalls (ast * tree)$/;"	f
hasStackParms	SDCCsymt.h	/^    unsigned hasStackParms;         \/* function has parameters on stack     *\/$/;"	m	struct:sym_link::<anonymous>
hasVargs	SDCCsymt.h	/^    unsigned hasVargs:1;            \/* functions has varargs                *\/$/;"	m	struct:sym_link::<anonymous>
has_path	SDCCsystem.c	/^has_path (const char *path)$/;"	f	file:
hasbody	SDCCsymt.h	/^    unsigned hasbody:1;             \/* function body defined                *\/$/;"	m	struct:sym_link::<anonymous>
hashKey	SDCCsymt.c	/^hashKey (const char *s)$/;"	f
hashSymbolName	SDCCpeeph.c	/^hashSymbolName (const char *name)$/;"	f	file:
hashiCodeKeys	SDCClrange.c	/^hashiCodeKeys (eBBlock ** ebbs, int count)$/;"	f
hashtItem	SDCChasht.h	/^hashtItem;$/;"	t
hashtItem	SDCChasht.h	/^typedef struct hashtItem$/;"	s
help	SDCCargs.h	/^    const char *help;$/;"	m
hexEscape	SDCCutil.c	/^hexEscape (const char **src)$/;"	f
home	SDCCmem.c	/^memmap *home = NULL;            \/* Unswitchable code bank      *\/$/;"	v
home_name	port.h	/^    const char *const home_name;$/;"	m
iCode	SDCCicode.h	/^iCode;$/;"	t
iCode	SDCCicode.h	/^typedef struct iCode$/;"	s
iCode2eBBlock	SDCCBBlock.c	/^iCode2eBBlock (iCode * ic)$/;"	f
iCodeBreakDown	SDCCBBlock.c	/^iCodeBreakDown (iCode * ic)$/;"	f
iCodeChain	SDCCicode.c	/^set *iCodeChain = NULL;$/;"	v
iCodeCopy	SDCCicode.h	/^  iCode *(*iCodeCopy) (iCode *);$/;"	m	struct:icodeFuncTable
iCodeFromAst	SDCCicode.c	/^iCodeFromAst (ast * tree)$/;"	f
iCodeFromeBBlock	SDCCBBlock.c	/^iCodeFromeBBlock (eBBlock ** ebbs, int count)$/;"	f
iCodeInAsm	SDCCglobl.h	/^    int iCodeInAsm;             \/* show i-code in asm *\/$/;"	m	struct:options
iCodeKey	SDCCicode.c	/^int iCodeKey = 0;$/;"	v
iCodeLabelOptimize	SDCClabel.c	/^iCodeLabelOptimize (iCode * ic)$/;"	f
iCodePrint	SDCCicode.h	/^  void (*iCodePrint) (struct dbuf_s *, iCode *, char *);$/;"	m	struct:icodeFuncTable
iCodeSeq	SDCClrange.c	/^int iCodeSeq = 0;$/;"	v
iCodeSeqhTab	SDCClrange.c	/^hTab *iCodeSeqhTab = NULL;$/;"	v
iCodeTable	SDCCicode.h	/^iCodeTable;$/;"	t
iCodehTab	SDCClrange.c	/^hTab *iCodehTab = NULL;$/;"	v
iComments1	SDCCglue.c	/^char *iComments1 = {$/;"	v
iComments2	SDCCglue.c	/^char *iComments2 = {$/;"	v
iTempLblNum	SDCCicode.c	/^int iTempLblNum = 0;$/;"	v
iTempNum	SDCCicode.c	/^int iTempNum = 0;$/;"	v
i_abs	SDCCmem.c	/^memmap *i_abs = NULL;           \/* absolute idata upto 256     *\/$/;"	v
iabs_name	port.h	/^    const char *const iabs_name;        \/\/ absolute idata\/data$/;"	m
iaccess	SDCCsymt.h	/^  unsigned iaccess:1;               \/* indirect access      *\/$/;"	m	struct:symbol
ic	SDCCgen.h	/^  iCode *ic;$/;"	m	struct:lineElem_s
ic	SDCCloop.h	/^    iCode *ic;$/;"	m	struct:induction
icode	SDCCicode.h	/^  int icode;$/;"	m	struct:icodeFuncTable
icodeFuncTable	SDCCicode.h	/^typedef struct icodeFuncTable$/;"	s
id	SDCCglobl.h	/^  int id;$/;"	m	struct:_dumpFiles
id	port.h	/^  const int id;$/;"	m
id	port.h	/^  int id;$/;"	m	struct:pragma_s
idata	SDCCmem.c	/^memmap *idata = NULL;           \/* internal data upto 256      *\/$/;"	v
idata_loc	SDCCglobl.h	/^    int idata_loc;              \/* indirect address space        *\/$/;"	m	struct:options
idata_name	port.h	/^    const char *const idata_name;$/;"	m
ifDefSymIs	SDCCcse.c	/^ifDefSymIs (set * cseSet, operand * sym)$/;"	f
ifDefSymIsX	SDCCcse.h	/^DEFSETFUNC (ifDefSymIsX);$/;"	v
ifDiCodeIs	SDCCcse.c	/^ifDiCodeIs (set * cseSet, iCode * ic)$/;"	f
ifDiCodeIsX	SDCCcse.h	/^DEFSETFUNC (ifDiCodeIsX);$/;"	v
ifFromIs	SDCCBBlock.h	/^DEFSETFUNC (ifFromIs);$/;"	v
ifKilledInBlock	SDCCdflow.h	/^DEFSETFUNC (ifKilledInBlock);$/;"	v
ifOperandsHave	SDCCcse.h	/^DEFSETFUNC (ifOperandsHave);$/;"	v
ifxForOp	SDCCgen.c	/^ifxForOp (operand * op, const iCode * ic)$/;"	f
ifxOptimize	SDCCcse.c	/^ifxOptimize (iCode * ic, set * cseSet,$/;"	f
ignoreTypedefType	SDCCy.c	/^int ignoreTypedefType=0;$/;"	v
ilist	SDCCy.c	/^    initList   *ilist;      \/* initial list                           *\/$/;"	m	union:YYSTYPE	file:
ilist	SDCCy.h	/^    initList   *ilist;      \/* initial list                           *\/$/;"	m	union:YYSTYPE
immedDom	SDCCcflow.c	/^immedDom (ebbIndex * ebbi, eBBlock * ebp)$/;"	f
implicit	SDCCsymt.h	/^  unsigned implicit:1;              \/* implicit flag                     *\/$/;"	m	struct:symbol
implicitCast	SDCCast.h	/^      unsigned implicitCast:1;  \/* true if compiler added this cast *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
inCalleeSaveList	SDCCsymt.c	/^inCalleeSaveList (char *s)$/;"	f
inCritical	SDCCy.c	/^int inCritical= 0;$/;"	v
inDefs	SDCCBBlock.h	/^  bitVect *inDefs;              \/* in coming defintions            *\/$/;"	m	struct:eBBlock
inExprs	SDCCBBlock.h	/^  set *inExprs;                 \/* in coming common expressions    *\/$/;"	m	struct:eBBlock
inInitMode	SDCCast.c	/^int inInitMode = 0;$/;"	v
inPtrsSet	SDCCBBlock.h	/^  bitVect *inPtrsSet;           \/* in coming pointers assigned values *\/$/;"	m	struct:eBBlock
incUsed	SDCClrange.c	/^incUsed (iCode *ic, operand *op)$/;"	f	file:
includeDirsSet	SDCCmain.c	/^set *includeDirsSet = NULL;     \/* list of include search directories *\/$/;"	v
indexSet	SDCCset.c	/^indexSet (set * s, int index)$/;"	f
induction	SDCCloop.h	/^induction;$/;"	t
induction	SDCCloop.h	/^typedef struct induction$/;"	s
infertype	SDCCsymt.h	/^  unsigned infertype:1;             \/* type should be inferred from first assign *\/$/;"	m	struct:symbol
init	SDCCval.h	/^  init;$/;"	m	struct:initList
init	port.h	/^  void (*init) (void);$/;"	m
initAggregates	SDCCast.c	/^initAggregates (symbol * sym, initList * ival, ast * wid)$/;"	f
initBuiltIns	SDCCsymt.c	/^initBuiltIns ()$/;"	f
initCSupport	SDCCsymt.c	/^initCSupport (void)$/;"	f
initExpr	SDCCast.h	/^      struct ast *initExpr;     \/* init portion          *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
initGenLineElement	SDCCgen.h	28;"	d
initList	SDCCval.h	/^initList;$/;"	t
initList	SDCCval.h	/^typedef struct initList$/;"	s
initMem	SDCCmem.c	/^initMem ()$/;"	f
initMode	SDCCast.h	/^  unsigned initMode:1;$/;"	m	struct:ast
initPaths	port.h	/^  void (*initPaths) (void);$/;"	m
initPeepHole	SDCCpeeph.c	/^initPeepHole (void)$/;"	f
initPointer	SDCCglue.c	/^initPointer (initList * ilist, sym_link * toType)$/;"	f
initSymt	SDCCsymt.c	/^initSymt (void)$/;"	f
initValPointer	SDCCglue.c	/^initValPointer (ast * expr)$/;"	f
initValues	SDCCmain.c	/^initValues (void)$/;"	f	file:
init_pragma_token	SDCCutil.c	/^init_pragma_token (struct pragma_token_s *token)$/;"	f
initiCode	SDCCicode.c	/^initiCode ()$/;"	f
initialComments	SDCCglue.c	/^initialComments (FILE * afile)$/;"	f
inlineAddDecl	SDCCast.c	/^inlineAddDecl (symbol * sym, ast * block, int addSymTab, int toFront)$/;"	f	file:
inlineAsm	SDCCicode.h	/^  const char *inlineAsm;        \/* pointer to inline assembler code *\/$/;"	m	struct:iCode
inlineFindParm	SDCCast.c	/^inlineFindParm (ast * parms, int index)$/;"	f	file:
inlineFindParmRecurse	SDCCast.c	/^inlineFindParmRecurse (ast * parms, int *index)$/;"	f	file:
inlineState	SDCCast.c	/^} inlineState;$/;"	v	file:
inlineTempVar	SDCCast.c	/^inlineTempVar (sym_link * type, int level)$/;"	f	file:
inlineasm	SDCCast.h	/^    const char *inlineasm;      \/* pointer to inline assembler code *\/$/;"	m	union:ast::<anonymous>
inlinereq	SDCCsymt.h	/^    unsigned inlinereq:1;           \/* inlining requested                   *\/$/;"	m	struct:sym_link::<anonymous>
insetwithFunc	SDCCset.h	/^typedef int (* insetwithFunc) (void *, void *);$/;"	t
int_size	port.h	/^    unsigned int int_size;$/;"	m
int_val	SDCCutil.h	/^    int int_val;$/;"	m	union:pragma_token_s::<anonymous>
interrupts	SDCCglue.c	/^symbol *interrupts[INTNO_MAX + 1];$/;"	v
intersectLoopSucc	SDCCloop.c	/^intersectLoopSucc (set * lexits, eBBlock ** ebbs)$/;"	f	file:
intersectSets	SDCCset.c	/^intersectSets (set * list1, set * list2, int throw)$/;"	f
intersectSetsWith	SDCCset.c	/^intersectSetsWith (set * list1, set * list2,$/;"	f
intlong_rent	SDCCglobl.h	/^    int intlong_rent;           \/* integer & long support routines reentrant *\/$/;"	m	struct:options
intno	SDCCsymt.h	/^    unsigned intno;                 \/* 1=Interrupt service routine          *\/$/;"	m	struct:sym_link::<anonymous>
intrtn	SDCCsymt.h	/^    unsigned intrtn:1;              \/* this is an interrupt routine         *\/$/;"	m	struct:sym_link::<anonymous>
invalid_directive	altlex.c	/^invalid_directive (void)$/;"	f	file:
iram_size	SDCCglobl.h	/^    int iram_size;              \/* internal ram size (used only for error checking) *\/$/;"	m	struct:options
isAstEqual	SDCCast.c	/^isAstEqual (ast * t1, ast * t2)$/;"	f	file:
isBitAndPow2	SDCCast.c	/^isBitAndPow2 (ast * tree)$/;"	f	file:
isComment	SDCCgen.h	/^  unsigned int isComment:1;$/;"	m	struct:lineElem_s
isConditionalExitFrom	SDCCBBlock.h	/^  struct eBBlock *isConditionalExitFrom;        \/* this block ends with a return or goto from a conditional block *\/$/;"	m	struct:eBBlock
isConformingBody	SDCCast.c	/^isConformingBody (ast * pbody, symbol * sym, ast * body)$/;"	f
isConstant	SDCCsymt.c	/^isConstant (sym_link * type)$/;"	f
isCseDefEqual	SDCCcse.c	/^isCseDefEqual (void *vsrc, void *vdest)$/;"	f
isDebug	SDCCgen.h	/^  unsigned int isDebug:1;$/;"	m	struct:lineElem_s
isDefAlive	SDCCdflow.h	/^DEFSETFUNC (isDefAlive);$/;"	v
isDefAlive	SDCCloop.c	/^DEFSETFUNC (isDefAlive);$/;"	v
isError	SDCCast.h	/^  unsigned isError:1;$/;"	m	struct:ast
isFree	SDCCsymt.h	/^  unsigned isFree:1;                \/* used by register allocator *\/$/;"	m	struct:symbol
isGlobal	SDCCicode.h	/^  unsigned int isGlobal:1;          \/* is a global operand *\/$/;"	m	struct:operand
isGlobalInNearSpace	SDCCcse.c	/^isGlobalInNearSpace (operand * op)$/;"	f	file:
isGptr	SDCCicode.h	/^  unsigned int isGptr:1;            \/* is a generic pointer  *\/$/;"	m	struct:operand
isHtabsEqual	SDCChasht.c	/^isHtabsEqual (hTab * htab1, hTab * htab2,$/;"	f
isInline	SDCCgen.h	/^  unsigned int isInline:1;$/;"	m	struct:lineElem_s
isLabel	SDCCgen.h	/^  unsigned int isLabel:1;$/;"	m	struct:lineElem_s
isLabelDefinition	SDCCpeeph.c	/^isLabelDefinition (const char *line, const char **start, int *len,$/;"	f
isLabelInAst	SDCCast.c	/^isLabelInAst (symbol * label, ast * tree)$/;"	f
isLabelReference	SDCCpeeph.c	/^isLabelReference (const char *line, const char **start, int *len)$/;"	f
isLastInLoop	SDCCBBlock.h	/^  unsigned int isLastInLoop:1;  \/* is the last block in a loop *\/$/;"	m	struct:eBBlock
isLiteral	SDCCicode.h	/^  unsigned int isLiteral:1;         \/* operand is literal    *\/$/;"	m	struct:operand
isLiveFcall	SDCCsymt.h	/^  unsigned isLiveFcall:1;           \/* is live at or across a function call *\/$/;"	m	struct:symbol
isLocalWithoutDef	SDCCopt.c	/^isLocalWithoutDef (symbol * sym)$/;"	f	file:
isLoopCountable	SDCCast.c	/^isLoopCountable (ast * initExpr, ast * condExpr, ast * loopExpr, symbol ** sym, ast ** init, ast ** end)$/;"	f	file:
isLoopReversible	SDCCast.c	/^isLoopReversible (ast * loop, symbol ** loopCntrl, ast ** init, ast ** end)$/;"	f	file:
isLvaluereq	SDCCicode.c	/^isLvaluereq (int lvl)$/;"	f	file:
isOclsExpensive	SDCCicode.c	/^isOclsExpensive (struct memmap * oclass)$/;"	f
isOperandEqual	SDCCicode.c	/^isOperandEqual (const operand * left, const operand * right)$/;"	f
isOperandGlobal	SDCCicode.c	/^isOperandGlobal (operand * op)$/;"	f
isOperandInCodeSpace	SDCCicode.c	/^isOperandInCodeSpace (operand * op)$/;"	f
isOperandInDirSpace	SDCCicode.c	/^isOperandInDirSpace (operand * op)$/;"	f
isOperandInFarSpace	SDCCicode.c	/^isOperandInFarSpace (operand * op)$/;"	f
isOperandInPagedSpace	SDCCicode.c	/^isOperandInPagedSpace (operand * op)$/;"	f
isOperandInvariant	SDCCloop.c	/^isOperandInvariant (operand * op, region * theLoop, set * lInvars)$/;"	f	file:
isOperandLiteral	SDCCicode.c	/^isOperandLiteral (const operand *const op)$/;"	f
isOperandOnStack	SDCCicode.c	/^isOperandOnStack (operand * op)$/;"	f
isOperandVolatile	SDCCicode.c	/^isOperandVolatile (operand * op, bool chkTemp)$/;"	f
isParameterToCall	SDCCicode.c	/^isParameterToCall (value * args, operand * op)$/;"	f
isParm	SDCCicode.h	/^  unsigned int isParm:1;            \/* is a parameter        *\/$/;"	m	struct:operand
isPowerOf2	SDCCopt.c	/^isPowerOf2 (unsigned long val)$/;"	f	file:
isPtr	SDCCicode.h	/^  unsigned int isPtr:1;             \/* is assigned a pointer *\/$/;"	m	struct:operand
isRestrict	SDCCsymt.c	/^isRestrict (sym_link * type)$/;"	f
isSetsEqual	SDCCset.c	/^isSetsEqual (set * dest, set * src)$/;"	f
isSetsEqualWith	SDCCset.c	/^isSetsEqualWith (set * dest, set * src, int (*cFunc) (void *, void *))$/;"	f
isShiftRightLitVal_BitAndLitVal	SDCCast.c	/^isShiftRightLitVal_BitAndLitVal (ast * tree)$/;"	f	file:
isSignedOp	SDCCcse.c	/^static int isSignedOp (iCode *ic)$/;"	f	file:
isSymbolEqual	SDCCsymt.c	/^isSymbolEqual (symbol * dest, symbol * src)$/;"	f
isTargetKeyword	SDCClex.c	/^isTargetKeyword (const char *s)$/;"	f	file:
isTargetKeyword	altlex.c	/^isTargetKeyword (const char *s)$/;"	f	file:
isVolatile	SDCCsymt.c	/^isVolatile (sym_link * type)$/;"	f
is_stmt	SDCCdwarf2.h	/^  unsigned is_stmt:1;$/;"	m	struct:dwline
isaddr	SDCCicode.h	/^  unsigned int isaddr:1;            \/* is an address   *\/$/;"	m	struct:operand
isiCodeEqual	SDCCicode.c	/^isiCodeEqual (iCode * left, iCode * right)$/;"	f
isiCodeInFunctionCall	SDCCicode.c	/^isiCodeInFunctionCall (iCode * ic)$/;"	f
isinSet	SDCCset.c	/^isinSet (set * list, void *item)$/;"	f
isinSetWith	SDCCset.c	/^isinSetWith (set * list, void *item, int (*cFunc) (void *, void *))$/;"	f
isind	SDCCsymt.h	/^  unsigned isind:1;                 \/* is an induction variable *\/$/;"	m	struct:symbol
isinscope	SDCCsymt.h	/^  unsigned isinscope:1;             \/* is in scope *\/$/;"	m	struct:symbol
isinvariant	SDCCsymt.h	/^  unsigned isinvariant:1;           \/* is a loop invariant  *\/$/;"	m	struct:symbol
isitmp	SDCCsymt.h	/^  unsigned isitmp:1;                \/* is an intermediate temp *\/$/;"	m	struct:symbol
islbl	SDCCsymt.h	/^  unsigned islbl:1;                 \/* is a temporary label *\/$/;"	m	struct:symbol
islocal	SDCCsymt.h	/^  unsigned islocal:1;               \/* is a local variable        *\/$/;"	m	struct:symbol
ismyparm	SDCCsymt.h	/^  unsigned ismyparm:1;              \/* is parameter of the function being generated *\/$/;"	m	struct:symbol
isptr	SDCCsymt.h	/^  unsigned isptr:1;                 \/* is a pointer *\/$/;"	m	struct:symbol
isr_overhead	port.h	/^    int isr_overhead;$/;"	m
isref	SDCCsymt.h	/^  unsigned isref:1;                 \/* has been referenced  *\/$/;"	m	struct:symbol
isreqv	SDCCsymt.h	/^  unsigned isreqv:1;                \/* is the register equivalent of a symbol *\/$/;"	m	struct:symbol
isspilt	SDCCsymt.h	/^  unsigned isspilt:1;               \/* has to be spilt *\/$/;"	m	struct:symbol
isstrlit	SDCCsymt.h	/^  unsigned isstrlit;                \/* is a string literal and it's usage count  *\/$/;"	m	struct:symbol
istack	SDCCmem.c	/^memmap *istack = NULL;          \/* internal stack              *\/$/;"	v
istack_name	port.h	/^    const char *const istack_name;$/;"	m
isvolatile	SDCCicode.h	/^  unsigned int isvolatile:1;        \/* is a volatile operand *\/$/;"	m	struct:operand
item	SDCChasht.h	/^    void *item;$/;"	m	struct:hashtItem
item	SDCCset.h	/^    void *item;$/;"	m	struct:set
itmpStack	SDCCsymt.h	/^    struct set *itmpStack;          \/* symbols spilt @ this stack location *\/$/;"	m	union:symbol::<anonymous>
ival	SDCCsymt.h	/^  struct initList *ival;            \/* ptr to initializer if any  *\/$/;"	m	struct:symbol
javaNative	SDCCsymt.h	/^    unsigned javaNative;            \/* is a JavaNative Function (TININative ONLY) *\/$/;"	m	struct:sym_link::<anonymous>
jmpTab	SDCCicode.h	/^    jmpTab;$/;"	m	union:iCode::<anonymous>
jmpToCount	SDCCpeeph.h	/^    int jmpToCount;$/;"	m
joinStrSet	SDCCutil.c	/^joinStrSet (set * list)$/;"	f
jumptableCost	port.h	/^  jumptableCost;$/;"	m
key	SDCCcse.h	/^    int key;$/;"	m	struct:cseDef
key	SDCChasht.h	/^    int key;$/;"	m	struct:hashtItem
key	SDCCicode.h	/^  int key;                      \/* running key for this iCode *\/$/;"	m	struct:iCode
key	SDCCicode.h	/^  int key;$/;"	m	struct:operand
key	SDCCsymt.h	/^  int key;$/;"	m	struct:symbol
keyForVar	SDCCpeeph.c	/^keyForVar (char *d)$/;"	f	file:
keywords	port.h	/^  char **keywords;$/;"	m
killDeadCode	SDCCopt.c	/^killDeadCode (ebbIndex * ebbi)$/;"	f
killedExprs	SDCCBBlock.h	/^  set *killedExprs;             \/* killed common expressions       *\/$/;"	m	struct:eBBlock
lSeq	SDCCBBlock.h	/^  int lSeq;                     \/* sequence number of the last iCode *\/$/;"	m	struct:eBBlock
label	SDCCdwarf2.h	/^      char * label;$/;"	m	struct:dwattr::<anonymous>::<anonymous>
label	SDCCdwarf2.h	/^    const char * label;$/;"	m	struct:dwloc::<anonymous>
label	SDCCdwarf2.h	/^  char * label;$/;"	m	struct:dwline
label	SDCCicode.h	/^  symbol *label;                \/* for a goto statement     *\/$/;"	m	struct:iCode
label1	SDCCglobl.h	/^    int label1;$/;"	m	struct:optimize
label2	SDCCglobl.h	/^    int label2;$/;"	m	struct:optimize
label3	SDCCglobl.h	/^    int label3;$/;"	m	struct:optimize
label4	SDCCglobl.h	/^    int label4;$/;"	m	struct:optimize
labelDef	SDCClabel.c	/^hTab *labelDef = NULL;$/;"	v
labelGotoGoto	SDCClabel.c	/^labelGotoGoto (iCode * ic)$/;"	f
labelGotoNext	SDCClabel.c	/^labelGotoNext (iCode * ic)$/;"	f
labelHash	SDCCpeeph.c	/^hTab *labelHash = NULL;$/;"	v
labelHashEntry	SDCCpeeph.h	/^labelHashEntry;$/;"	t
labelIfx	SDCClabel.c	/^labelIfx (iCode * ic)$/;"	f
labelKey	SDCCast.c	/^int labelKey = 1;$/;"	v
labelKey2num	SDCCgen.h	29;"	d
labelRef	SDCClabel.c	/^hTab *labelRef = NULL;$/;"	v
labelUnreach	SDCClabel.c	/^labelUnreach (iCode * ic)$/;"	f
labelUnrefLabel	SDCClabel.c	/^labelUnrefLabel (iCode * ic)$/;"	f
labels	SDCCicode.h	/^      set *labels;              \/* ordered set of labels  *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
labels	SDCCpeeph.c	/^  allocTrace labels;$/;"	m	file:
lastChild	SDCCdwarf2.h	/^  struct dwtag * lastChild;$/;"	m	struct:dwtag
lastLine	SDCCsymt.h	/^  int lastLine;                     \/* for functions the last line *\/$/;"	m	struct:symbol
lbuff	SDCCy.c	/^char lbuff[1024];       \/* local buffer *\/$/;"	v
ldefs	SDCCBBlock.h	/^  bitVect *ldefs;               \/* local definitions only          *\/$/;"	m	struct:eBBlock
le_ngt	port.h	/^  bool le_ngt;                  \/* transform (a <= b) to !(a > b)   *\/$/;"	m
left	SDCCast.h	/^  struct ast *left;             \/* pointer to left tree    *\/$/;"	m	struct:ast
left	SDCCicode.h	/^      operand *left;            \/* left if any   *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
length	SDCCdwarf2.h	/^      int length;$/;"	m	struct:dwattr::<anonymous>::<anonymous>
length	SDCCdwarf2.h	/^  int length;$/;"	m	struct:dwfile
lessPedantic	SDCCglobl.h	/^    int lessPedantic;           \/* disable some warnings *\/$/;"	m	struct:options
level	SDCCast.h	/^  int level;                    \/* level for expr *\/$/;"	m	struct:ast
level	SDCCicode.h	/^  short level;                  \/* scope level *\/$/;"	m	struct:iCode
level	SDCCsymt.h	/^  int level;                    \/* nest level for this symbol *\/$/;"	m	struct:bucket
level	SDCCsymt.h	/^  short level;                      \/* declaration lev,fld offset *\/$/;"	m	struct:symbol
level	SDCCsymt.h	/^  unsigned char level;          \/* Nesting level              *\/$/;"	m	struct:structdef
lexFilename	SDCClex.c	/^char *lexFilename;$/;"	v
lexLineno	SDCClex.c	/^int lexLineno = 1;$/;"	v
libDirsSet	SDCCmain.c	/^set *libDirsSet = NULL;         \/* list of lib search directories *\/$/;"	v
libFilesSet	SDCCmain.c	/^set *libFilesSet = NULL;$/;"	v
libPathsSet	SDCCmain.c	/^set *libPathsSet = NULL;$/;"	v
libs	port.h	/^    const char *const *libs;$/;"	m
linds	SDCCBBlock.h	/^  bitVect *linds;               \/* if loop exit this contains defNumbers$/;"	m	struct:eBBlock
line	SDCCdwarf2.h	/^  int line;$/;"	m	struct:dwline
line	SDCCgen.h	/^  char *line;$/;"	m	struct:lineElem_s
lineCurr	SDCCgen.h	/^  lineNode *lineCurr;$/;"	m	struct:genLine_s
lineDef	SDCCsymt.h	/^  int lineDef;                      \/* defined line number        *\/$/;"	m	struct:symbol
lineElem_s	SDCCgen.h	/^typedef struct lineElem_s$/;"	s
lineElem_t	SDCCgen.h	/^lineElem_t;$/;"	t
lineElement	SDCCgen.h	/^  lineElem_t lineElement;$/;"	m	struct:genLine_s
lineHead	SDCCgen.h	/^  lineNode *lineHead;$/;"	m	struct:genLine_s
lineNode	SDCCgen.h	/^lineNode;$/;"	t
lineNode_s	SDCCgen.h	/^typedef struct lineNode_s$/;"	s
linebuf	altlex.c	/^static char linebuf[10000];$/;"	v	file:
linelen	altlex.c	/^static int linepos, linelen;$/;"	v	file:
lineno	SDCCast.h	/^  int lineno;                   \/* source file line number     *\/$/;"	m	struct:ast
lineno	SDCCicode.c	/^int lineno = 1;                 \/* current line number *\/$/;"	v
lineno	SDCCicode.h	/^  int lineno;                   \/* file & lineno for debug information *\/$/;"	m	struct:iCode
lineno	SDCCval.h	/^    int lineno;$/;"	m	struct:designation
lineno	SDCCval.h	/^  int lineno;$/;"	m	struct:initList
linepos	altlex.c	/^static int linepos, linelen;$/;"	v	file:
linkEdit	SDCCmain.c	/^linkEdit (char **envp)$/;"	f	file:
linkOptionsSet	SDCCmain.c	/^set *linkOptionsSet = NULL;     \/* set of linker options *\/$/;"	v
linker	port.h	/^  linker;$/;"	m
list2expr	SDCCval.c	/^list2expr (initList * ilist)$/;"	f
list2int	SDCCval.c	/^list2int (initList * val)$/;"	f
list2val	SDCCval.c	/^list2val (initList * val)$/;"	f
literalFromCast	SDCCast.h	/^      unsigned literalFromCast:1;       \/* true if this is an EX_VALUE of LITERAL$/;"	m	struct:ast::<anonymous>::<anonymous>
literalList	SDCCval.h	/^typedef struct literalList$/;"	s
literalList	SDCCval.h	/^} literalList;$/;"	t
literalValue	SDCCval.h	/^  double literalValue;$/;"	m	struct:literalList
little_endian	port.h	/^  bool little_endian;$/;"	m
liveFrom	SDCCsymt.h	/^  int liveFrom;                     \/* live from iCode sequence number *\/$/;"	m	struct:symbol
liveRanges	SDCClrange.c	/^hTab *liveRanges = NULL;$/;"	v
liveTo	SDCCsymt.h	/^  int liveTo;                       \/* live to sequence number *\/$/;"	m	struct:symbol
lnk	SDCCast.h	/^    sym_link *lnk;              \/* sym_link * if type= EX_LINK  *\/$/;"	m	union:ast::<anonymous>
lnk	SDCCy.c	/^    sym_link   *lnk;        \/* declarator  or specifier               *\/$/;"	m	union:YYSTYPE	file:
lnk	SDCCy.h	/^    sym_link   *lnk;        \/* declarator  or specifier               *\/$/;"	m	union:YYSTYPE
loc	SDCCdwarf2.h	/^    struct dwloc * loc;$/;"	m	union:dwattr::<anonymous>
loc	SDCCdwarf2.h	/^  dwloc * loc;$/;"	m	struct:dwlocregion
localof	SDCCsymt.h	/^  struct symbol *localof;           \/* local variable of which function *\/$/;"	m	struct:symbol
loclist	SDCCdwarf2.h	/^    struct dwloclist * loclist;$/;"	m	union:dwattr::<anonymous>
logLevel	SDCCerr.h	/^  ERROR_LOG_LEVEL logLevel;$/;"	m	struct:SDCCERRG
longOpt	SDCCargs.h	/^    const char *longOpt;$/;"	m
longOpt	SDCCmain.c	/^  const char *longOpt;$/;"	m	file:
long_size	port.h	/^    int long_size;$/;"	m
longlong_size	port.h	/^    int longlong_size;$/;"	m
loopExpr	SDCCast.h	/^      struct ast *loopExpr;     \/* iteration portion     *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
loopInduction	SDCCglobl.h	/^    int loopInduction;$/;"	m	struct:optimize
loopInduction	SDCCloop.c	/^loopInduction (region * loopReg, ebbIndex * ebbi)$/;"	f	file:
loopInsert	SDCCloop.c	/^loopInsert (set ** regionSet, eBBlock * block)$/;"	f	file:
loopInvariant	SDCCglobl.h	/^    int loopInvariant;$/;"	m	struct:optimize
loopInvariants	SDCCloop.c	/^loopInvariants (region * theLoop, ebbIndex * ebbi)$/;"	f	file:
loopOptimizations	SDCCloop.c	/^loopOptimizations (hTab * orderedLoops, ebbIndex * ebbi)$/;"	f
lrr	SDCCicode.h	/^    lrr;$/;"	m	union:iCode::<anonymous>
lt_nge	port.h	/^  bool lt_nge;                  \/* transform (a < b)  to !(a >= b)  *\/$/;"	m
lvalItem	SDCCicode.c	/^lvalItem;$/;"	t	file:
lvalItem	SDCCicode.c	/^typedef struct lvalItem$/;"	s	file:
lvalue	SDCCast.h	/^  unsigned lvalue:1;$/;"	m	struct:ast
lvaluereqSet	SDCCicode.c	/^set *lvaluereqSet = NULL;$/;"	v
lvl	SDCCicode.c	/^  int lvl;$/;"	m	struct:lvalItem	file:
magic	port.h	/^  int magic;$/;"	m
main	SDCClex.c	/^int main()$/;"	f
main	SDCCmain.c	/^main (int argc, char **argv, char **envp)$/;"	f
mainf	SDCCglue.c	/^symbol *mainf;$/;"	v
mainreturn	SDCCglobl.h	/^    int mainreturn;             \/* issue a return after main *\/$/;"	m	struct:options
map	SDCCmem.h	/^    memmap *map;$/;"	m	struct:namedspacemap
markAlive	SDCClrange.c	/^markAlive (iCode * sic, iCode * eic, int key)$/;"	f	file:
markLiveRanges	SDCClrange.c	/^markLiveRanges (eBBlock ** ebbs, int count)$/;"	f	file:
markNoPath	SDCCcflow.c	/^markNoPath (ebbIndex * ebbi)$/;"	f	file:
markWholeLoop	SDCClrange.c	/^markWholeLoop (eBBlock *ebp, int key)$/;"	f	file:
match	SDCCpeeph.h	/^    lineNode *match;$/;"	m	struct:peepRule
matchLine	SDCCpeeph.c	/^matchLine (char *s, char *d, hTab ** vars)$/;"	f	file:
matchRule	SDCCpeeph.c	/^matchRule (lineNode * pl,$/;"	f	file:
max	SDCCglobl.h	126;"	d
maxCount	port.h	/^    int maxCount;$/;"	m
maxInterrupts	SDCCglue.c	/^unsigned maxInterrupts = 0;$/;"	v
maxKey	SDCChasht.h	/^    int maxKey;			\/* maximum key value *\/$/;"	m	struct:hTab
max_allocs_per_node	SDCCglobl.h	/^    int max_allocs_per_node;    \/* Maximum number of allocations \/ combinations considered at each node in the tree-decomposition based algorithms *\/$/;"	m	struct:options
max_base_size	port.h	/^    int max_base_size;$/;"	m
mcmd	port.h	/^    const char *mcmd;$/;"	m
mem	port.h	/^  mem;$/;"	m
memmap	SDCCmem.h	/^memmap;$/;"	t
memmap	SDCCmem.h	/^typedef struct memmap$/;"	s
mergeDeclSpec	SDCCsymt.c	/^mergeDeclSpec (sym_link * dest, sym_link * src, const char *name)$/;"	f
mergeInDefs	SDCCdflow.h	/^DEFSETFUNC (mergeInDefs);$/;"	v
mergeInExprs	SDCCdflow.h	/^DEFSETFUNC (mergeInExprs);$/;"	v
mergeSets	SDCCset.c	/^mergeSets (set **sset, set *list)$/;"	f
mergeSpec	SDCCsymt.c	/^mergeSpec (sym_link * dest, sym_link * src, const char *name)$/;"	f
merge_command	SDCCsystem.c	/^merge_command (const char *command, const char *params)$/;"	f	file:
merged	SDCCloop.h	/^    unsigned int merged:1;$/;"	m	struct:region
message	SDCCmain.c	/^  const char *message;$/;"	m	file:
mfprintf	SDCCmacro.c	/^mfprintf (FILE * fp, hTab * pvals, const char *pformat, ...)$/;"	f
min	SDCCglobl.h	129;"	d
minKey	SDCChasht.h	/^    int minKey;			\/* minimum key value   *\/$/;"	m	struct:hTab
miscOpt	SDCCopt.c	/^miscOpt (eBBlock ** ebbs, int count)$/;"	f	file:
model	SDCCglobl.h	/^    int model;                  \/* see MODEL_* defines above *\/$/;"	m	struct:options
moduleName	SDCCmain.c	/^const char *moduleName;         \/* module name is same as module name base, but with all *\/$/;"	v
moduleNameBase	SDCCmain.c	/^static const char *moduleNameBase;  \/* module name base is source file without path and extension *\/$/;"	v	file:
moveNestedInit	SDCCast.c	/^moveNestedInit (initList *src)$/;"	f	file:
moveNestedInit	SDCCval.c	/^void moveNestedInit(initList *deepParent, initList *src)$/;"	f	file:
movedFrom	SDCCicode.h	/^  set *movedFrom;               \/* if this iCode gets moved to another block *\/$/;"	m	struct:iCode
msprintf	SDCCmacro.c	/^msprintf (hTab * pvals, const char *pformat, ...)$/;"	f
muldiv	SDCCsymt.c	/^symbol *muldiv[3][4][4];$/;"	v
muldiv	port.h	/^    unsigned muldiv;$/;"	m
multypes	SDCCsymt.c	/^sym_link *multypes[4][2];$/;"	v
mvsprintf	SDCCmacro.c	/^mvsprintf (hTab * pvals, const char *pformat, va_list ap)$/;"	f
mylineno	altlex.c	/^int mylineno;$/;"	v
nItems	SDCChasht.h	/^    int nItems;$/;"	m	struct:hTab
nParms	port.h	/^  int nParms;                   \/* number of parms : max 8 *\/$/;"	m	struct:builtins
nRegs	SDCCsymt.h	/^  short nRegs;                      \/* number of registers required *\/$/;"	m	struct:symbol
naked	SDCCsymt.h	/^    unsigned naked:1;               \/* naked function                       *\/$/;"	m	struct:sym_link::<anonymous>
name	SDCCdwarf2.h	/^  char * name;$/;"	m	struct:dwfile
name	SDCCmem.h	/^    char *name;$/;"	m	struct:namedspacemap
name	SDCCpeeph.h	/^    char name[SDCC_NAME_MAX + 1];$/;"	m
name	SDCCsymt.h	/^  char name[SDCC_NAME_MAX + 1]; \/* name of this symbol        *\/$/;"	m	struct:bucket
name	SDCCsymt.h	/^  char name[SDCC_SYMNAME_MAX + 1];  \/* Input Variable Name     *\/$/;"	m	struct:symbol
name	SDCCval.h	/^  char name[SDCC_NAME_MAX + 1]; \/* operand accessing this value     *\/$/;"	m	struct:value
name	port.h	/^  char *name;                   \/* name of builtin function *\/$/;"	m	struct:builtins
name	port.h	/^  const char *name;$/;"	m	struct:pragma_s
namedspacemap	SDCCmem.h	/^namedspacemap;$/;"	t
namedspacemap	SDCCmem.h	/^typedef struct namedspacemap$/;"	s
namedspacemaps	SDCCmem.c	/^namedspacemap *namedspacemaps = 0; \/* memory segments for named address spaces *\/$/;"	v
ndompset	SDCCBBlock.h	/^  bitVect *ndompset;            \/* pointers set by non-dominating basic blocks *\/$/;"	m	struct:eBBlock
ne_neq	port.h	/^  bool ne_neq;                  \/* transform a != b --> ! (a == b)  *\/$/;"	m
needLinkerScript	port.h	/^    const int needLinkerScript;$/;"	m
newAst_	SDCCast.c	/^newAst_ (unsigned type)$/;"	f	file:
newAst_LINK	SDCCast.c	/^newAst_LINK (sym_link * val)$/;"	f
newAst_OP	SDCCast.c	/^newAst_OP (unsigned op)$/;"	f
newAst_VALUE	SDCCast.c	/^newAst_VALUE (value * val)$/;"	f
newBitVect	SDCCbitv.c	/^newBitVect (int size)$/;"	f
newBoolLink	SDCCsymt.c	/^newBoolLink ()$/;"	f
newBucket	SDCCsymt.c	/^newBucket (void)$/;"	f
newCharLink	SDCCsymt.c	/^newCharLink ()$/;"	f
newCseDef	SDCCcse.c	/^newCseDef (operand * sym, iCode * ic)$/;"	f
newDesignation	SDCCval.c	/^newDesignation (int type, void *designator)$/;"	f
newEdge	SDCCBBlock.c	/^newEdge (eBBlock * from, eBBlock * to)$/;"	f
newEnumType	SDCCsymt.c	/^newEnumType (symbol * enumlist)$/;"	f
newFixed16x16Link	SDCCsymt.c	/^newFixed16x16Link ()$/;"	f
newFloatLink	SDCCsymt.c	/^newFloatLink ()$/;"	f
newHashTable	SDCChasht.c	/^newHashTable (int size)$/;"	f
newIfxNode	SDCCast.c	/^newIfxNode (ast * condAst, symbol * trueLabel, symbol * falseLabel)$/;"	f
newInduction	SDCCloop.c	/^newInduction (operand * sym, unsigned int op, long constVal, iCode * ic, operand * asym)$/;"	f	file:
newIntLink	SDCCsymt.c	/^newIntLink ()$/;"	f
newLineNode	SDCCgen.c	/^newLineNode (const char *line)$/;"	f
newLink	SDCCsymt.c	/^newLink (SYM_LINK_CLASS select)$/;"	f
newLongLink	SDCCsymt.c	/^newLongLink ()$/;"	f
newLongLongLink	SDCCsymt.c	/^newLongLongLink ()$/;"	f
newNode	SDCCast.c	/^newNode (long op, ast * left, ast * right)$/;"	f
newOperand	SDCCicode.c	/^newOperand ()$/;"	f
newPeepRule	SDCCpeeph.c	/^newPeepRule (lineNode * match,$/;"	f	file:
newRegion	SDCCloop.c	/^newRegion ()$/;"	f	file:
newSet	SDCCset.c	/^newSet (void)$/;"	f
newStruct	SDCCsymt.c	/^newStruct (const char *tag)$/;"	f
newSymbol	SDCCsymt.c	/^newSymbol (const char *name, int scope)$/;"	f
newValue	SDCCval.c	/^newValue (void)$/;"	f
newVoidLink	SDCCsymt.c	/^newVoidLink ()$/;"	f
neweBBlock	SDCCBBlock.c	/^neweBBlock ()$/;"	f
newiCode	SDCCicode.c	/^newiCode (int op, operand * left, operand * right)$/;"	f
newiCodeCondition	SDCCicode.c	/^newiCodeCondition (operand * condition, symbol * trueLabel, symbol * falseLabel)$/;"	f
newiCodeLabelGoto	SDCCicode.c	/^newiCodeLabelGoto (int op, symbol * label)$/;"	f
newiList	SDCCval.c	/^newiList (int type, void *ilist)$/;"	f
newiTemp	SDCCicode.c	/^newiTemp (const char *s)$/;"	f
newiTempFromOp	SDCCicode.c	/^newiTempFromOp (operand * op)$/;"	f
newiTempLabel	SDCCicode.c	/^newiTempLabel (const char *s)$/;"	f
newiTempLoopHeaderLabel	SDCCicode.c	/^newiTempLoopHeaderLabel (bool pre)$/;"	f
newiTempOperand	SDCCicode.c	/^newiTempOperand (sym_link * type, char throwType)$/;"	f
next	SDCCdwarf2.h	/^  struct dwattr * next;$/;"	m	struct:dwattr
next	SDCCdwarf2.h	/^  struct dwline * next;$/;"	m	struct:dwline
next	SDCCdwarf2.h	/^  struct dwloc * next;$/;"	m	struct:dwloc
next	SDCCdwarf2.h	/^  struct dwloclist * next;$/;"	m	struct:dwloclist
next	SDCCdwarf2.h	/^  struct dwlocregion * next;$/;"	m	struct:dwlocregion
next	SDCCgen.h	/^  struct lineNode_s *next;$/;"	m	struct:lineNode_s
next	SDCChasht.h	/^    struct hashtItem *next;$/;"	m	struct:hashtItem
next	SDCCicode.h	/^  struct iCode *next;           \/* next in chain *\/$/;"	m	struct:iCode
next	SDCCmem.h	/^    struct namedspacemap *next;$/;"	m	struct:namedspacemap
next	SDCCpeeph.h	/^    struct peepRule *next;$/;"	m	struct:peepRule
next	SDCCset.h	/^    struct set *next;$/;"	m	struct:set
next	SDCCsymt.h	/^  struct bucket *next;          \/* ptr 2 next bucket          *\/$/;"	m	struct:bucket
next	SDCCsymt.h	/^  struct sym_link *next;            \/* next element on the chain  *\/$/;"	m	struct:sym_link
next	SDCCsymt.h	/^  struct symbol *next;              \/* crosslink to next symbol   *\/$/;"	m	struct:symbol
next	SDCCval.h	/^    struct designation *next;           \/* next part of nested designator *\/$/;"	m	struct:designation
next	SDCCval.h	/^  struct initList *next;$/;"	m	struct:initList
next	SDCCval.h	/^  struct literalList *next;$/;"	m	struct:literalList
next	SDCCval.h	/^  struct value *next;           \/* used in initializer list         *\/$/;"	m	struct:value
nfuncs	SDCCglobl.h	/^    int  nfuncs;        \/* number of functions in this overlay *\/$/;"	m
noAlloc	SDCCast.c	/^int noAlloc = 0;$/;"	v
noAssemble	SDCCmain.c	/^int noAssemble = 0;$/;"	v
noCcodeInAsm	SDCCglobl.h	/^    int noCcodeInAsm;           \/* hide c-code from asm *\/$/;"	m	struct:options
noInit	SDCCglue.c	/^int noInit = 0;                 \/* no initialization *\/$/;"	v
noJTabBoundary	SDCCglobl.h	/^    int noJTabBoundary;$/;"	m	struct:optimize
noLineno	SDCCast.c	/^int noLineno = 0;$/;"	v
noLoopReverse	SDCCglobl.h	/^    int noLoopReverse;$/;"	m	struct:optimize
noOptsdccInAsm	SDCCglobl.h	/^    bool noOptsdccInAsm;        \/* Do not emit .optsdcc in asm *\/$/;"	m	struct:options
noOverlay	SDCCglobl.h	/^    int noOverlay;              \/* don't overlay local variables & parameters *\/$/;"	m	struct:options
noPath	SDCCBBlock.h	/^  unsigned int noPath:1;        \/* there is no path from _entry to this block *\/$/;"	m	struct:eBBlock
noPeepComments	SDCCglobl.h	/^    int noPeepComments;         \/* hide peephole optimizer comments *\/$/;"	m	struct:options
noRegParams	SDCCglobl.h	/^    int noRegParams;            \/* Disable passing some parameters in registers *\/$/;"	m	struct:options
noSpilLoc	SDCCsymt.h	/^  unsigned noSpilLoc:1;             \/* cannot be assigned a spil location *\/$/;"	m	struct:symbol
noXinitOpt	SDCCglobl.h	/^    int noXinitOpt;             \/* don't optimize initialized xdata *\/$/;"	m	struct:options
no_pack_iram	SDCCglobl.h	/^    int no_pack_iram;           \/* MCS51\/DS390 - Deprecated: Tells the linker not to pack variables in internal ram *\/$/;"	m	struct:options
no_std_crt0	SDCCglobl.h	/^    int no_std_crt0;            \/* for the z80\/gbz80 do not link default crt0.o*\/$/;"	m	struct:options
node	SDCCval.h	/^    struct ast *node;$/;"	m	union:initList::<anonymous>
noiv	SDCCglobl.h	/^    int noiv;                   \/* do not generate irq vector table entries *\/$/;"	m	struct:options
nonbanked	SDCCsymt.h	/^    unsigned nonbanked:1;           \/* function has the nonbanked attribute *\/$/;"	m	struct:sym_link::<anonymous>
nopeep	SDCCglobl.h	/^    int nopeep;                 \/* no peep hole optimization *\/$/;"	m	struct:options
noreturn	SDCCsymt.h	/^    unsigned noreturn:1;            \/* promised not to return               *\/$/;"	m	struct:sym_link::<anonymous>
nostdinc	SDCCglobl.h	/^    int nostdinc;               \/* Don't use standard include files *\/$/;"	m	struct:options
nostdlib	SDCCglobl.h	/^    int nostdlib;               \/* Don't use standard lib files *\/$/;"	m	struct:options
nosupdate	SDCCicode.h	/^  unsigned nosupdate:1;         \/* don't update spillocation with this *\/$/;"	m	struct:iCode
notUsed	port.h	/^    bool (*notUsed) (const char *reg, lineNode * currPl, lineNode * head);$/;"	m
notUsedFrom	port.h	/^    bool (*notUsedFrom) (const char *reg, const char *label, lineNode *head);$/;"	m
notUsedInBlock	SDCClrange.c	/^notUsedInBlock (symbol * sym, eBBlock * ebp, iCode *ic)$/;"	f
notVolatileVariable	SDCCpeeph.c	/^notVolatileVariable(char *var, lineNode *currPl, lineNode *endPl)$/;"	f	file:
noun	SDCCsymt.h	/^  NOUN noun;                        \/* CHAR INT STRUCTURE LABEL   *\/$/;"	m	struct:specifier
nounName	SDCCsymt.c	/^nounName (sym_link * sl)$/;"	f
num_elem	SDCCsymt.h	/^  size_t num_elem;                  \/* # of elems if type==array, *\/$/;"	m	struct:declarator
oBuf	SDCCmem.h	/^    struct dbuf_s oBuf;         \/* object buffer associated    *\/$/;"	m	struct:memmap
oclass	SDCCsymt.h	/^  struct memmap *oclass;            \/* output storage class       *\/$/;"	m	struct:specifier
oclsExpense	port.h	/^  int (*oclsExpense) (struct memmap * oclass);$/;"	m
octalEscape	SDCCutil.c	/^octalEscape (const char **str)$/;"	f
offset	SDCCdwarf2.h	/^      int offset;$/;"	m	struct:dwattr::<anonymous>::<anonymous>
offset	SDCCdwarf2.h	/^    int offset;$/;"	m	struct:dwloc::<anonymous>
offset	SDCCdwarf2.h	/^  int offset;$/;"	m	struct:dwline
offset	SDCCsymt.h	/^  unsigned offset;                  \/* offset from top if struct *\/$/;"	m	struct:symbol
offsetFold	SDCCopt.c	/^offsetFold (eBBlock **ebbs, int count)$/;"	f	file:
offsetSP	port.h	/^      int offsetSP;$/;"	m
offsetofOp	SDCCast.c	/^offsetofOp (sym_link * type, ast * snd)$/;"	f
offsetofOp_rec	SDCCast.c	/^offsetofOp_rec (sym_link * type, ast * snd, sym_link ** result_type)$/;"	f	file:
olay	SDCCglobl.h	/^} olay;$/;"	t
oldralloc	SDCCglobl.h	/^    bool oldralloc;             \/* Use old register allocator *\/$/;"	m	struct:options
omitFramePtr	SDCCglobl.h	/^    int omitFramePtr;           \/* Turn off the frame pointer. *\/$/;"	m	struct:options
onStack	SDCCsymt.h	/^  unsigned onStack:1;               \/* this symbol allocated on the stack *\/$/;"	m	struct:symbol
op	SDCCast.h	/^    unsigned op;                \/* operator if type= EX_OP  *\/$/;"	m	union:ast::<anonymous>
op	SDCCicode.h	/^  unsigned int op;              \/* operation defined *\/$/;"	m	struct:iCode
op	SDCCloop.h	/^    unsigned int op;$/;"	m	struct:induction
opFromOpWithDU	SDCCicode.c	/^opFromOpWithDU (operand * op, bitVect * defs, bitVect * uses)$/;"	f
opTypeToStr	SDCCicode.c	/^opTypeToStr (OPTYPE op)$/;"	f	file:
opcode	SDCCdwarf2.h	/^  int opcode;$/;"	m	struct:dwloc
openFile	SDCCdebug.h	/^  int (*openFile) (const char *file);$/;"	m	struct:DebugFile
operKeyReset	SDCCast.c	/^set *operKeyReset = NULL;$/;"	v
operand	SDCCdwarf2.h	/^  } operand;$/;"	m	struct:dwloc
operand	SDCCicode.h	/^operand;$/;"	t
operand	SDCCicode.h	/^typedef struct operand$/;"	s
operandBaseName	SDCCpeeph.c	/^operandBaseName (const char *op)$/;"	f	file:
operandFromAst	SDCCicode.c	/^operandFromAst (ast * tree, int lvl)$/;"	f
operandFromLink	SDCCicode.c	/^operandFromLink (sym_link * type)$/;"	f
operandFromLit	SDCCicode.c	/^operandFromLit (double i)$/;"	f
operandFromOperand	SDCCicode.c	/^operandFromOperand (operand * op)$/;"	f
operandFromSymbol	SDCCicode.c	/^operandFromSymbol (symbol * sym)$/;"	f
operandFromValue	SDCCicode.c	/^operandFromValue (value * val)$/;"	f
operandKey	SDCCicode.c	/^int operandKey = 0;$/;"	v
operandLitValue	SDCCicode.c	/^operandLitValue (operand * op)$/;"	f
operandOperation	SDCCicode.c	/^operandOperation (operand * left, operand * right, int op, sym_link * type)$/;"	f
operandSize	SDCCicode.c	/^operandSize (operand * op)$/;"	f
operandType	SDCCicode.c	/^operandType (const operand *op)$/;"	f
oprnd	SDCCast.h	/^    struct operand *oprnd;      \/* used only for side effecting function calls *\/$/;"	m	union:ast::<anonymous>
optimize	SDCCglobl.h	/^struct optimize$/;"	s
optimize	SDCCmain.c	/^struct optimize optimize;$/;"	v
optimizeCastCast	SDCCopt.c	/^optimizeCastCast (eBBlock ** ebbs, int count)$/;"	f	file:
optimizeCompare	SDCCast.c	/^optimizeCompare (ast * root)$/;"	f	file:
optimizeGetAbit	SDCCast.c	/^optimizeGetAbit (ast * tree, RESULT_TYPE resultType)$/;"	f
optimizeGetByte	SDCCast.c	/^optimizeGetByte (ast * tree, RESULT_TYPE resultType)$/;"	f
optimizeGetHbit	SDCCast.c	/^optimizeGetHbit (ast * tree, RESULT_TYPE resultType)$/;"	f
optimizeGetWord	SDCCast.c	/^optimizeGetWord (ast * tree, RESULT_TYPE resultType)$/;"	f
optimizeRRCRLC	SDCCast.c	/^optimizeRRCRLC (ast * root)$/;"	f
optimizeSWAP	SDCCast.c	/^optimizeSWAP (ast * root)$/;"	f
options	SDCCglobl.h	/^struct options$/;"	s
options	SDCCmain.c	/^struct options options;$/;"	v
optionsTable	SDCCmain.c	/^static const OPTION optionsTable[] = {$/;"	v	file:
opval	SDCCast.h	/^  opval;$/;"	m	struct:ast
osname	SDCCglobl.h	/^    char *osname;       \/* overlay segment name *\/$/;"	m
otherPathsPresent	SDCCBBlock.c	/^otherPathsPresent (eBBlock ** ebbs, eBBlock * this)$/;"	f
out	SDCCerr.h	/^  FILE *out;$/;"	m	struct:SDCCERRG
outDefs	SDCCBBlock.h	/^  bitVect *outDefs;             \/* out going defintions            *\/$/;"	m	struct:eBBlock
outExprs	SDCCBBlock.h	/^  set *outExprs;                \/* out going common expressions    *\/$/;"	m	struct:eBBlock
out_fmt	SDCCglobl.h	/^    int out_fmt;                \/* 0 = undefined, 'i' = intel Hex format, 's' = motorola S19 format, 'E' = elf format, 'Z' = gb format *\/$/;"	m	struct:options
outputDebugStackSymbols	SDCCdebug.c	/^outputDebugStackSymbols (void)$/;"	f
outputDebugSymbols	SDCCdebug.c	/^outputDebugSymbols (void)$/;"	f
overlay	SDCCmem.c	/^memmap *overlay = NULL;         \/* overlay segment             *\/$/;"	v
overlay	SDCCsymt.h	/^    unsigned overlay;               \/* force parameters & locals into overlay segment *\/$/;"	m	struct:sym_link::<anonymous>
overlay2Set	SDCCmem.c	/^overlay2Set ()$/;"	f
overlay2data	SDCCmem.c	/^overlay2data ()$/;"	f
overlay_name	port.h	/^    const char *const overlay_name;$/;"	m
ovrSetSets	SDCCmem.c	/^set *ovrSetSets = NULL;$/;"	v
pMappings	SDCCasm.h	/^  const ASM_MAPPING *pMappings;$/;"	m	struct:_ASM_MAPPINGS
pParent	SDCCasm.h	/^  const ASM_MAPPINGS *pParent;$/;"	m	struct:_ASM_MAPPINGS
paged	SDCCmem.h	/^    unsigned paged:1;           \/* this is a paged mem space   *\/$/;"	m	struct:memmap
pageno	SDCCmem.h	/^    unsigned char pageno;       \/* page no for this variable   *\/$/;"	m	struct:memmap
parent	SDCCdwarf2.h	/^  struct dwtag * parent;$/;"	m	struct:dwtag
parmBytes	SDCCicode.h	/^  int parmBytes;                \/* if call\/pcall, count of parameter bytes$/;"	m	struct:iCode
parmPush	SDCCicode.h	/^  unsigned parmPush:1;          \/* parameter push Vs spill push *\/$/;"	m	struct:iCode
parm_types	port.h	/^  char *parm_types[MAX_BUILTIN_ARGS];   \/* each parm type as string : see typeFromStr *\/$/;"	m	struct:builtins
parms_in_bank1	SDCCglobl.h	/^    int parms_in_bank1;         \/* DS390 - use reg bank1 to pass parameters *\/$/;"	m	struct:options
parseCmdLine	SDCCmain.c	/^parseCmdLine (int argc, char **argv)$/;"	f	file:
parseOption	port.h	/^  bool (*parseOption) (int *pargc, char **argv, int *i);$/;"	m
partOfLoop	SDCCBBlock.h	/^  struct region *partOfLoop;    \/* pointer to the loop region this block is part of *\/$/;"	m	struct:eBBlock
passedLabel	SDCCpeeph.h	/^    bool passedLabel;$/;"	m
pathExists	SDCCutil.c	/^pathExists (const char *ppath)$/;"	f
pattern1	SDCCptropt.c	/^pattern1 (iCode * sic)$/;"	f	file:
pattern2	SDCCptropt.c	/^pattern2 (iCode * sic)$/;"	f	file:
pcDistance	SDCCpeeph.c	/^pcDistance (lineNode * cpos, char *lbl, bool back)$/;"	f	file:
pcseDef	SDCCcse.c	/^pcseDef (void *item, va_list ap)$/;"	f
pdata	SDCCmem.c	/^memmap *pdata = NULL;           \/* paged external data         *\/$/;"	v
pdata_name	port.h	/^    const char *const pdata_name;$/;"	m
peekSet	SDCCset.c	/^peekSet (set * sp)$/;"	f
peep	port.h	/^  peep;$/;"	m
peepHole	SDCCpeeph.c	/^peepHole (lineNode ** pls)$/;"	f
peepReturn	SDCCglobl.h	/^    int peepReturn;             \/* enable peephole optimization for return instructions *\/$/;"	m	struct:options
peepRule	SDCCpeeph.h	/^peepRule;$/;"	t
peepRule	SDCCpeeph.h	/^typedef struct peepRule$/;"	s
peep_file	SDCCglobl.h	/^    char *peep_file;            \/* additional rules for peep hole *\/$/;"	m	struct:options
piCode	SDCCicode.c	/^piCode (void *item, FILE * of)$/;"	f
picAddrOf	SDCCicode.c	/^PRINTFUNC (picAddrOf);$/;"	v
picAssign	SDCCicode.c	/^PRINTFUNC (picAssign);$/;"	v
picCast	SDCCicode.c	/^PRINTFUNC (picCast);$/;"	v
picCritical	SDCCicode.c	/^PRINTFUNC (picCritical);$/;"	v
picDummyRead	SDCCicode.c	/^PRINTFUNC (picDummyRead);$/;"	v
picEndCritical	SDCCicode.c	/^PRINTFUNC (picEndCritical);$/;"	v
picGeneric	SDCCicode.c	/^PRINTFUNC (picGeneric);$/;"	v
picGenericOne	SDCCicode.c	/^PRINTFUNC (picGenericOne);$/;"	v
picGetValueAtAddr	SDCCicode.c	/^PRINTFUNC (picGetValueAtAddr);$/;"	v
picGoto	SDCCicode.c	/^PRINTFUNC (picGoto);$/;"	v
picIfx	SDCCicode.c	/^PRINTFUNC (picIfx);$/;"	v
picInline	SDCCicode.c	/^PRINTFUNC (picInline);$/;"	v
picJumpTable	SDCCicode.c	/^PRINTFUNC (picJumpTable);$/;"	v
picLabel	SDCCicode.c	/^PRINTFUNC (picLabel);$/;"	v
picReceive	SDCCicode.c	/^PRINTFUNC (picReceive);$/;"	v
picSetValueAtAddr	SDCCicode.c	/^PRINTFUNC (picSetValueAtAddr);$/;"	v
pkey	SDCChasht.h	/^    void *pkey;$/;"	m	struct:hashtItem
plain_opts	port.h	/^    const char *plain_opts;$/;"	m
pointerTypeToGPByte	SDCCglue.c	/^pointerTypeToGPByte (const int p_type, const char *iname, const char *oname)$/;"	f
pointerTypes	SDCCsymt.c	/^pointerTypes (sym_link * ptr, sym_link * type)$/;"	f
poptions	port.h	/^  OPTION *poptions;$/;"	m
populateMainValues	SDCCutil.c	/^populateMainValues (const char **ppin)$/;"	f
populateStringHash	SDCCutil.c	/^populateStringHash (const char **pin)$/;"	f
port	SDCCmain.c	/^PORT *port;$/;"	v
post_static_name	port.h	/^    const char *const post_static_name;$/;"	m
powof2	SDCCsymt.c	/^powof2 (TYPE_TARGET_ULONG num)$/;"	f
pparameter	SDCCargs.h	/^    void *pparameter;$/;"	m
pragma_s	port.h	/^struct pragma_s$/;"	s
pragma_tbl	SDCClex.c	/^static struct pragma_s pragma_tbl[] = {$/;"	v	file:
pragma_token_e	SDCCutil.h	/^enum pragma_token_e$/;"	g
pragma_token_s	SDCCutil.h	/^struct pragma_token_s$/;"	s
preArgvSet	SDCCmain.c	/^set *preArgvSet = NULL;         \/* pre-processor arguments  *\/$/;"	v
preHeader	SDCCBBlock.h	/^  struct eBBlock *preHeader;    \/* preheader if this is a loop entry *\/$/;"	m	struct:eBBlock
preProcOnly	SDCCmain.c	/^int preProcOnly = 0;$/;"	v
preProcess	SDCCmain.c	/^preProcess (char **envp)$/;"	f	file:
predList	SDCCBBlock.h	/^  set *predList;                \/* predecessors of this basic block    *\/$/;"	m	struct:eBBlock
prereqv	SDCCsymt.h	/^  struct symbol *prereqv;           \/* symbol before register equiv. substitution *\/$/;"	m	struct:symbol
prev	SDCCgen.h	/^  struct lineNode_s *prev;$/;"	m	struct:lineNode_s
prev	SDCCicode.h	/^  struct iCode *prev;           \/* previous in chain *\/$/;"	m	struct:iCode
prev	SDCCsymt.h	/^  struct bucket *prev;          \/* ptr 2 previous bucket      *\/$/;"	m	struct:bucket
printAllocInfo	SDCCmem.c	/^printAllocInfo (symbol * func, struct dbuf_s * oBuf)$/;"	f
printAllocInfoSeg	SDCCmem.c	/^printAllocInfoSeg (memmap * map, symbol * func, struct dbuf_s *oBuf)$/;"	f	file:
printCLine	SDCCasm.c	/^printCLine (const char *srcFile, int lineno)$/;"	f
printChar	SDCCglue.c	/^printChar (struct dbuf_s *oBuf, const char *s, int plen)$/;"	f
printCyclomatic	SDCCopt.c	/^printCyclomatic (eBBlock ** ebbs, int count)$/;"	f	file:
printEntryLabel	SDCCBBlock.h	/^DEFSETFUNC (printEntryLabel);$/;"	v
printExterns	SDCCglue.c	/^printExterns (FILE * afile)$/;"	f
printFromToType	SDCCsymt.c	/^printFromToType (sym_link * from, sym_link * to)$/;"	f
printGPointerType	SDCCglue.c	/^printGPointerType (struct dbuf_s *oBuf, const char *iname, const char *oname, int type)$/;"	f	file:
printILine	SDCCasm.c	/^printILine (iCode * ic)$/;"	f
printIval	SDCCglue.c	/^printIval (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf, bool check)$/;"	f
printIvalArray	SDCCglue.c	/^printIvalArray (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf, bool check)$/;"	f
printIvalBitFields	SDCCglue.c	/^printIvalBitFields (symbol ** sym, initList ** ilist, struct dbuf_s *oBuf)$/;"	f	file:
printIvalChar	SDCCglue.c	/^printIvalChar (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf, const char *s, bool check)$/;"	f
printIvalCharPtr	SDCCglue.c	/^printIvalCharPtr (symbol * sym, sym_link * type, value * val, struct dbuf_s *oBuf)$/;"	f
printIvalFuncPtr	SDCCglue.c	/^printIvalFuncPtr (sym_link * type, initList * ilist, struct dbuf_s *oBuf)$/;"	f
printIvalPtr	SDCCglue.c	/^printIvalPtr (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf)$/;"	f
printIvalStruct	SDCCglue.c	/^printIvalStruct (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf)$/;"	f	file:
printIvalType	SDCCglue.c	/^printIvalType (symbol * sym, sym_link * type, initList * ilist, struct dbuf_s *oBuf)$/;"	f
printLine	SDCCgen.c	/^printLine (lineNode * head, struct dbuf_s *oBuf)$/;"	f
printName	SDCCicode.h	/^  char *printName;$/;"	m	struct:icodeFuncTable
printOperand	SDCCicode.c	/^printOperand (operand * op, FILE * file)$/;"	f
printOptions	SDCCmain.c	/^printOptions (const OPTION * optionsTable, FILE * stream)$/;"	f	file:
printPointerType	SDCCglue.c	/^printPointerType (struct dbuf_s *oBuf, const char *name)$/;"	f	file:
printPublics	SDCCglue.c	/^printPublics (FILE * afile)$/;"	f
printSearchDirs	SDCCglobl.h	/^    int printSearchDirs;        \/* display the directories in the compiler's search path *\/$/;"	m	struct:options
printSymName	SDCCopt.c	/^printSymName (void *vsym)$/;"	f
printTypeChain	SDCCsymt.c	/^printTypeChain (sym_link * start, FILE * of)$/;"	f
printTypeChainRaw	SDCCsymt.c	/^printTypeChainRaw (sym_link * start, FILE * of)$/;"	f
printUsage	SDCCmain.c	/^printUsage (void)$/;"	f	file:
printVersionInfo	SDCCmain.c	/^printVersionInfo (FILE * stream)$/;"	f
printiCChain	SDCCicode.c	/^printiCChain (iCode * icChain, FILE * of)$/;"	f
processBlockVars	SDCCast.c	/^processBlockVars (ast * tree, int *stack, int action)$/;"	f
processFile	SDCCmain.c	/^processFile (char *s)$/;"	f	file:
processFuncArgs	SDCCsymt.c	/^processFuncArgs (symbol * func)$/;"	f
processFuncPtrArgs	SDCCsymt.c	/^processFuncPtrArgs (sym_link * funcType)$/;"	f
processParms	SDCCast.c	/^processParms (ast * func, value * defParm, ast ** actParm, int *parmNumber,     \/* unused, although updated *\/$/;"	f	file:
processRegParms	SDCCast.c	/^processRegParms (value * args, ast * body)$/;"	f	file:
process_pragma	SDCClex.c	/^process_pragma (const char *s)$/;"	f	file:
process_pragma	port.h	/^  int (*process_pragma) (const char *sz);$/;"	m
process_pragma_tbl	SDCClex.c	/^process_pragma_tbl (const struct pragma_s *pragma_tbl, const char *s)$/;"	f
processor	port.h	/^  char *processor;$/;"	m
profile	SDCCglobl.h	/^    int profile;                \/* Turn on extra profiling information *\/$/;"	m	struct:options
program_name	SDCCmain.c	/^program_name (const char *path)$/;"	f	file:
promoteAnonStructs	SDCCsymt.c	/^promoteAnonStructs (int su, structdef * sdef)$/;"	f
protect_sp_update	SDCCglobl.h	/^    int protect_sp_update;      \/* DS390 - will disable interrupts during ESP:SP updates *\/$/;"	m	struct:options
psbase	SDCCsymt.h	/^  struct symbol *psbase;            \/* if pseudo symbol, the symbol it is based on *\/$/;"	m	struct:symbol
ptrAddition	SDCCptropt.c	/^ptrAddition (iCode * sic)$/;"	f
ptrArithmetic	SDCCglobl.h	/^    int ptrArithmetic;$/;"	m	struct:optimize
ptrBaseRematSym	SDCCptropt.c	/^ptrBaseRematSym (symbol * ptrsym)$/;"	f
ptrPostIncDecOpt	SDCCptropt.c	/^ptrPostIncDecOpt (iCode * sic)$/;"	f
ptrPseudoSymConvert	SDCCptropt.c	/^ptrPseudoSymConvert (symbol * sym, iCode * dic, const char *name)$/;"	f
ptrPseudoSymSafe	SDCCptropt.c	/^ptrPseudoSymSafe (symbol * sym, iCode * dic)$/;"	f
ptrType	SDCCmem.h	/^    int ptrType;                \/* pointer Type for this space *\/$/;"	m	struct:memmap
ptr_addrspace	SDCCsymt.h	/^  struct symbol *ptr_addrspace;     \/* pointer is in named address space  *\/$/;"	m	struct:declarator
ptr_const	SDCCsymt.h	/^  unsigned ptr_const:1;             \/* pointer is constant        *\/$/;"	m	struct:declarator
ptr_restrict	SDCCsymt.h	/^  unsigned ptr_restrict:1;          \/* pointer is resticted       *\/$/;"	m	struct:declarator
ptr_size	port.h	/^    int ptr_size;               \/\/near$/;"	m
ptr_volatile	SDCCsymt.h	/^  unsigned ptr_volatile:1;          \/* pointer is volatile        *\/$/;"	m	struct:declarator
ptrreg	SDCCsymt.h	/^  unsigned ptrreg:1;                \/* this symbol assigned to a ptr reg *\/$/;"	m	struct:symbol
ptrsSet	SDCCBBlock.h	/^  bitVect *ptrsSet;             \/* pointers assigned values in the block *\/$/;"	m	struct:eBBlock
ptt	SDCCast.c	/^ptt (ast * tree)$/;"	f
publics	SDCCglue.c	/^set *publics = NULL;            \/* public variables *\/$/;"	v
rMask	SDCCicode.h	/^  bitVect *rMask;               \/* registers in use during this instruction *\/$/;"	m	struct:iCode
rSurv	SDCCicode.h	/^  bitVect *rSurv;               \/* registers that survive this instruction (i.e. they are in use, it is not their last use and they are not in the return) *\/$/;"	m	struct:iCode
rUsed	SDCCicode.h	/^  bitVect *rUsed;               \/* registers used by this instruction *\/$/;"	m	struct:iCode
rbank	SDCCsymt.h	/^    unsigned rbank:1;               \/* seperate register bank               *\/$/;"	m	struct:sym_link::<anonymous>
readFileIntoBuffer	SDCCpeeph.c	/^readFileIntoBuffer (char *fname)$/;"	f	file:
readRules	SDCCpeeph.c	/^readRules (char *bp)$/;"	f	file:
reassociate_ic	SDCCpeeph.c	/^reassociate_ic (lineNode *shead, lineNode *stail,$/;"	f	file:
reassociate_ic_down	SDCCpeeph.c	/^reassociate_ic_down (lineNode *shead, lineNode *stail,$/;"	f	file:
reassociate_ic_up	SDCCpeeph.c	/^reassociate_ic_up (lineNode *shead, lineNode *stail,$/;"	f	file:
recomputeLiveRanges	SDCClrange.c	/^recomputeLiveRanges (eBBlock ** ebbs, int count)$/;"	f
recvSize	SDCCsymt.h	/^  int recvSize;                     \/* size of first argument  *\/$/;"	m	struct:symbol
redoStackOffsets	SDCCmem.c	/^redoStackOffsets (void)$/;"	f
reent	SDCCsymt.h	/^    unsigned reent:1;               \/* function is reentrant                *\/$/;"	m	struct:sym_link::<anonymous>
reent_overhead	port.h	/^    int reent_overhead;$/;"	m
reentrant	SDCCy.c	/^int reentrant = 0;$/;"	v
ref	SDCCdwarf2.h	/^    struct dwtag * ref;$/;"	m	union:dwattr::<anonymous>
refCount	SDCCpeeph.h	/^    int refCount;$/;"	m
reg	SDCCmem.c	/^memmap *reg = NULL;             \/* register space              *\/$/;"	v
regBlocks	SDCCloop.h	/^    set *regBlocks;		\/* set of all blocks *\/$/;"	m	struct:region
regNum	port.h	/^      int (*regNum) (const struct reg_info *);$/;"	m
regNumBP	port.h	/^      int regNumBP;$/;"	m
regNumRet	port.h	/^      int regNumRet;$/;"	m
regNumSP	port.h	/^      int regNumSP;$/;"	m
regType	SDCCsymt.h	/^  short regType;                    \/* type of register required    *\/$/;"	m	struct:symbol
reg_name	port.h	/^    const char *const reg_name;$/;"	m
reg_parm	port.h	/^  int (*reg_parm) (struct sym_link *, bool reentrant);  \/* will return 1 if can be passed in register *\/$/;"	m
regalloc_dry_run	SDCCmain.c	/^bool regalloc_dry_run = FALSE;$/;"	v
regbank	SDCCsymt.h	/^    short regbank;                  \/* register bank 2b used                *\/$/;"	m	struct:sym_link::<anonymous>
region	SDCCdwarf2.h	/^  dwlocregion * region;$/;"	m	struct:dwloclist
region	SDCCloop.h	/^region;$/;"	t
region	SDCCloop.h	/^typedef struct region$/;"	s
regs	SDCCsymt.h	/^  struct reg_info *regs[8];         \/* can have at the most 8 registers *\/$/;"	m	struct:symbol
regsRead	SDCCgen.h	/^  bitVect *regsRead;$/;"	m	struct:asmLineNodeBase
regsSaved	SDCCicode.h	/^  unsigned regsSaved:1;         \/* registers have been saved *\/$/;"	m	struct:iCode
regsUsed	SDCCsymt.h	/^  struct bitVect *regsUsed;         \/* for functions registers used *\/$/;"	m	struct:symbol
regsWritten	SDCCgen.h	/^  bitVect *regsWritten;$/;"	m	struct:asmLineNodeBase
regsp	SDCCmem.h	/^    unsigned regsp:1;           \/* 1 = sfr space               *\/$/;"	m	struct:memmap
relFilesSet	SDCCmain.c	/^set *relFilesSet = NULL;$/;"	v
rel_ext	port.h	/^    const char *rel_ext;$/;"	m
remainSpil	SDCCsymt.h	/^  unsigned remainSpil:1;            \/* spilt because not used in remainder *\/$/;"	m	struct:symbol
remat	SDCCsymt.h	/^  unsigned remat:1;                 \/* can be remateriazed *\/$/;"	m	struct:symbol
rematiCode	SDCCsymt.h	/^  struct iCode *rematiCode;         \/* rematerialise with which instruction *\/$/;"	m	struct:symbol
remiCodeFromeBBlock	SDCCBBlock.c	/^remiCodeFromeBBlock (eBBlock * ebb, iCode * ic)$/;"	f
removedCast	SDCCast.h	/^      unsigned removedCast:1;   \/* true if the explicit cast has been removed *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
reorderIlist	SDCCval.c	/^initList *reorderIlist (sym_link * type, initList * ilist)$/;"	f
replLoopSym	SDCCast.c	/^replLoopSym (ast * body, symbol * sym)$/;"	f	file:
replace	SDCCpeeph.h	/^    lineNode *replace;$/;"	m	struct:peepRule
replaceAllSymBySym	SDCCcse.c	/^replaceAllSymBySym (iCode * ic, operand * from, operand * to, bitVect ** ndpset)$/;"	f
replaceAstWithTemporary	SDCCast.c	/^replaceAstWithTemporary (ast ** treeptr)$/;"	f	file:
replaceLabel	SDCCBBlock.c	/^replaceLabel (eBBlock * ebp, symbol * fromLbl, symbol * toLbl)$/;"	f
replaceRegEqv	SDCCopt.c	/^replaceRegEqv (ebbIndex * ebbi)$/;"	f	file:
replaceRule	SDCCpeeph.c	/^replaceRule (lineNode ** shead, lineNode * stail, peepRule * pr)$/;"	f	file:
replaceSymBySym	SDCCBBlock.c	/^replaceSymBySym (set * sset, operand * src, operand * dest)$/;"	f
req	SDCCicode.c	/^  int req;$/;"	m	struct:lvalItem	file:
reqv	SDCCsymt.h	/^  struct operand *reqv;             \/* register equivalent of a local variable *\/$/;"	m	struct:symbol
resetParmKey	SDCCast.h	/^DEFSETFUNC (resetParmKey);$/;"	v
reset_labelKey	port.h	/^  int reset_labelKey;           \/* reset Label no 1 at the start of a function *\/$/;"	m
reset_regparms	port.h	/^  void (*reset_regparms) (void);        \/* reset the register count *\/$/;"	m
resolveIvalSym	SDCCval.c	/^resolveIvalSym (initList * ilist, sym_link * type)$/;"	f
resolveSymbols	SDCCast.c	/^resolveSymbols (ast * tree)$/;"	f
restart	SDCCpeeph.h	/^    unsigned int restart:1;$/;"	m	struct:peepRule
result	SDCCicode.h	/^      operand *result;          \/* result of this op *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
resultTypePropagate	SDCCast.c	/^resultTypePropagate (ast * tree, RESULT_TYPE resultType)$/;"	f	file:
retlab	SDCCast.c	/^  symbol *retlab;               \/* label ending inlined function (virtual return) *\/$/;"	m	file:
retsym	SDCCast.c	/^  symbol *retsym;               \/* variable for inlined function return value *\/$/;"	m	file:
returnAtEnd	SDCCcflow.c	/^int returnAtEnd (eBBlock *ebp)$/;"	f
returnLabel	SDCCicode.c	/^symbol *returnLabel;            \/* function return label *\/$/;"	v
revDesignation	SDCCval.c	/^revDesignation (designation * val)$/;"	f
reverseLink	SDCCsymt.c	/^reverseLink (sym_link * type)$/;"	f
reverseLoop	SDCCast.c	/^reverseLoop (ast * loop, symbol * sym, ast * init, ast * end)$/;"	f
reverseParms	SDCCast.c	/^reverseParms (ast * ptree)$/;"	f	file:
reverseSet	SDCCset.c	/^reverseSet (set * s)$/;"	f
reverseSyms	SDCCsymt.c	/^reverseSyms (symbol * sym)$/;"	f
reverseVal	SDCCval.c	/^reverseVal (value * val)$/;"	f
reverseValWithType	SDCCval.c	/^reverseValWithType (value * val)$/;"	f
reversed	SDCCast.h	/^  unsigned reversed:1;$/;"	m	struct:ast
reverseiCChain	SDCCicode.c	/^reverseiCChain ()$/;"	f
revinit	SDCCval.c	/^revinit (initList * val)$/;"	f
right	SDCCast.h	/^  struct ast *right;            \/* pointer to right tree   *\/$/;"	m	struct:ast
right	SDCCicode.h	/^      operand *right;           \/* right if any  *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
riu	SDCCicode.h	/^  char riu;                     \/* after ralloc, the registers in use *\/$/;"	m	struct:iCode
rlive	SDCCicode.h	/^  bitVect *rlive;               \/* ranges that are live at this point *\/$/;"	m	struct:iCode
rliveClear	SDCClrange.c	/^rliveClear (eBBlock ** ebbs, int count)$/;"	f	file:
rlivePoint	SDCClrange.c	/^rlivePoint (eBBlock ** ebbs, int count, bool emitWarnings)$/;"	f	file:
rlrr	SDCCsymt.c	/^symbol *rlrr[2][4][2];$/;"	v
rname	SDCCsymt.h	/^  char rname[SDCC_NAME_MAX + 1];    \/* internal name           *\/$/;"	m	struct:symbol
rootRules	SDCCpeeph.c	/^static peepRule *rootRules = NULL;$/;"	v	file:
rtype	port.h	/^  char *rtype;                  \/* return type as string : see typeFromStr *\/$/;"	m	struct:builtins
ruonly	SDCCsymt.h	/^  unsigned ruonly:1;                \/* used in return statement only *\/$/;"	m	struct:symbol
rvalue	SDCCast.h	/^  unsigned rvalue:1;$/;"	m	struct:ast
s	SDCCsymt.h	/^    specifier s;                    \/* if CLASS == SPECIFIER      *\/$/;"	m	union:sym_link::<anonymous>
s	port.h	/^  s;$/;"	m
scanOptionsTable	SDCCmain.c	/^scanOptionsTable (const OPTION * optionsTable, char shortOpt, const char *longOpt, char **argv, int *pi, int argc)$/;"	f	file:
sch	SDCCBBlock.h	/^  iCode *sch;                   \/* pointer to start of code chain *\/$/;"	m	struct:eBBlock
sclass	SDCCsymt.h	/^  STORAGE_CLASS sclass;             \/* REGISTER,AUTO,FIX,CONSTANT *\/$/;"	m	struct:specifier
sclsFromPtr	SDCCsymt.c	/^sclsFromPtr (sym_link * ptr)$/;"	f
scopeLevel	SDCCicode.c	/^int scopeLevel;$/;"	v
sdcc_pclose	SDCCsystem.c	/^sdcc_pclose (FILE *fp)$/;"	f
sdcc_popen	SDCCsystem.c	/^sdcc_popen (const char *cmd)$/;"	f
sdcc_popen_read	SDCCsystem.c	375;"	d	file:
sdcc_popen_read	SDCCsystem.c	382;"	d	file:
sdcc_system	SDCCsystem.c	/^sdcc_system (const char *cmd)$/;"	f
sdef	SDCCy.c	/^    structdef  *sdef;       \/* structure definition                   *\/$/;"	m	union:YYSTYPE	file:
sdef	SDCCy.h	/^    structdef  *sdef;       \/* structure definition                   *\/$/;"	m	union:YYSTYPE
searchLitOp	SDCCast.c	/^searchLitOp (ast * tree, ast ** parent, const char *ops)$/;"	f	file:
select	SDCCsymt.h	/^  } select;$/;"	m	struct:sym_link
separateAddressSpaces	SDCCopt.c	/^separateAddressSpaces (eBBlock ** ebbs, int count)$/;"	f	file:
seq	SDCCicode.h	/^  int seq;                      \/* sequence number within routine *\/$/;"	m	struct:iCode
seqPoint	SDCCast.h	/^  int seqPoint;                 \/* sequence point *\/$/;"	m	struct:ast
seqPoint	SDCCicode.c	/^int seqPoint;$/;"	v
seqPoint	SDCCicode.h	/^  int seqPoint;                 \/* sequence point *\/$/;"	m	struct:iCode
seqPointNo	SDCCy.c	/^int seqPointNo= 1;      \/* sequence point number *\/$/;"	v
sequenceiCode	SDCClrange.c	/^sequenceiCode (eBBlock ** ebbs, int count)$/;"	f	file:
set	SDCCset.h	/^set;$/;"	t
set	SDCCset.h	/^typedef struct set$/;"	s
setAstFileLine	SDCCast.c	/^setAstFileLine (ast * tree, char *filename, int lineno)$/;"	f
setBinPaths	SDCCmain.c	/^setBinPaths (const char *argv0)$/;"	f	file:
setDataPaths	SDCCmain.c	/^setDataPaths (const char *argv0)$/;"	f	file:
setDefaultOptions	SDCCmain.c	/^setDefaultOptions (void)$/;"	f	file:
setDefaultOptions	port.h	/^  void (*setDefaultOptions) (void);$/;"	m
setErrorLogLevel	SDCCerr.c	/^void setErrorLogLevel (ERROR_LOG_LEVEL level)$/;"	f
setFirstItem	SDCCset.c	/^setFirstItem (set * sset)$/;"	f
setFromConditionArgs	SDCCpeeph.c	/^setFromConditionArgs (char *cmdLine, hTab * vars)$/;"	f	file:
setFromSet	SDCCset.c	/^setFromSet (set * lp)$/;"	f
setFromSetNonRev	SDCCset.c	/^setFromSetNonRev (set * lp)$/;"	f
setIncludePath	SDCCmain.c	/^setIncludePath (void)$/;"	f	file:
setLibPath	SDCCmain.c	/^setLibPath (void)$/;"	f	file:
setLiveFrom	SDCClrange.c	/^setLiveFrom (symbol * sym, int from)$/;"	f	file:
setLiveTo	SDCClrange.c	/^setLiveTo (symbol * sym, int to)$/;"	f	file:
setMainValue	SDCCutil.c	/^setMainValue (const char *pname, const char *pvalue)$/;"	f
setNextItem	SDCCset.c	/^setNextItem (set * sset)$/;"	f
setOClass	SDCCicode.c	/^setOClass (sym_link * ptr, sym_link * spec)$/;"	f
setOperandType	SDCCicode.c	/^setOperandType (operand * op, sym_link * type)$/;"	f
setParseWithComma	SDCCmain.c	/^setParseWithComma (set ** dest, const char *src)$/;"	f
setToNull	SDCCset.c	/^setToNull (void **item)$/;"	f
setToRange	SDCClrange.c	/^setToRange (operand * op, int to, bool check)$/;"	f
setUsesDefs	SDCCcse.c	/^setUsesDefs (operand * op, bitVect * bdefs,$/;"	f
setWError	SDCCerr.c	/^setWError (int flag)$/;"	f
setWarningDisabled	SDCCerr.c	/^setWarningDisabled (int errNum)$/;"	f
sfr	SDCCmem.c	/^memmap *sfr = NULL;             \/* register space              *\/$/;"	v
sfrbit	SDCCmem.c	/^memmap *sfrbit = NULL;          \/* sfr bit space               *\/$/;"	v
shadowregs	SDCCsymt.h	/^    unsigned shadowregs:1;          \/* function uses shadow registers (pic16 port) *\/$/;"	m	struct:sym_link::<anonymous>
shash_add	SDCChasht.c	/^shash_add (hTab ** h, const char *szKey, const char *szValue)$/;"	f
shash_find	SDCChasht.c	/^shash_find (hTab * h, const char *szKey)$/;"	f
shellEscapeStrSet	SDCCutil.c	/^shellEscapeStrSet (set * list)$/;"	f
shell_escape	SDCCutil.c	/^shell_escape (const char *str)$/;"	f
shift	port.h	/^    unsigned shift;$/;"	m
shortOpt	SDCCargs.h	/^    char shortOpt;$/;"	m
shortOpt	SDCCmain.c	/^  char shortOpt;$/;"	m	file:
short_size	port.h	/^    int short_size;$/;"	m
shortis8bits	SDCCglobl.h	/^    int shortis8bits;           \/* treat short like int or char *\/$/;"	m	struct:options
siblings	SDCCdwarf2.h	/^  struct dwtag * siblings;$/;"	m	struct:dwtag
sig_handler	SDCCmain.c	/^sig_handler (int signal)$/;"	f	file:
size	SDCCbitv.h	/^    int size;$/;"	m	struct:bitVect
size	SDCCgen.h	/^  int size;$/;"	m	struct:asmLineNodeBase
size	SDCChasht.h	/^    int size;			\/* max number of items *\/$/;"	m	struct:hTab
size	SDCCsymt.h	/^  unsigned size;                \/* sizeof the table in bytes  *\/$/;"	m	struct:structdef
sizeofDispatch	port.h	/^    int sizeofDispatch;$/;"	m
sizeofElement	port.h	/^    int sizeofElement;$/;"	m
sizeofMatchJump	port.h	/^    int sizeofMatchJump[3];$/;"	m
sizeofOp	SDCCast.c	/^sizeofOp (sym_link * type)$/;"	f
sizeofRangeCompare	port.h	/^    int sizeofRangeCompare[3];$/;"	m
sizeofSubtract	port.h	/^    int sizeofSubtract;$/;"	m
skipLine	SDCCasm.c	/^skipLine (FILE * infp)$/;"	f	file:
skip_whitespace	altlex.c	/^skip_whitespace (int c)$/;"	f	file:
slbl	SDCCmem.h	/^    int slbl;                   \/* label counter for space     *\/$/;"	m	struct:memmap
sloc	SDCCmem.h	/^    unsigned sloc;              \/* starting location           *\/$/;"	m	struct:memmap
smallc	SDCCsymt.h	/^    unsigned smallc:1;              \/* Parameters on stack are passed in reverse order *\/$/;"	m	struct:sym_link::<anonymous>
sname	SDCCmem.h	/^    const char *sname;          \/* character prefix for map    *\/$/;"	m	struct:memmap
spacesToUnderscores	cdbFile.c	/^spacesToUnderscores (char *dest, const char *src, size_t len)$/;"	f	file:
specifier	SDCCsymt.h	/^specifier;$/;"	t
specifier	SDCCsymt.h	/^typedef struct specifier$/;"	s
spildir	SDCCsymt.h	/^  unsigned spildir:1;               \/* spilt in direct space *\/$/;"	m	struct:symbol
spillA	SDCCsymt.h	/^  unsigned spillA:1;                \/* spilt be register allocator *\/$/;"	m	struct:symbol
spillLoc	SDCCsymt.h	/^    struct symbol *spillLoc;        \/* register spil location *\/$/;"	m	union:symbol::<anonymous>
split_command	SDCCsystem.c	/^split_command (const char *cmd_line, char **command, char **params)$/;"	f	file:
srcFile	SDCCmain.c	/^FILE *srcFile;                  \/* source file          *\/$/;"	v
stack	SDCCsymt.h	/^  int stack;                        \/* offset on stack      *\/$/;"	m	struct:symbol
stack	port.h	/^  stack;$/;"	m
stack10bit	SDCCglobl.h	/^    int stack10bit;             \/* use 10 bit stack (flat24 model only) *\/$/;"	m	struct:options
stackAuto	SDCCglobl.h	/^    int stackAuto;              \/* Stack Automatic  *\/$/;"	m	struct:options
stackPtr	SDCCy.c	/^int stackPtr  = 1;      \/* stack pointer           *\/$/;"	v
stackSpil	SDCCsymt.h	/^  unsigned stackSpil:1;             \/* has been spilt on temp stack location *\/$/;"	m	struct:symbol
stack_loc	SDCCglobl.h	/^    int stack_loc;              \/* initial value of internal stack pointer *\/$/;"	m	struct:options
stack_probe	SDCCglobl.h	/^    int stack_probe;            \/* insert call to function __stack_probe *\/$/;"	m	struct:options
stack_size	SDCCglobl.h	/^    int stack_size;             \/* MCS51\/DS390 - Tells the linker to allocate this space for stack *\/$/;"	m	struct:options
startLabel	SDCCdwarf2.h	/^  char * startLabel;$/;"	m	struct:dwlocregion
startsWith	SDCCutil.c	/^startsWith (const char *sz, const char *key)$/;"	f
staticAutos	SDCCast.c	/^ast *staticAutos = NULL;$/;"	v
static_name	port.h	/^    const char *const static_name;$/;"	m
statsg	SDCCmem.c	/^memmap *statsg = NULL;          \/* the constant data segment   *\/$/;"	v
std_c11	SDCCglobl.h	/^    int std_c11;                \/* enable C11 keywords\/constructs *\/$/;"	m	struct:options
std_c99	SDCCglobl.h	/^    int std_c99;                \/* enable C99 keywords\/constructs *\/$/;"	m	struct:options
std_sdcc	SDCCglobl.h	/^    int std_sdcc;               \/* enable SDCC extensions to C *\/$/;"	m	struct:options
strVal	SDCCval.c	/^strVal (const char *s)$/;"	f
string	SDCCdwarf2.h	/^    const char * string;$/;"	m	union:dwattr::<anonymous>
stringLiteral	SDCClex.c	/^stringLiteral (void)$/;"	f	file:
stringLiteral	altlex.c	/^stringLiteral (void)$/;"	f	file:
stringToSymbol	SDCCast.c	/^stringToSymbol (value * val)$/;"	f	file:
strncatz	SDCCutil.c	/^strncatz (char *dest, const char *src, size_t n)$/;"	f
strncpyz	SDCCutil.c	/^strncpyz (char *dest, const char *src, size_t n)$/;"	f
structElemType	SDCCsymt.c	/^structElemType (sym_link * stype, value * id)$/;"	f
structdef	SDCCsymt.h	/^structdef;$/;"	t
structdef	SDCCsymt.h	/^typedef struct structdef$/;"	s
style	SDCCerr.h	/^  int style;                        \/* 1=MSVC *\/$/;"	m	struct:SDCCERRG
subtractFromSet	SDCCset.c	/^subtractFromSet (set * left, set * right, int throw)$/;"	f
succList	SDCCBBlock.h	/^  set *succList;                \/* list eBBlocks which are successors  *\/$/;"	m	struct:eBBlock
succVect	SDCCBBlock.h	/^  bitVect *succVect;            \/* bitVector of successors (index is bbnum) *\/$/;"	m	struct:eBBlock
support	port.h	/^  support;$/;"	m
supportRtn	SDCCicode.h	/^  unsigned supportRtn:1;        \/* will cause a call to a support routine *\/$/;"	m	struct:iCode
supported_models	port.h	/^    int supported_models;$/;"	m
svt	SDCCicode.h	/^  svt;$/;"	m	struct:operand
swDefault	SDCCast.h	/^      int swDefault;            \/* default if present       *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
swNum	SDCCast.h	/^      int swNum;                \/* switch number            *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
swSuffix	SDCCast.h	/^      char *swSuffix;$/;"	m	struct:ast::<anonymous>::<anonymous>
swVals	SDCCast.h	/^      value *swVals;            \/* switch comparison values *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
switchAddressSpaceAt	SDCCopt.c	/^switchAddressSpaceAt (iCode *ic, const symbol *const addrspace)$/;"	f
switchAddressSpaces	SDCCopt.c	/^switchAddressSpaces (iCode *ic)$/;"	f	file:
switchAddressSpacesOptimally	SDCCnaddr.cc	/^switchAddressSpacesOptimally (iCode *ic, ebbIndex *ebbi)$/;"	f
switchVals	SDCCast.h	/^    switchVals;$/;"	m	union:ast::<anonymous>
sym	SDCCast.h	/^    symbol *sym;                \/* if block then -> symbols *\/$/;"	m	union:ast::<anonymous>
sym	SDCCcse.h	/^    operand *sym;		\/* defining symbol *\/$/;"	m	struct:cseDef
sym	SDCCdwarf2.h	/^    symbol * sym;$/;"	m	struct:dwloc::<anonymous>
sym	SDCCloop.h	/^    operand *sym;$/;"	m	struct:induction
sym	SDCCsymt.h	/^  void *sym;                    \/* pointer to the object      *\/$/;"	m	struct:bucket
sym	SDCCval.h	/^  symbol *sym;                  \/* Original Symbol                  *\/$/;"	m	struct:value
sym	SDCCy.c	/^    symbol     *sym;        \/* symbol table pointer                   *\/$/;"	m	union:YYSTYPE	file:
sym	SDCCy.h	/^    symbol     *sym;        \/* symbol table pointer                   *\/$/;"	m	union:YYSTYPE
symOperand	SDCCicode.h	/^    struct symbol *symOperand;      \/* operand is of type symbol *\/$/;"	m	union:operand::<anonymous>
sym_link	SDCCsymt.h	/^sym_link;$/;"	t
sym_link	SDCCsymt.h	/^typedef struct sym_link$/;"	s
symaddr	SDCCdwarf2.h	/^    } symaddr;$/;"	m	union:dwattr::<anonymous>
symbol	SDCCsymt.h	/^symbol;$/;"	t
symbol	SDCCsymt.h	/^typedef struct symbol$/;"	s
symbolVal	SDCCval.c	/^symbolVal (symbol * sym)$/;"	f
syms	SDCCmem.h	/^    struct set *syms;           \/* symbols defined in this segment *\/$/;"	m	struct:memmap
szKey	SDCCasm.h	/^  const char *szKey;$/;"	m
szValue	SDCCasm.h	/^  const char *szValue;$/;"	m
table	SDCChasht.h	/^    hashtItem **table;		\/* the actual table  *\/$/;"	m	struct:hTab
tag	SDCCdwarf2.h	/^  int tag;$/;"	m	struct:dwtag
tag	SDCCsymt.h	/^  char tag[SDCC_NAME_MAX + 1];  \/* tag part of structure      *\/$/;"	m	struct:structdef
tag	SDCCval.h	/^        struct symbol *tag;             \/* tag part of structure          *\/$/;"	m	union:designation::<anonymous>
tag_code	port.h	/^    int tag_code;$/;"	m
tag_far	port.h	/^    int tag_far;$/;"	m
tag_near	port.h	/^    int tag_near;$/;"	m
tag_xstack	port.h	/^    int tag_xstack;$/;"	m
tagsym	SDCCsymt.h	/^  struct symbol *tagsym;        \/* tag symbol (NULL if no tag) *\/$/;"	m	struct:structdef
target	port.h	/^  const char *const target;$/;"	m
target_name	port.h	/^  const char *const target_name;$/;"	m
tdef	SDCCsymt.h	/^  unsigned tdef:1;                  \/* current link created by     *\/$/;"	m	struct:sym_link
tfprintf	SDCCasm.c	/^tfprintf (FILE *fp, const char *szFormat, ...)$/;"	f
timestamp	SDCCdwarf2.h	/^  int timestamp;$/;"	m	struct:dwfile
tini_libid	SDCCglobl.h	/^    int tini_libid;             \/* library ID for TINI *\/$/;"	m	struct:options
to	SDCCBBlock.h	/^  eBBlock *to;                  \/* to Basic Block   *\/$/;"	m	struct:edge
tree	SDCCicode.h	/^  struct ast *tree;             \/* ast node for this iCode (if not NULL) *\/$/;"	m	struct:iCode
trueLabel	SDCCast.h	/^      symbol *trueLabel;        \/* entry point into body *\/$/;"	m	struct:ast::<anonymous>::<anonymous>
trueLabel	SDCCast.h	/^  symbol *trueLabel;            \/* if statement trueLabel  *\/$/;"	m	struct:ast
trueLabel	SDCCicode.h	/^      symbol *trueLabel;        \/* true for conditional     *\/$/;"	m	struct:iCode::<anonymous>::<anonymous>
tryHandleSimpleOpt	SDCCmain.c	/^tryHandleSimpleOpt (char **argv, int *pi, int argc)$/;"	f	file:
tryHandleUnsupportedOpt	SDCCmain.c	/^tryHandleUnsupportedOpt (char **argv, int *pi)$/;"	f	file:
tspec	SDCCsymt.h	/^  struct sym_link *tspec;           \/* pointer type specifier     *\/$/;"	m	struct:declarator
type	SDCCast.h	/^  ASTTYPE type;$/;"	m	struct:ast
type	SDCCicode.h	/^  OPTYPE type;                      \/* type of operand *\/$/;"	m	struct:operand
type	SDCCsymt.h	/^  int type;                     \/* STRUCT or UNION            *\/$/;"	m	struct:structdef
type	SDCCsymt.h	/^  struct sym_link *type;            \/* 1st link to declarator chain *\/$/;"	m	struct:symbol
type	SDCCutil.h	/^  enum pragma_token_e type;$/;"	m	struct:pragma_token_s
type	SDCCval.h	/^    int type;$/;"	m	struct:designation
type	SDCCval.h	/^  int type;$/;"	m	struct:initList
type	SDCCval.h	/^  sym_link *type;               \/* start of type chain              *\/$/;"	m	struct:value
typeFromStr	SDCCsymt.c	/^typeFromStr (const char *s)$/;"	f
typeOperand	SDCCicode.h	/^    struct sym_link *typeOperand;   \/* operand is of type typechain *\/$/;"	m	union:operand::<anonymous>
type_specifier_list	SDCC.y	/^type_specifier_list : type_specifier_list_ { $$ = finalizeSpec($1); };$/;"	l
udChked	SDCCsymt.h	/^  unsigned udChked:1;               \/* use def checking has been already done *\/$/;"	m	struct:symbol
ulFromVal	SDCCval.c	/^ulFromVal (value * val)$/;"	f
ulrrcnd	SDCCicode.h	/^  ulrrcnd;$/;"	m	struct:iCode
undefined	SDCCsymt.h	/^  unsigned undefined:1;             \/* undefined variable                *\/$/;"	m	struct:symbol
underflow	altlex.c	/^underflow (void)$/;"	f	file:
unionSets	SDCCset.c	/^unionSets (set * list1, set * list2, int throw)$/;"	f
unionSetsWith	SDCCset.c	/^unionSetsWith (set * list1, set * list2, int (*cFunc) (), int throw)$/;"	f
universalEscape	SDCCutil.c	/^universalEscape (const char **str, unsigned int n)$/;"	f
unput	SDCClex.c	135;"	d	file:
unqualified_pointer	port.h	/^  int unqualified_pointer;      \/* unqualified pointers type is  *\/$/;"	m
unsetDefsAndUses	SDCCcse.c	/^unsetDefsAndUses (iCode * ic)$/;"	f
unsigned_char	SDCCglobl.h	/^    int unsigned_char;          \/* use unsigned for char without signed\/unsigned modifier *\/$/;"	m	struct:options
unsupportedOptTable	SDCCmain.c	/^static const UNSUPPORTEDOPT unsupportedOptTable[] = {$/;"	v	file:
unvisitBlocks	SDCClrange.c	/^unvisitBlocks (eBBlock ** ebbs, int count)$/;"	f	file:
updateCseDefAncestors	SDCCcse.c	/^updateCseDefAncestors(cseDef *cdp, set * cseSet)$/;"	f
updateSpillLocation	SDCCcse.c	/^updateSpillLocation (iCode * ic, int induction)$/;"	f
uptr	SDCCsymt.h	/^  unsigned uptr:1;                  \/* used as a pointer *\/$/;"	m	struct:symbol
useAccelerator	SDCCglobl.h	/^    int useAccelerator;         \/* use ds390 Arithmetic Accelerator *\/$/;"	m	struct:options
useXstack	SDCCglobl.h	/^    int useXstack;              \/* use Xternal Stack *\/$/;"	m	struct:options
use_dw_for_init	port.h	/^  bool use_dw_for_init;$/;"	m
use_non_free	SDCCglobl.h	/^    int use_non_free;           \/* Search \/ include non-free licensed libraries and header files *\/$/;"	m	struct:options
use_stdout	SDCCglobl.h	/^    int use_stdout;             \/* send errors to stdout instead of stderr *\/$/;"	m	struct:options
used	SDCCsymt.h	/^  int used;                         \/* no. of times this was used *\/$/;"	m	struct:symbol
usedBetweenPoints	SDCCdflow.c	/^usedBetweenPoints (operand * op, iCode * start, iCode * end)$/;"	f
usedInRemaining	SDCCdflow.c	/^usedInRemaining (operand * op, iCode * ic)$/;"	f
uselessDecl	SDCCy.c	/^bool uselessDecl = TRUE;$/;"	v
userIncDirsSet	SDCCmain.c	/^set *userIncDirsSet = NULL;     \/* list of user include directories *\/$/;"	v
uses	SDCCicode.h	/^  bitVect *uses;                \/* vector of key of used symbols      *\/$/;"	m	struct:iCode
uses	SDCCsymt.h	/^  struct bitVect *uses;             \/* bit vector for uses        *\/$/;"	m	struct:symbol
usesDefs	SDCCBBlock.h	/^  bitVect *usesDefs;            \/* which definitions are used in this block *\/$/;"	m	struct:eBBlock
usesDefs	SDCCicode.h	/^  bitVect *usesDefs;                \/* which definitions are used by this *\/$/;"	m	struct:operand
usl	SDCCsymt.h	/^  usl;$/;"	m	struct:symbol
usualBinaryConversions	SDCCicode.c	/^usualBinaryConversions (operand ** op1, operand ** op2, RESULT_TYPE resultType, int op)$/;"	f	file:
vArgs	SDCCval.h	/^  unsigned vArgs:1;             \/* arg list ended with variable arg *\/$/;"	m	struct:value
v_char	SDCCsymt.h	/^    const char *v_char;               \/*          character string               *\/$/;"	m	union:specifier::<anonymous>
v_enum	SDCCsymt.h	/^    struct symbol *v_enum;            \/* ptr to enum_list if enum==1             *\/$/;"	m	union:specifier::<anonymous>
v_fixed16x16	SDCCsymt.h	/^    TYPE_TARGET_ULONG v_fixed16x16;   \/* 4 bytes: fixed point constant value     *\/$/;"	m	union:specifier::<anonymous>
v_float	SDCCsymt.h	/^    double v_float;                   \/*          floating point constant value  *\/$/;"	m	union:specifier::<anonymous>
v_int	SDCCsymt.h	/^    TYPE_TARGET_INT v_int;            \/* 2 bytes: int and char values            *\/$/;"	m	union:specifier::<anonymous>
v_long	SDCCsymt.h	/^    TYPE_TARGET_LONG v_long;          \/* 4 bytes: long constant value            *\/$/;"	m	union:specifier::<anonymous>
v_longlong	SDCCsymt.h	/^    TYPE_TARGET_LONGLONG v_longlong;  \/* 8 bytes: long long constant value       *\/$/;"	m	union:specifier::<anonymous>
v_struct	SDCCsymt.h	/^  struct structdef *v_struct;       \/* structure pointer      *\/$/;"	m	struct:specifier
v_uint	SDCCsymt.h	/^    TYPE_TARGET_UINT v_uint;          \/* 2 bytes: unsigned int const value       *\/$/;"	m	union:specifier::<anonymous>
v_ulong	SDCCsymt.h	/^    TYPE_TARGET_ULONG v_ulong;        \/* 4 bytes: unsigned long constant value   *\/$/;"	m	union:specifier::<anonymous>
v_ulonglong	SDCCsymt.h	/^    TYPE_TARGET_ULONGLONG v_ulonglong;\/* 8 bytes: unsigned long long const value *\/$/;"	m	union:specifier::<anonymous>
va_emitcode	SDCCgen.c	/^va_emitcode (const char *inst, const char *fmt, va_list ap)$/;"	f
val	SDCCast.h	/^    value *val;                 \/* value if type = EX_VALUE *\/$/;"	m	union:ast::<anonymous>
val	SDCCdwarf2.h	/^  } val;$/;"	m	struct:dwattr
val	SDCCutil.h	/^  } val;$/;"	m	struct:pragma_token_s
val	SDCCy.c	/^    value      *val;        \/* for integer constant                   *\/$/;"	m	union:YYSTYPE	file:
val	SDCCy.h	/^    value      *val;        \/* for integer constant                   *\/$/;"	m	union:YYSTYPE
valBitwise	SDCCval.c	/^valBitwise (value * lval, value * rval, int op)$/;"	f
valCastLiteral	SDCCval.c	/^valCastLiteral (sym_link * dtype, double fval)$/;"	f
valCompare	SDCCval.c	/^valCompare (value * lval, value * rval, int ctype)$/;"	f
valComplement	SDCCval.c	/^valComplement (value * val)$/;"	f
valDiv	SDCCval.c	/^valDiv (value * lval, value * rval)$/;"	f
valForArray	SDCCval.c	/^valForArray (ast * arrExpr)$/;"	f
valForCastAggr	SDCCval.c	/^valForCastAggr (ast * aexpr, sym_link * type, ast * cnst, int op)$/;"	f
valForCastArr	SDCCval.c	/^valForCastArr (ast * aexpr, sym_link * type)$/;"	f
valForStructElem	SDCCval.c	/^valForStructElem (ast * structT, ast * elemT)$/;"	f
valFromType	SDCCval.c	/^valFromType (sym_link * type)$/;"	f
valLogicAndOr	SDCCval.c	/^valLogicAndOr (value * lval, value * rval, int op)$/;"	f
valMinus	SDCCval.c	/^valMinus (value * lval, value * rval)$/;"	f
valMod	SDCCval.c	/^valMod (value * lval, value * rval)$/;"	f
valMult	SDCCval.c	/^valMult (value * lval, value * rval)$/;"	f
valNot	SDCCval.c	/^valNot (value * val)$/;"	f
valOperand	SDCCicode.h	/^    struct value *valOperand;       \/* operand is of type value  *\/$/;"	m	union:operand::<anonymous>
valPlus	SDCCval.c	/^valPlus (value * lval, value * rval)$/;"	f
valShift	SDCCval.c	/^valShift (value * lval, value * rval, int lr)$/;"	f
valUnaryPM	SDCCval.c	/^valUnaryPM (value * val)$/;"	f
validateLink	SDCCsymt.c	/^validateLink (sym_link * l, const char *macro, const char *args, const char select, const char *file, unsigned line)$/;"	f
validateOpType	SDCCicode.c	/^validateOpType (operand * op, const char *macro, const char *args, OPTYPE type, const char *file, unsigned line)$/;"	f
validateOpTypeConst	SDCCicode.c	/^validateOpTypeConst (const operand * op, const char *macro, const char *args, OPTYPE type, const char *file, unsigned line)$/;"	f
value	SDCCval.h	/^typedef struct value$/;"	s
value	SDCCval.h	/^value;$/;"	t
valueFromLit	SDCCval.c	/^valueFromLit (double lit)$/;"	f
values	SDCCast.h	/^  values;$/;"	m	struct:ast
values	SDCCpeeph.c	/^  allocTrace values;$/;"	m	file:
vars	SDCCpeeph.h	/^    hTab *vars;$/;"	m	struct:peepRule
vc_err_style	SDCCglobl.h	/^    int vc_err_style;           \/* errors and warnings are compatible with Micro$oft visual studio *\/$/;"	m	struct:options
vect	SDCCbitv.h	/^    unsigned char *vect;$/;"	m	struct:bitVect
verbose	SDCCglobl.h	/^    int verbose;                \/* Show what the compiler is doing *\/$/;"	m	struct:options
verboseAsm	SDCCglobl.h	/^    int verboseAsm;             \/* include comments generated with gen.c *\/$/;"	m	struct:options
verboseExec	SDCCglobl.h	/^    int verboseExec;            \/* show what we are doing *\/$/;"	m	struct:options
verifyShortOption	SDCCmain.c	/^verifyShortOption (const char *opt)$/;"	f	file:
visited	SDCCBBlock.h	/^  unsigned int visited:1;       \/* visitied flag      *\/$/;"	m	struct:eBBlock
visited	SDCCgen.h	/^  unsigned int visited:1;$/;"	m	struct:lineElem_s
visited	SDCCloop.h	/^    unsigned int visited:1;$/;"	m	struct:region
vwerror	SDCCerr.c	/^vwerror (int errNum, va_list marker)$/;"	f
wassert	SDCCglobl.h	401;"	d
wassertl	SDCCglobl.h	398;"	d
werror	SDCCerr.c	/^werror (int errNum, ...)$/;"	f
werror	SDCCerr.h	/^  int werror;                       \/* treat the warnings as errors *\/$/;"	m	struct:SDCCERRG
werrorfl	SDCCerr.c	/^werrorfl (char *newFilename, int newLineno, int errNum, ...)$/;"	f
while	SDCC.y	/^while : WHILE  {  \/* create and push the continue , break & body labels *\/$/;"	l
wparam	SDCCsymt.h	/^    unsigned wparam:1;              \/* first byte of arguments is passed via WREG (pic16 port) *\/$/;"	m	struct:sym_link::<anonymous>
writeALine	SDCCdebug.h	/^  int (*writeALine) (const char *module, int Line);$/;"	m	struct:DebugFile
writeCLine	SDCCdebug.h	/^  int (*writeCLine) (iCode *ic);$/;"	m	struct:DebugFile
writeEndFunction	SDCCdebug.h	/^  int (*writeEndFunction) (symbol *pSym, iCode *ic, int offset);$/;"	m	struct:DebugFile
writeFrameAddress	SDCCdebug.h	/^  int (*writeFrameAddress) (const char *variable, struct reg_info *reg, int offset);$/;"	m	struct:DebugFile
writeFunction	SDCCdebug.h	/^  int (*writeFunction) (symbol *pSym, iCode *ic);$/;"	m	struct:DebugFile
writeLabel	SDCCdebug.h	/^  int (*writeLabel) (symbol *pSym, iCode *ic);$/;"	m	struct:DebugFile
writeModule	SDCCdebug.h	/^  int (*writeModule) (const char *name);$/;"	m	struct:DebugFile
writeScope	SDCCdebug.h	/^  int (*writeScope) (iCode *ic);$/;"	m	struct:DebugFile
writeSymbol	SDCCdebug.h	/^  int (*writeSymbol) (symbol *pSym);$/;"	m	struct:DebugFile
writeType	SDCCdebug.h	/^  int (*writeType) (structdef *sdef, int block, int inStruct, const char *tag);$/;"	m	struct:DebugFile
x_abs	SDCCmem.c	/^memmap *x_abs = NULL;           \/* absolute xdata\/pdata        *\/$/;"	v
xabs_name	port.h	/^    const char *const xabs_name;        \/\/ absolute xdata\/pdata$/;"	m
xclass	SDCCsymt.h	/^  SYM_LINK_CLASS xclass;            \/* DECLARATOR or SPECIFIER     *\/$/;"	m	struct:sym_link
xdata	SDCCmem.c	/^memmap *xdata = NULL;           \/* external data               *\/$/;"	v
xdata_loc	SDCCglobl.h	/^    int xdata_loc;              \/* xternal ram starts at address *\/$/;"	m	struct:options
xdata_name	port.h	/^    const char *const xdata_name;$/;"	m
xidata	SDCCmem.c	/^memmap *xidata = NULL;          \/* the initialized xdata       *\/$/;"	v
xidata_name	port.h	/^    const char *const xidata_name;      \/\/ initialized xdata$/;"	m
xinit	SDCCmem.c	/^memmap *xinit = NULL;           \/* the initializers for xidata *\/$/;"	v
xinit_name	port.h	/^    const char *const xinit_name;       \/\/ a code copy of xidata$/;"	m
xram_movc	SDCCglobl.h	/^    int xram_movc;              \/* use movc instead of movx to read xram (mcs51) *\/$/;"	m	struct:options
xram_size	SDCCglobl.h	/^    int xram_size;              \/* external ram size (used only for error checking) *\/$/;"	m	struct:options
xram_size_set	SDCCglobl.h	/^    bool xram_size_set;         \/* since xram_size=0 is a possibility *\/$/;"	m	struct:options
xstack	SDCCmem.c	/^memmap *xstack = NULL;          \/* xternal stack data          *\/$/;"	v
xstack	SDCCsymt.h	/^  int xstack;                       \/* offset on xternal stack *\/$/;"	m	struct:symbol
xstackPtr	SDCCy.c	/^int xstackPtr = 0;      \/* xstack pointer          *\/$/;"	v
xstack_loc	SDCCglobl.h	/^    int xstack_loc;             \/* initial location of external stack *\/$/;"	m	struct:options
xstack_name	port.h	/^    const char *const xstack_name;$/;"	m
ygetc	altlex.c	/^ygetc (void)$/;"	f	file:
yungetc	altlex.c	/^yungetc (int c)$/;"	f	file:
yy_NUL_trans	SDCClex.c	/^static yyconst yy_state_type yy_NUL_trans[472] =$/;"	v	file:
yy_accept	SDCClex.c	/^static yyconst short int yy_accept[472] =$/;"	v	file:
yy_at_bol	SDCClex.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	SDCClex.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	SDCClex.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_state	SDCClex.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	SDCClex.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	SDCClex.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	SDCClex.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_create_buffer	SDCClex.c	/^YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )$/;"	f
yy_current_buffer	SDCClex.c	/^static YY_BUFFER_STATE yy_current_buffer = 0;$/;"	v	file:
yy_delete_buffer	SDCClex.c	/^void yy_delete_buffer( YY_BUFFER_STATE b )$/;"	f
yy_did_buffer_switch_on_eof	SDCClex.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_fatal_error	SDCClex.c	/^static void yy_fatal_error( yyconst char msg[] )$/;"	f	file:
yy_fill_buffer	SDCClex.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_alloc	SDCClex.c	/^static void *yy_flex_alloc( yy_size_t size )$/;"	f	file:
yy_flex_free	SDCClex.c	/^static void yy_flex_free( void *ptr )$/;"	f	file:
yy_flex_realloc	SDCClex.c	/^static void *yy_flex_realloc( void *ptr, yy_size_t size )$/;"	f	file:
yy_flex_strlen	SDCClex.c	/^static int yy_flex_strlen( yyconst char *s )$/;"	f	file:
yy_flex_strncpy	SDCClex.c	/^static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )$/;"	f	file:
yy_flush_buffer	SDCClex.c	/^void yy_flush_buffer( YY_BUFFER_STATE b )$/;"	f
yy_get_next_buffer	SDCClex.c	/^static int yy_get_next_buffer()$/;"	f	file:
yy_get_previous_state	SDCClex.c	/^static yy_state_type yy_get_previous_state()$/;"	f	file:
yy_hold_char	SDCClex.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	SDCClex.c	/^static int yy_init = 1;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	SDCClex.c	/^void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )$/;"	f
yy_input_file	SDCClex.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	SDCClex.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	SDCClex.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	SDCClex.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	SDCClex.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	SDCClex.c	/^void yy_load_buffer_state( void )$/;"	f
yy_n_chars	SDCClex.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	SDCClex.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	SDCClex.c	246;"	d	file:
yy_nxt	SDCClex.c	/^static yyconst short yy_nxt[][256] =$/;"	v	file:
yy_pop_state	SDCClex.c	/^static void yy_pop_state()$/;"	f	file:
yy_push_state	SDCClex.c	/^static void yy_push_state( int new_state )$/;"	f	file:
yy_reduce_print	SDCCy.c	/^yy_reduce_print (yyrule)$/;"	f	file:
yy_scan_buffer	SDCClex.c	/^YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )$/;"	f
yy_scan_bytes	SDCClex.c	/^YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )$/;"	f
yy_scan_string	SDCClex.c	/^YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )$/;"	f
yy_set_bol	SDCClex.c	255;"	d	file:
yy_set_interactive	SDCClex.c	248;"	d	file:
yy_size_t	SDCClex.c	/^typedef unsigned int yy_size_t;$/;"	t	file:
yy_stack_print	SDCCy.c	/^yy_stack_print (bottom, top)$/;"	f	file:
yy_start	SDCClex.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_start_stack	SDCClex.c	/^static int *yy_start_stack = 0;$/;"	v	file:
yy_start_stack_depth	SDCClex.c	/^static int yy_start_stack_depth = 0;$/;"	v	file:
yy_start_stack_ptr	SDCClex.c	/^static int yy_start_stack_ptr = 0;$/;"	v	file:
yy_state_type	SDCClex.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	SDCClex.c	/^void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )$/;"	f
yy_top_state	SDCClex.c	/^static int yy_top_state()$/;"	f	file:
yy_try_NUL_trans	SDCClex.c	/^static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )$/;"	f	file:
yyalloc	SDCCy.c	/^union yyalloc$/;"	u	file:
yychar	SDCCy.c	/^    char       yychar[SDCC_NAME_MAX+1];$/;"	m	union:YYSTYPE	file:
yychar	SDCCy.c	/^int yychar;$/;"	v
yychar	SDCCy.h	/^    char       yychar[SDCC_NAME_MAX+1];$/;"	m	union:YYSTYPE
yycheck	SDCCy.c	/^static const short yycheck[] =$/;"	v	file:
yyclearin	SDCCy.c	1443;"	d	file:
yyconst	SDCClex.c	53;"	d	file:
yyconst	SDCClex.c	55;"	d	file:
yydebug	SDCCy.c	/^int yydebug;$/;"	v
yydefact	SDCCy.c	/^static const unsigned short yydefact[] =$/;"	v	file:
yydefgoto	SDCCy.c	/^static const short yydefgoto[] =$/;"	v	file:
yydestruct	SDCCy.c	/^yydestruct (yytype, yyvaluep)$/;"	f	file:
yyerrok	SDCCy.c	1442;"	d	file:
yyerror	SDCClex.c	/^yyerror (char *s)$/;"	f
yyerror	altlex.c	/^yyerror (const char *s)$/;"	f
yyin	SDCClex.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyin	altlex.c	/^FILE *yyin;$/;"	v
yyinput	SDCClex.c	/^static int yyinput()$/;"	f	file:
yyint	SDCCy.c	/^    int        yyint;       \/* integer value returned                 *\/$/;"	m	union:YYSTYPE	file:
yyint	SDCCy.h	/^    int        yyint;       \/* integer value returned                 *\/$/;"	m	union:YYSTYPE
yyleng	SDCClex.c	/^int yyleng;$/;"	v
yyless	SDCClex.c	124;"	d	file:
yyless	SDCClex.c	17122;"	d	file:
yyless	SDCClex.c	17123;"	d	file:
yylex	altlex.c	/^yylex (void)$/;"	f
yylval	SDCCy.c	/^YYSTYPE yylval;$/;"	v
yymore	SDCClex.c	15325;"	d	file:
yynerrs	SDCCy.c	/^int yynerrs;$/;"	v
yyout	SDCClex.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	SDCCy.c	/^static const short yypact[] =$/;"	v	file:
yypgoto	SDCCy.c	/^static const short yypgoto[] =$/;"	v	file:
yyprhs	SDCCy.c	/^static const unsigned short yyprhs[] =$/;"	v	file:
yyr1	SDCCy.c	/^static const unsigned short yyr1[] =$/;"	v	file:
yyr2	SDCCy.c	/^static const unsigned char yyr2[] =$/;"	v	file:
yyrestart	SDCClex.c	/^void yyrestart( FILE *input_file )$/;"	f
yyrhs	SDCCy.c	/^static const short yyrhs[] =$/;"	v	file:
yyrline	SDCCy.c	/^static const unsigned short yyrline[] =$/;"	v	file:
yysigned_char	SDCCy.c	/^   typedef short yysigned_char;$/;"	t	file:
yysigned_char	SDCCy.c	/^   typedef signed char yysigned_char;$/;"	t	file:
yyss	SDCCy.c	/^  short yyss;$/;"	m	union:yyalloc	file:
yystos	SDCCy.c	/^static const unsigned short yystos[] =$/;"	v	file:
yystpcpy	SDCCy.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	SDCCy.c	1648;"	d	file:
yystr	SDCCy.c	/^    const char *yystr;      \/* pointer to dynamicaly allocated string *\/$/;"	m	union:YYSTYPE	file:
yystr	SDCCy.h	/^    const char *yystr;      \/* pointer to dynamicaly allocated string *\/$/;"	m	union:YYSTYPE
yystrlen	SDCCy.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	SDCCy.c	1625;"	d	file:
yystype	SDCCy.c	388;"	d	file:
yystype	SDCCy.h	304;"	d
yysymprint	SDCCy.c	/^yysymprint (yyoutput, yytype, yyvaluep)$/;"	f	file:
yytable	SDCCy.c	/^static const short yytable[] =$/;"	v	file:
yyterminate	SDCClex.c	15491;"	d	file:
yytext	SDCClex.c	/^char *yytext;$/;"	v
yytext	altlex.c	/^char *yytext;$/;"	v
yytext_ptr	SDCClex.c	17221;"	d	file:
yytext_ptr	SDCClex.c	268;"	d	file:
yytname	SDCCy.c	/^static const char *const yytname[] =$/;"	v	file:
yytokentype	SDCCy.c	/^   enum yytokentype {$/;"	g	file:
yytokentype	SDCCy.h	/^   enum yytokentype {$/;"	g
yytoknum	SDCCy.c	/^static const unsigned short yytoknum[] =$/;"	v	file:
yytranslate	SDCCy.c	/^static const unsigned char yytranslate[] =$/;"	v	file:
yyunput	SDCClex.c	/^static void yyunput( int c, register char *yy_bp )$/;"	f	file:
yyvs	SDCCy.c	/^  YYSTYPE yyvs;$/;"	m	union:yyalloc	file:
yywrap	SDCClex.c	/^yywrap (void)$/;"	f
